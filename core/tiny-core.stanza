defpackage core

;;; REQUIRED FOR COMPILER

protected lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
public lostanza deftype Tuple<T> :
  length: long
  var items: ref<T> ...
protected lostanza deftype Box :
   item: ref<?>
protected lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype StackFrame :
  var return: long
  var liveness-map: long
  var slots: long ...
protected lostanza deftype Stack :
  var size: long
  var frames: ptr<StackFrame>
  var stack-pointer: ptr<StackFrame>
  var pc: long
public lostanza deftype Byte :
  value: byte

public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype True
public lostanza deftype False
public deftype List<T>
lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
lostanza deftype NilList <: List<Void>
public lostanza deftype String :
  length: long
  var hash: int
  var chars: byte ...
public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>
public deftype GenSymbol <: Symbol
public deftype Unique

public lostanza deftype LivenessTracker :
  value: ref<False|Unique>
  tail: ptr<?>

var EXECUTION-HALT:() -> Void
defn halt () -> Void : EXECUTION-HALT()
public defn fatal (msg) -> Void : halt()
protected lostanza defn arity-error (arity:long) -> ref<Void> : return fatal(String("AE"))
protected defn no-method-error (multi:String, args:Tuple) : fatal("NME")
protected defn amb-method-error (multi:String, args:Tuple) : fatal("AME")
protected defn amb-branch-error (args:Tuple) : fatal("ABE")
protected lostanza defn tuple-length-error (actual-len:long, expected-len:long) -> ref<Void> : return fatal(String("TLE"))
protected defn no-branch-error (args:Tuple) : fatal("NBE")
protected lostanza defn cast-error (type:ref<Type>, obj:ref<?>, ctxt:int) -> ref<Void> : return fatal(String("CE"))
protected defn variable-uninitialized-error (name:String|False) -> Void : fatal("VUE")
protected lostanza defn invalid-return-error () -> ref<Void> : return fatal(String("IRE"))
protected lostanza defn void-tuple (n:long) -> ref<Tuple> : return new Tuple{n}
protected lostanza defn initialize-constants () -> ref<False> : return false
lostanza defn extend-heap (size:long) -> long : return 0
lostanza defn extend-stack (size:long) -> long : return 0
lostanza defn print-stack-trace (stack:ref<Stack>) -> ref<False> : return false
lostanza defn collect-garbage (size:long) -> long : return 0
lostanza defn class-name (x:int) -> ptr<byte> : return ""
public lostanza defn String (chars:ptr<byte>) -> ref<String> : return new String{1, 0}
defn execute-toplevel-command (f:() -> False) -> True|False : false

;;; APP

; UNSIGNED COMPARISONS

protected extern printf: (ptr<byte>, ? ...) -> int
 
lostanza defn error (msg:ptr<byte>) -> ref<False> :
  call-c printf(msg)
  return false

lostanza defn test () -> ref<False> :
  if ($ls-prim ult 1 2) != 1 :
    error("!!! ERROR: INT ULT 1 2\n")
  if ($ls-prim ult 2 2) != 0 :
    error("!!! ERROR: INT ULT 2 2\n")
  if ($ls-prim ult 3 2) != 0 :
    error("!!! ERROR: INT ULT 3 2\n")
  if ($ls-prim ugt 1 2) != 0 :
    error("!!! ERROR: INT UGT 1 2\n")
  if ($ls-prim ugt 2 2) != 0 :
    error("!!! ERROR: INT UGT 2 2\n")
  if ($ls-prim ugt 3 2) != 1 :
    error("!!! ERROR: INT UGT 3 2\n")
  if ($ls-prim ule 1 2) != 1 :
    error("!!! ERROR: INT ULE 1 2\n")
  if ($ls-prim ule 2 2) != 1 :
    error("!!! ERROR: INT ULE 2 2\n")
  if ($ls-prim ule 3 2) != 0 :
    error("!!! ERROR: INT ULE 3 2\n")
  if ($ls-prim uge 1 2) != 0 :
    error("!!! ERROR: INT UGE 1 2\n")
  if ($ls-prim uge 2 2) != 1 :
    error("!!! ERROR: INT UGE 2 2\n")
  if ($ls-prim uge 3 2) != 1 :
    error("!!! ERROR: INT UGE 3 2\n")
  return false

test()

; ; VARIABLES
; 
; protected extern printf: (ptr<byte>, ? ...) -> int
; 
; lostanza defn dump (msg:ptr<byte>, x:ref<Int>) -> ref<False> :
;   call-c printf(msg, x.value)
;   return false
; 
; lostanza defn error (x:ref<Int>) -> ref<False> :
;   dump("WRONG ANSWER: %d\n", x)
;   return false
; 
; lostanza defn dump (x:ref<Int>) -> ref<False> :
;   dump("ANSWER: %d\n", x)
;   return false
; 
; var num-errors:Int = 0
; 
; defn inc-errors () :
;   num-errors = num-errors + 1
; 
; defn plus (a:Int, b:Int) -> Int : ($prim add a b)
; defn equal? (a:Int, b:Int) -> True|False : ($prim eq a b)
; 
; defn main () :
;   inc-errors()
;   inc-errors()
;   if num-errors == 2 : false
;   else : error(num-errors)
;   dump(num-errors)
; 
; main()

; ; VAR OFFSET DATA
; 
; protected extern printf: (ptr<byte>, ? ...) -> int
; 
; lostanza defn do-error (msg:ptr<byte>) -> ref<False> :
;   call-c printf(msg)
;   return false
; 
; lostanza defn error () -> ref<False> :
;   do-error("WRONG ANSWER\n")
;   ; inc-errors()
;   return false
; 
; lostanza deftype Stuff1 :
;   length : long
;   var data : byte ...
; 
; lostanza defn Stuff1 (n:ref<Int>) -> ref<Stuff1> :
;   return new Stuff1{n.value}
; 
; lostanza defn get (s:ref<Stuff1>, i:ref<Int>) -> ref<Int> :
;   return new Int{s.data[i.value]}
; 
; lostanza defn set (s:ref<Stuff1>, i:ref<Int>, x:ref<Int>) -> ref<False> :
;   s.data[i.value] = x.value as byte
;   return false
; 
; lostanza deftype Stuff4 :
;   length : long
;   var data : int ...
; 
; lostanza defn Stuff4 (n:ref<Int>) -> ref<Stuff4> :
;   return new Stuff4{n.value}
; 
; lostanza defn get (s:ref<Stuff4>, i:ref<Int>) -> ref<Int> :
;   return new Int{s.data[i.value]}
; 
; lostanza defn set (s:ref<Stuff4>, i:ref<Int>, x:ref<Int>) -> ref<False> :
;   s.data[i.value] = x.value
;   return false
; 
; lostanza deftype Stuff8 :
;   length : long
;   var data : long ...
; 
; lostanza defn Stuff8 (n:ref<Int>) -> ref<Stuff8> :
;   return new Stuff8{n.value}
; 
; lostanza defn get (s:ref<Stuff8>, i:ref<Int>) -> ref<Int> :
;   return new Int{s.data[i.value] as int}
; 
; lostanza defn set (s:ref<Stuff8>, i:ref<Int>, x:ref<Int>) -> ref<False> :
;   s.data[i.value] = x.value
;   return false
; 
; defn plus (a:Int, b:Int) -> True|False : ($prim add a b)
; defn equal? (a:Int, b:Int) -> True|False : ($prim eq a b)
; 
; public defn complement (a:True|False) -> True|False :
;   if a : false
;   else : true
; 
; defn test () :
;   val s1 = Stuff1(8)
;   s1[0] = 16
;   if not (s1[0] == 16) : error()
;   val s4 = Stuff4(8)
;   s4[0] = 16
;   if not (s4[0] == 16) : error()
;   val s8 = Stuff8(8)
;   s8[0] = 16
;   if not (s8[0] == 16) : error()
; 
; test()

; ; SIGN EXTENSION
; 
; protected extern printf: (ptr<byte>, ? ...) -> int
;  
; lostanza defn error (msg:ptr<byte>) -> ref<False> :
;   call-c printf(msg)
;   return false
; 
; lostanza defn test () -> ref<False> :
;   if (- 1) != -1 :
;     error("!!! ERROR: INT NEGATION\n")
;   if (1 - 2) != -1 :
;     error("!!! ERROR: INT MINUS\n")
;   if (1 * -1) != -1 :
;     error("!!! ERROR: INT MULTIPLY\n")
;   if (1 / -1) != -1 :
;     error("!!! ERROR: INT DIVIDE\n")
;   if (3 % 2) != 1 :
;     error("!!! ERROR: INT MODULO\n")
;   return false
; 
; test()

; ; EXTEND STACK
; 
; defn minus (a:Int, b:Int) -> Int : ($prim sub a b)
; defn equal? (a:Int, b:Int) -> True|False : ($prim eq a b)
; 
; defn recursive (c:Int) -> Int :
;   if c == 0 :
;     0
;   else :
;     recursive(c - 1)
; 
; defn main () :
;   recursive(1024)
; 
; main()

; ; EXTEND HEAP
; 
; lostanza deftype Stuff :
;   length : long
;   data : long ...
; 
; lostanza defn Stuff (n:ref<Int>) -> ref<Stuff> :
;   return new Stuff{n.value}
; 
; defn minus (a:Int, b:Int) -> Int : ($prim sub a b)
; defn shift-left (a:Int, b:Int) -> Int : ($prim shl a b)
; defn greater? (a:Int, b:Int) -> True|False : ($prim gt a b)
; 
; defn cons (n:Int, s:Int) :
;   let loop (n:Int = n) :
;     if n > 0 :
;       Stuff(s)
;       loop(n - 1)
; 
; defn main () : cons(1, 1 << 24)
; 
; main()

; ; LONGS
; 
; lostanza defn exchange (n:ref<Long>) -> ref<Int> :
;   return new Int{n.value as int}
; 
; defn main () : exchange(256L)
; 
; main()

; ; TAIL CALLS
; 
; protected extern printf: (ptr<byte>, ? ...) -> int
; 
; lostanza defn error (x:ref<Int>) -> ref<False> :
;   call-c printf("WRONG ANSWER: %d\n", x.value)
;   return false
; 
; defn plus (a:Int, b:Int) -> Int : ($prim add a b)
; defn minus (a:Int, b:Int) -> Int : ($prim sub a b)
; defn greater? (a:Int, b:Int) -> True|False : ($prim gt a b)
; defn equal? (a:Int, b:Int) -> True|False : ($prim eq a b)
; public defn complement (a:True|False) -> True|False :
;   if a : false
;   else : true
; 
; defn* sum (n:Int, total:Int) :
;   if n > 0 : sum(n - 1, total + n)
;   else : total
;   
; defn main () :
;   val i = sum(0, 0)
;   val r = sum(10, 0)
;   if not (r == 55) : error(r)
; 
; main()

; ; CLOSURES
; 
; protected extern printf: (ptr<byte>, ? ...) -> int
; 
; lostanza defn debug (x:ref<Int>) -> ref<False> :
;   call-c printf("HELLO WORLD %d\n" x.value)
;   return false
; 
; defn plus (a:Int, b:Int) -> Int :
;   ($prim add a b)
; 
; defn closure (x:Int) :
;   fn () : x + 1
; 
; defn main () :
;   val f = closure(3)
;   debug(f())
; 
; main()

; ;Let loops
; protected extern printf: (ptr<byte>, ? ...) -> int
; 
; lostanza defn debug (x:ref<Int>) -> ref<False> :
;   call-c printf("HELLO WORLD %d\n" x.value)
;   return false
; 
; defn plus (a:Int, b:Int) -> Int :
;   ($prim add a b)
; 
; defn minus (a:Int, b:Int) -> Int :
;   ($prim sub a b)
; 
; defn equal? (a:Int, b:Int) -> True|False :
;   ($prim eq a b)
; 
; defn count-loop (n:Int) -> Int :
;   let loop (c:Int = n) :
;     if c == 0 :
;       n
;     else :
;       loop(c - 1)
; 
; defn count-accumulator (n:Int) -> Int :
;   let loop (c:Int = n, r:Int = 0) :
;     if c == 0 :
;       r
;     else :
;       loop(c - 1, r + 1)
; 
; defn count-recursive (n:Int, c:Int) -> Int :
;   if c == 0 :
;     n
;   else :
;     count-recursive(n, c - 1)
; 
; defn main () :
;   ; debug(count(1 + 2))
;   debug(count-accumulator(3))
;   debug(count-loop(3))
;   debug(count-recursive(3, 3))
;   ; debug(95 + 1) 
; 
; main()

; ; lostanza defn main () -> ref<False> :
; ;   call-c printf("HELLO WORLD\n")
; ;   return false
; ;
; ; main()

; defstruct Person :
;   age : Int
; 
; defn main () :
;   val p = Person(1)
;   age(p)
; 
; main()

; protected extern printf: (ptr<byte>, ? ...) -> int
;  
; lostanza defn error (msg:ptr<byte>) -> ref<False> :
;   call-c printf(msg)
;   return false
; 
; lostanza defn test () -> ref<False> :
;   ;Floats
;   if (- 1.0f) != -1.0f :
;     error("!!! ERROR: FLOAT NEG\n")
;   if (1.0f + 2.0f) != 3.0f :
;     error("!!! ERROR: FLOAT PLUS\n")
;   if (1.0f - 2.0f) != -1.0f :
;     error("!!! ERROR: FLOAT MINUS\n")
;   if (2.0f * 3.0f) != 6.0f :
;     error("!!! ERROR: FLOAT MUL\n")
;   if (6.0f / 3.0f) != 2.0f :
;     error("!!! ERROR: FLOAT DIV\n")
;   if (1.0f < 2.0f) != 0 :
;     error("!!! ERROR: FLOAT LESS\n")
;   if (1.0f > 2.0f) != 0 :
;     error("!!! ERROR: FLOAT GREATER\n")
;   if (1.0f <= 2.0f) != 1 :
;     error("!!! ERROR: FLOAT LESS EQUAL\n")
;   if (1.0f >= 2.0f) != 0 :
;     error("!!! ERROR: FLOAT GREATER EQUAL\n")
; 
;   ;Doubles
;   if (- 1.0) != -1.0 :
;     error("!!! ERROR: DOUBLE NEG\n")
;   if (1.0 + 2.0) != 3.0 :
;     error("!!! ERROR: DOUBLE PLUS\n")
;   if (1.0 - 2.0) != -1.0 :
;     error("!!! ERROR: DOUBLE MINUS\n")
;   if (2.0 * 3.0) != 6.0 :
;     error("!!! ERROR: DOUBLE MUL\n")
;   if (6.0 / 3.0) != 2.0 :
;     error("!!! ERROR: DOUBLE DIV\n")
;   if (1.0 < 2.0) != 0 :
;     error("!!! ERROR: DOUBLE LESS\n")
;   if (1.0 > 2.0) != 0 :
;     error("!!! ERROR: DOUBLE GREATER\n")
;   if (1.0 <= 2.0) != 1 :
;     error("!!! ERROR: DOUBLE LESS EQUAL\n")
;   if (1.0 >= 2.0) != 0 :
;     error("!!! ERROR: DOUBLE GREATER EQUAL\n")
; 
;   ;Conversions
;   if (1L as int) != 1 :
;     error("!!! ERROR: LONG TO INT CONVERSION\n")
;   if (1 as long) != 1L :
;     error("!!! ERROR: INT TO LONG CONVERSION\n")
;   if (1Y as int) != 1 :
;     error("!!! ERROR: BYTE TO INT CONVERSION\n")
;   if (1 as byte) != 1Y :
;     error("!!! ERROR: INT TO BYTE CONVERSION\n")
;   if (1Y as long) != 1L :
;     error("!!! ERROR: BYTE TO LONG CONVERSION\n")
;   if (1L as byte) != 1Y :
;     error("!!! ERROR: LONG TO BYTE CONVERSION\n")
; 
;   if (1.0f as int) != 1 :
;     error("!!! ERROR: FLOAT TO INT CONVERSION\n")
;   if (1 as float) != 1.0f :
;     error("!!! ERROR: INT TO FLOAT CONVERSION\n")
;   if (1.0f as long) != 1L :
;     error("!!! ERROR: FLOAT TO LONG CONVERSION\n")
;   if (1L as float) != 1.0f :
;     error("!!! ERROR: LONG TO FLOAT CONVERSION\n")
;   if (1.0f as byte) != 1Y :
;     error("!!! ERROR: FLOAT TO BYTE CONVERSION\n")
;   if (1Y as float) != 1.0f :
;     error("!!! ERROR: BYTE TO FLOAT CONVERSION\n")
; 
;   if (1.0 as int) != 1 :
;     error("!!! ERROR: DOUBLE TO INT CONVERSION\n")
;   if (1 as double) != 1.0 :
;     error("!!! ERROR: INT TO DOUBLE CONVERSION\n")
;   if (1.0 as long) != 1L :
;     error("!!! ERROR: DOUBLE TO LONG CONVERSION\n")
;   if (1L as double) != 1.0 :
;     error("!!! ERROR: LONG TO DOUBLE CONVERSION\n")
;   if (1.0 as byte) != 1Y :
;     error("!!! ERROR: DOUBLE TO BYTE CONVERSION\n")
;   if (1Y as double) != 1.0 :
;     error("!!! ERROR: BYTE TO DOUBLE CONVERSION\n")
;   if (1.0 as float) != 1.0f :
;     error("!!! ERROR: DOUBLE TO FLOAT CONVERSION\n")
;   if (1.0f as double) != 1.0 :
;     error("!!! ERROR: FLOAT TO DOUBLE CONVERSION\n")
; 
;   if (1Y + 2Y) != 3Y :
;     error("!!! ERROR: BYTE PLUS\n")
;   if (3Y - 2Y) != 1Y :
;     error("!!! ERROR: BYTE MINUS\n")
;   ; if (2Y * 3Y) != 6Y :
;   ;   error("!!! ERROR: BYTE MUL\n")
;   ; if (6Y / 3Y) != 2Y :
;   ;   error("!!! ERROR: BYTE DIV\n")
;   ; if (5Y % 2Y) != 1Y :
;   ;   error("!!! ERROR: BYTE MOD\n")
;   if (3Y & 2Y) != 2Y :
;     error("!!! ERROR: BYTE AND\n")
;   if (3Y | 2Y) != 3Y :
;     error("!!! ERROR: BYTE OR\n")
;   if (3Y ^ 2Y) != 1Y :
;     error("!!! ERROR: BYTE XOR\n")
;   if (3Y << 2Y) != 12Y :
;     error("!!! ERROR: BYTE SHL\n")
;   if (12Y >> 2Y) != 3Y :
;     error("!!! ERROR: BYTE SHR\n")
;   if (1Y < 2Y) != 1Y :
;     error("!!! ERROR: BYTE LESS\n")
;   if (1Y > 2Y) != 0Y :
;     error("!!! ERROR: BYTE GREATER\n")
;   if (1Y <= 2Y) != 1Y :
;     error("!!! ERROR: BYTE LESS EQUAL\n")
;   if (1Y >= 2Y) != 0Y :
;     error("!!! ERROR: BYTE GREATER EQUAL\n")
; 
;   if (1 + 2) != 3 :
;     error("!!! ERROR: INT PLUS\n")
;   if (1 - 2) != -1 :
;     error("!!! ERROR: INT MINUS\n")
;   if (2 * 3) != 6 :
;     error("!!! ERROR: INT MUL\n")
;   if (6 / 3) != 2 :
;     error("!!! ERROR: INT DIV\n")
;   if (5 % 2) != 1 :
;     error("!!! ERROR: INT MOD\n")
;   if (3 & 2) != 2 :
;     error("!!! ERROR: INT AND\n")
;   if (3 | 2) != 3 :
;     error("!!! ERROR: INT OR\n")
;   if (3 ^ 2) != 1 :
;     error("!!! ERROR: INT XOR\n")
;   if (3 << 2) != 12 :
;     error("!!! ERROR: INT SHL\n")
;   if (12 >> 2) != 3 :
;     error("!!! ERROR: INT SHR\n")
;   if (-12 >>> 2) != -3 :
;     error("!!! ERROR: INT ASHR\n")
;   if (1 < 2) != 1 :
;     error("!!! ERROR: INT LESS\n")
;   if (1 > 2) != 0 :
;     error("!!! ERROR: INT GREATER\n")
;   if (1 <= 2) != 1 :
;     error("!!! ERROR: INT LESS EQUAL\n")
;   if (1 >= 2) != 0 :
;     error("!!! ERROR: INT GREATER EQUAL\n")
; 
;   if (1L + 2L) != 3L :
;     error("!!! ERROR: LONG PLUS\n")
;   if (1L - 2L) != -1L :
;     error("!!! ERROR: LONG MINUS\n")
;   if (2L * 3L) != 6L :
;     error("!!! ERROR: LONG MUL\n")
;   if (6L / 3L) != 2L :
;     error("!!! ERROR: LONG DIV\n")
;   if (5L % 2L) != 1L :
;     error("!!! ERROR: LONG MOD\n")
;   if (3L & 2L) != 2L :
;     error("!!! ERROR: LONG AND\n")
;   if (3L | 2L) != 3L :
;     error("!!! ERROR: LONG OR\n")
;   if (3L ^ 2L) != 1L :
;     error("!!! ERROR: LONG XOR\n")
;   if (3L << 2L) != 12L :
;     error("!!! ERROR: LONG SHL\n")
;   if (12L >> 2L) != 3L :
;     error("!!! ERROR: LONG SHR\n")
;   if (-12L >>> 2L) != -3L :
;     error("!!! ERROR: LONG ASHR\n")
;   if (1L < 2L) != 1L :
;     error("!!! ERROR: LONG LESS\n")
;   if (1L > 2L) != 0L :
;     error("!!! ERROR: LONG GREATER\n")
;   if (1L <= 2L) != 1L :
;     error("!!! ERROR: LONG LESS EQUAL\n")
;   if (1L >= 2L) != 0L :
;     error("!!! ERROR: LONG GREATER EQUAL\n")
;   return false
; 
; test()

; ;DEFSTRUCT
; protected extern printf: (ptr<byte>, ? ...) -> int
;  
; lostanza defn debug (x:ref<Int>) -> ref<False> :
;   call-c printf("HELLO WORLD %llx\n" x.value)
;   return false
; 
; defstruct Person :
;   age : Int
; 
; debug(age(Person(11)))

; ;DEFN DISPATCH
; protected extern printf: (ptr<byte>, ? ...) -> int
;  
; lostanza defn debug (x:ref<Int>) -> ref<False> :
;   call-c printf("HELLO WORLD %llx\n" x.value)
;   return false
; 
; defn plus (a:Int, b:Int) -> Int : ($prim add a b)
; 
; defn f (a:Int) : a + 1
; defn f (a:Float) : a
;  
; defn g (a:Int|Float) : f(a)
; 
; debug(g(1) as Int)

; ;MULTI DISPATCH
; protected extern printf: (ptr<byte>, ? ...) -> int
;  
; lostanza defn debug (x:ref<Int>) -> ref<False> :
;   call-c printf("HELLO WORLD %llx\n" x.value)
;   return false
; 
; defn plus (a:Int, b:Int) -> Int : ($prim add a b)
; 
; defmulti f (a:?) -> Int|Float
; defmethod f (a:Int) : a + 1
; defmethod f (a:Float) : a
;  
; defn g (a:Int|Float) : f(a)
; 
; debug(g(1) as Int)
