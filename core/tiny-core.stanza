defpackage core

;;; REQUIRED FOR COMPILER

protected lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
public lostanza deftype Tuple<T> :
  length: long
  var items: ref<T> ...
protected lostanza deftype Box :
   item: ref<?>
protected lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
protected lostanza deftype StackFrame :
  var return: long
  var liveness-map: long
  var slots: long ...
protected lostanza deftype Stack :
  var size: long
  var frames: ptr<StackFrame>
  var stack-pointer: ptr<StackFrame>
  var pc: long
public lostanza deftype Byte :
  value: byte

public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype True
public lostanza deftype False
public deftype List<T>
lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
lostanza deftype NilList <: List<Void>
public lostanza deftype String :
  length: long
  var hash: int
  var chars: byte ...
public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>
public deftype GenSymbol <: Symbol
public deftype Unique

public lostanza deftype LivenessTracker :
  value: ref<False|Unique>
  tail: ptr<?>

var EXECUTION-HALT:() -> Void
defn halt () -> Void : EXECUTION-HALT()
public defn fatal (msg) -> Void : halt()
protected lostanza defn arity-error (arity:long) -> ref<Void> : return fatal(String("AE"))
protected defn no-method-error (multi:String, args:Tuple) : fatal("NME")
protected defn amb-method-error (multi:String, args:Tuple) : fatal("AME")
protected defn amb-branch-error (args:Tuple) : fatal("ABE")
protected lostanza defn tuple-length-error (actual-len:long, expected-len:long) -> ref<Void> : return fatal(String("TLE"))
protected defn no-branch-error (args:Tuple) : fatal("NBE")
protected lostanza defn cast-error (type:ref<Type>, obj:ref<?>, ctxt:int) -> ref<Void> : return fatal(String("CE"))
protected defn variable-uninitialized-error (name:String|False) -> Void : fatal("VUE")
protected lostanza defn invalid-return-error () -> ref<Void> : return fatal(String("IRE"))
protected lostanza defn void-tuple (n:long) -> ref<Tuple> : return new Tuple{n}
protected lostanza defn initialize-constants () -> ref<False> : return false
lostanza defn extend-heap (size:long) -> long : return 0
lostanza defn extend-stack (size:long) -> long : return 0
lostanza defn print-stack-trace (stack:ref<Stack>) -> ref<False> : return false
lostanza defn collect-stack-trace (stack:ref<Stack>) -> ref<False> : return false
lostanza defn collect-garbage (size:long) -> long : return 0
lostanza defn class-name (x:int) -> ptr<byte> : return ""
public lostanza defn String (chars:ptr<byte>) -> ref<String> : return new String{1, 0}
defn execute-toplevel-command (f:() -> False) -> True|False : f()

;;; APP

; STANDARD SUPPORT

protected extern printf: (ptr<byte>, ? ...) -> int
protected extern memcpy: (ptr<?>, ptr<?>, long) -> ptr<?>
 
public defn minus (a:Int, b:Int) -> Int : ($prim sub a b)
public defn plus (a:Int, b:Int) -> Int : ($prim add a b)
public defn equal? (a:Int, b:Int) -> True|False : ($prim eq a b)
defn byte-equal? (a:Byte, b:Byte) -> True|False :
  ($prim identical? a b)
defn char-equal? (a:Char, b:Char) -> True|False :
  ($prim identical? a b)
lostanza defn long-equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false
public defn greater? (a:Int, b:Int) -> True|False : ($prim gt a b)

public defn complement (a:True|False) -> True|False :
  if a : false
  else : true

defn not-equal? (a:Int, b:Int) -> True|False : not (a == b)
defn not-equal? (a:True|False, b:True|False) -> True|False : not ($prim identical? a b)

var num-errors:Int = 0

defn inc-errors () :
  num-errors = num-errors + 1

public lostanza defn plop (x:ref<Int>) -> ref<False> :
  call-c printf("DUMP: %d\n", x.value)
  return false

lostanza defn dump (msg:ptr<byte>) -> ref<False> :
  call-c printf(msg)
  return false

lostanza defn dump (msg:ptr<byte>, x:ref<Int>) -> ref<False> :
  call-c printf(msg, x.value)
  return false

lostanza defn dump (msg:ptr<byte>, x:ref<Int>, y:ref<Int>) -> ref<False> :
  call-c printf(msg, x.value, y.value)
  return false

lostanza defn error (msg:ptr<byte>) -> ref<False> :
  call-c printf(msg)
  inc-errors()
  return false

lostanza defn error (t:ref<Int>, n:ref<Int>, e:ref<Int>) -> ref<False> :
  call-c printf("!!! WRONG ANSWER %d/%d: %d\n", t.value, n.value, e.value)
  inc-errors()
  return false

lostanza defn report-errors () -> ref<False> :
  dump("\n===>>> NUM-ERRORS %d <<<===\n\n" num-errors)
  return false

; UNSIGNED COMPARISONS

lostanza defn f0 () -> ref<False> :
  return dump("=== UNSIGNED COMPARISONS\n")
f0()

lostanza defn test-unsigned-int-comparisons () -> ref<False> :
  if ($ls-prim ult -1 2) != 0 :
    error("!!! ERROR: INT ULT -1 2\n")
  if ($ls-prim ult 1 -2) != 1 :
    error("!!! ERROR: INT ULT 1 -2\n")
  if ($ls-prim ult 1 2) != 1 :
    error("!!! ERROR: INT ULT 1 2\n")
  if ($ls-prim ult 2 2) != 0 :
    error("!!! ERROR: INT ULT 2 2\n")
  if ($ls-prim ult 3 2) != 0 :
    error("!!! ERROR: INT ULT 3 2\n")
  if ($ls-prim ugt -1 2) != 1 :
    error("!!! ERROR: INT UGT -1 2\n")
  if ($ls-prim ugt 1 -2) != 0 :
    error("!!! ERROR: INT UGT 1 -2\n")
  if ($ls-prim ugt 1 2) != 0 :
    error("!!! ERROR: INT UGT 1 2\n")
  if ($ls-prim ugt 2 2) != 0 :
    error("!!! ERROR: INT UGT 2 2\n")
  if ($ls-prim ugt 3 2) != 1 :
    error("!!! ERROR: INT UGT 3 2\n")
  if ($ls-prim ule -1 2) != 0 :
    error("!!! ERROR: INT ULE -1 2\n")
  if ($ls-prim ule 1 -2) != 1 :
    error("!!! ERROR: INT ULE 1 -2\n")
  if ($ls-prim ule 1 2) != 1 :
    error("!!! ERROR: INT ULE 1 2\n")
  if ($ls-prim ule 2 2) != 1 :
    error("!!! ERROR: INT ULE 2 2\n")
  if ($ls-prim ule 3 2) != 0 :
    error("!!! ERROR: INT ULE 3 2\n")
  if ($ls-prim uge -1 2) != 1 :
    error("!!! ERROR: INT UGE -1 2\n")
  if ($ls-prim uge 1 -2) != 0 :
    error("!!! ERROR: INT UGE 1 -2\n")
  if ($ls-prim uge 1 2) != 0 :
    error("!!! ERROR: INT UGE 1 2\n")
  if ($ls-prim uge 2 2) != 1 :
    error("!!! ERROR: INT UGE 2 2\n")
  if ($ls-prim uge 3 2) != 1 :
    error("!!! ERROR: INT UGE 3 2\n")
  return false

lostanza defn test-unsigned-long-comparisons () -> ref<False> :
  if ($ls-prim ult -1L 2L) != 0 :
    error("!!! ERROR: LONG ULT -1 2\n")
  if ($ls-prim ult 1L -2L) != 1 :
    error("!!! ERROR: LONG ULT 1 -2\n")
  if ($ls-prim ult 1L 2L) != 1 :
    error("!!! ERROR: LONG ULT 1 2\n")
  if ($ls-prim ult 2L 2L) != 0 :
    error("!!! ERROR: LONG ULT 2 2\n")
  if ($ls-prim ult 3L 2L) != 0 :
    error("!!! ERROR: LONG ULT 3 2\n")
  if ($ls-prim ugt -1L 2L) != 1 :
    error("!!! ERROR: LONG UGT -1 2\n")
  if ($ls-prim ugt 1L -2L) != 0 :
    error("!!! ERROR: LONG UGT 1 -2\n")
  if ($ls-prim ugt 1L 2L) != 0 :
    error("!!! ERROR: LONG UGT 1 2\n")
  if ($ls-prim ugt 2L 2L) != 0 :
    error("!!! ERROR: LONG UGT 2 2\n")
  if ($ls-prim ugt 3L 2L) != 1 :
    error("!!! ERROR: LONG UGT 3 2\n")
  if ($ls-prim ule -1L 2L) != 0 :
    error("!!! ERROR: LONG ULE -1 2\n")
  if ($ls-prim ule 1L -2L) != 1 :
    error("!!! ERROR: LONG ULE 1 -2\n")
  if ($ls-prim ule 1L 2L) != 1 :
    error("!!! ERROR: LONG ULE 1 2\n")
  if ($ls-prim ule 2L 2L) != 1 :
    error("!!! ERROR: LONG ULE 2 2\n")
  if ($ls-prim ule 3L 2L) != 0 :
    error("!!! ERROR: LONG ULE 3 2\n")
  if ($ls-prim uge -1L 2L) != 1 :
    error("!!! ERROR: LONG UGE -1 2\n")
  if ($ls-prim uge 1L -2L) != 0 :
    error("!!! ERROR: LONG UGE 1 -2\n")
  if ($ls-prim uge 1L 2L) != 0 :
    error("!!! ERROR: LONG UGE 1 2\n")
  if ($ls-prim uge 2L 2L) != 1 :
    error("!!! ERROR: LONG UGE 2 2\n")
  if ($ls-prim uge 3L 2L) != 1 :
    error("!!! ERROR: LONG UGE 3 2\n")
  return false

test-unsigned-int-comparisons()
test-unsigned-long-comparisons()

; VARIABLES

lostanza defn f1 () -> ref<False> :
  return dump("=== VARIABLES\n")
f1()

var num:Int = 0

defn inc-num () :
  num = num + 1

defn variable-test () :
  inc-num()
  inc-num()
  if num == 2 : false
  else : error(2, 1, num)

variable-test()

; TAG TESTS

lostanza defn f2 () -> ref<False> :
  return dump("=== TAG\n")
f2()

lostanza defn fab-byte (i:ref<Int>) -> ref<Byte> :
  return new Byte{i.value as byte}

lostanza defn fab-long (i:ref<Int>) -> ref<Long> :
  return new Long{i.value}

lostanza defn fab-float (x:ref<Float>) -> ref<Float> :
  return new Float{x.value}

lostanza defn fab-char (i:ref<Int>) -> ref<Char> :
  return new Char{i.value as byte}

lostanza defn long-tag-test () -> ref<False> :
  val l = fab-long(new Int{65})
  if l.value != 65L : error(new Int{12}, new Int{1}, new Int{0})
  return false

lostanza defn float-tag-test () -> ref<False> :
  val f = fab-float(new Float{65.0f})
  if f.value != 65.0f : error(new Int{12}, new Int{4}, new Int{0})
  return false

defn tag-tests () :
  if not byte-equal?(fab-byte(65), 65Y) : error(12, 0, 0)
  long-tag-test()
  if not char-equal?(fab-char(65), 'A') : error(12, 2, 0)
  float-tag-test()

tag-tests()

; LOSTANZA DEFN FIELDS OFFSET DATA

lostanza defn f3 () -> ref<False> :
  return dump("=== LOSTANZA FIELDS OFFSET\n")
f3()

lostanza deftype Stuff1 :
  var x : byte

lostanza defn Stuff1 (x:ref<Int>) -> ref<Stuff1> :
  return new Stuff1{x.value as byte}

lostanza defn x (s:ref<Stuff1>) -> ref<Int> :
  return new Int{s.x as int}

lostanza defn set-x (s:ref<Stuff1>, x:ref<Int>) -> ref<False> :
  s.x = x.value as byte
  return false

lostanza deftype Stuff4 :
  var x : int

lostanza defn Stuff4 (x:ref<Int>) -> ref<Stuff4> :
  return new Stuff4{x.value}

lostanza defn x (s:ref<Stuff4>) -> ref<Int> :
  return new Int{s.x}

lostanza defn set-x (s:ref<Stuff4>, x:ref<Int>) -> ref<False> :
  s.x = x.value
  return false

lostanza deftype Stuff8 :
  var x : long

lostanza defn Stuff8 (x:ref<Int>) -> ref<Stuff8> :
  return new Stuff8{x.value as long}

lostanza defn x (s:ref<Stuff8>) -> ref<Int> :
  return new Int{s.x as int}

lostanza defn set-x (s:ref<Stuff8>, x:ref<Int>) -> ref<False> :
  s.x = x.value as int
  return false

defn lostanza-struct-fields-test () :
  val s1 = Stuff1(8)
  val r1i = x(s1)
  if not (r1i == 8) : error(3, 1, r1i)
  set-x(s1, 16)
  val r1 = x(s1)
  if not (r1 == 16) : error(3, 2, r1)
  val s4 = Stuff4(8)
  set-x(s4, 16)
  val r4 = x(s4)
  if not (r4 == 16) : error(3, 4, r4)
  val s8 = Stuff8(8)
  set-x(s8, 16)
  val r8 = x(s8)
  if not (r8 == 16) : error(3, 5, r8)

lostanza-struct-fields-test()

; LOSTANZA STRUCT VAR OFFSET DATA

lostanza defn f4 () -> ref<False> :
  return dump("=== LOSTANZA STRUCT VAR\n")
f4()

lostanza deftype Repeated1 :
  length : long
  var data : byte ...

lostanza defn Repeated1 (n:ref<Int>) -> ref<Repeated1> :
  return new Repeated1{n.value}

lostanza defn length (s:ref<Repeated1>) -> ref<Int> :
  return new Int{s.length as int}

lostanza defn get (s:ref<Repeated1>, i:ref<Int>) -> ref<Int> :
  return new Int{s.data[i.value]}

lostanza defn set (s:ref<Repeated1>, i:ref<Int>, x:ref<Int>) -> ref<False> :
  s.data[i.value] = x.value as byte
  return false

lostanza deftype Repeated4 :
  length : long
  var data : int ...

lostanza defn Repeated4 (n:ref<Int>) -> ref<Repeated4> :
  return new Repeated4{n.value}

lostanza defn get (s:ref<Repeated4>, i:ref<Int>) -> ref<Int> :
  return new Int{s.data[i.value]}

lostanza defn set (s:ref<Repeated4>, i:ref<Int>, x:ref<Int>) -> ref<False> :
  s.data[i.value] = x.value
  return false

lostanza deftype Repeated8 :
  length : long
  var data : long ...

lostanza defn Repeated8 (n:ref<Int>) -> ref<Repeated8> :
  return new Repeated8{n.value}

lostanza defn get (s:ref<Repeated8>, i:ref<Int>) -> ref<Int> :
  return new Int{s.data[i.value] as int}

lostanza defn set (s:ref<Repeated8>, i:ref<Int>, x:ref<Int>) -> ref<False> :
  s.data[i.value] = x.value
  return false

defn lostanza-var-fields-test () :
  val s1 = Repeated1(8)
  val r1i = length(s1)
  if not (r1i == 8) : error(4, 1, r1i)
  s1[0] = 16
  val r1 = s1[0]
  if not (r1 == 16) : error(4, 2, r1)
  val s4 = Repeated4(8)
  s4[0] = 16
  val r4 = s4[0]
  if not (r4 == 16) : error(4, 3, r4)
  val s8 = Repeated8(8)
  s8[0] = 16
  val r8 = s8[0]
  if not (r8 == 16) : error(4, 4, r8)

lostanza-var-fields-test()

; SIGN EXTENSION

lostanza defn f5 () -> ref<False> :
  return dump("=== SIGN EXTENSION\n")
f5()

lostanza defn sign-extension-test () -> ref<False> :
  if (- 1) != -1 :
    error("!!! ERROR: INT NEGATION\n")
  if (1 - 2) != -1 :
    error("!!! ERROR: INT MINUS\n")
  if (1 * -1) != -1 :
    error("!!! ERROR: INT MULTIPLY\n")
  if (1 / -1) != -1 :
    error("!!! ERROR: INT DIVIDE\n")
  if (3 % 2) != 1 :
    error("!!! ERROR: INT MODULO\n")
  return false

sign-extension-test()

; ; EXTEND STACK
; 
; defn recursive (c:Int) -> Int :
;   if c == 0 :
;     0
;   else :
;     recursive(c - 1)
; 
; defn extend-stack-test () :
;   recursive(1024)
; 
; extend-stack-test()

; ; EXTEND HEAP
; 
; lostanza deftype Stuff :
;   length : long
;   data : long ...
; 
; lostanza defn Stuff (n:ref<Int>) -> ref<Stuff> :
;   return new Stuff{n.value}
; 
; defn minus (a:Int, b:Int) -> Int : ($prim sub a b)
; defn shift-left (a:Int, b:Int) -> Int : ($prim shl a b)
; defn greater? (a:Int, b:Int) -> True|False : ($prim gt a b)
; 
; defn cons (n:Int, s:Int) :
;   let loop (n:Int = n) :
;     if n > 0 :
;       Stuff(s)
;       loop(n - 1)
; 
; defn extend-heap-test () : cons(1, 1 << 24)
; 
; extend-heap-test()

; ; LONGS
; 
; lostanza defn exchange (n:ref<Long>) -> ref<Int> :
;   return new Int{n.value as int}
; 
; defn main () : exchange(256L)
; 
; main()

; TAIL CALLS

lostanza defn f6 () -> ref<False> :
  return dump("=== TAIL CALLS\n")
f6()

defn* sum (n:Int, total:Int) :
  if n > 0 : sum(n - 1, total + n)
  else : total
  
defn tail-calls-test () :
  val i = sum(0, 0)
  val r = sum(10, 0)
  if not (r == 55) : error(5, 1, r)

tail-calls-test()

; CLOSURES

lostanza defn f7 () -> ref<False> :
  return dump("=== CLOSURES\n")
f7()

defn closure (x:Int) :
  fn () : x + 1

defn closures-test () :
  val f = closure(3)
  val r = f()
  if not (r == 4) : error(6, 1, r)

closures-test()

; LET LOOPS

lostanza defn f8 () -> ref<False> :
  return dump("=== LET LOOPS\n")
f8()

defn count-loop (n:Int) -> Int :
  let loop (c:Int = n) :
    if c == 0 :
      n
    else :
      loop(c - 1)

defn count-accumulator (n:Int) -> Int :
  let loop (c:Int = n, r:Int = 0) :
    if c == 0 :
      r
    else :
      loop(c - 1, r + 1)

defn count-recursive (n:Int, c:Int) -> Int :
  if c == 0 :
    n
  else :
    count-recursive(n, c - 1)

defn let-loops-test () :
  val r1 = count-accumulator(4)
  if not (r1 == 4) : error(7, 1, r1)
  val r2 = count-loop(5)
  if not (r2 == 5) : error(7, 2, r2)
  val r3 = count-recursive(3, 3)
  if not (r3 == 3) : error(7, 3, r3)

let-loops-test()

; STRUCTS

lostanza defn f9 () -> ref<False> :
  return dump("=== STRUCTS\n")
f9()

defstruct Person :
  age : Int

defn structs-test () :
  val p = Person(1)
  val r1 = age(p)
  if not (r1 == 1) : error(8, 1, r1)

structs-test()

; ARITHMETIC

lostanza defn f10 () -> ref<False> :
  return dump("=== INT ARITHMETIC\n")
f10()

defn int-arithmetic-tests () :
  if not ($prim eq 1 1) :
    error(11, 0, 0)
  if ($prim eq 0 1) :
    error(11, 1, 0)
  if ($prim add 1 2) != 3 :
    error(11, 2, 0)
  if ($prim sub 1 2) != -1 :
    error(11, 3, 0)
  if ($prim mul 2 3) != 6 :
    error(11, 4, 0)
  if ($prim div 6 3) != 2 :
    error(11, 5, 0)
  val r6 = ($prim mod 5 2)
  if r6 != 1 :
    error(11, 6, r6)
  if ($prim and 3 2) != 2 :
    error(11, 7, 0)
  if ($prim or 3 2) != 3 :
    error(11, 8, 0)
  if ($prim xor 3 2) != 1 :
    error(11, 9, 0)
  if ($prim shl 3 2) != 12 :
    error(11, 10, 0)
  if ($prim shr 12 2) != 3 :
    error(11, 11, 0)
  if ($prim ashr -12 2) != -3 :
    error(11, 12, 0)
  if ($prim lt 1 2) != true :
    error(11, 13, 0)
  if ($prim gt 1 2) != false :
    error(11, 14, 0)
  if ($prim le 1 2) != true :
    error(11, 15, 0)
  if ($prim ge 1 2) != false :
    error(11, 16, 0)
  if ($prim neg 1) != -1 :
    error(11, 17, 0)
  if ($prim not 0) != 0xffffffff :
    error(11, 18, 0)
  
int-arithmetic-tests()

lostanza defn f11 () -> ref<False> :
  return dump("=== ARITHMETIC\n")
f11()

lostanza defn arithmetic-tests () -> ref<False> :
  ;Floats
  if (1.0f == 1.0f) != 1 :
    error("!!! ERROR: FLOAT EQUAL? 1.0 1.0\n")
  if (0.0f == 1.0f) != 0 :
    error("!!! ERROR: FLOAT EQUAL? 0.0 1.0\n")
  if (- 1.0f) != -1.0f :
    error("!!! ERROR: FLOAT NEG\n")
  if (1.0f + 2.0f) != 3.0f :
    error("!!! ERROR: FLOAT PLUS\n")
  if (1.0f - 2.0f) != -1.0f :
    error("!!! ERROR: FLOAT MINUS\n")
  if (2.0f * 3.0f) != 6.0f :
    error("!!! ERROR: FLOAT MUL\n")
  if (6.0f / 3.0f) != 2.0f :
    error("!!! ERROR: FLOAT DIV\n")
  if (1.0f < 2.0f) != 1 :
    error("!!! ERROR: FLOAT LESS\n")
  if (1.0f > 2.0f) != 0 :
    error("!!! ERROR: FLOAT GREATER\n")
  if (1.0f <= 2.0f) != 1 :
    error("!!! ERROR: FLOAT LESS EQUAL\n")
  if (1.0f >= 2.0f) != 0 :
    error("!!! ERROR: FLOAT GREATER EQUAL\n")

  ;Doubles
  if (1.0 == 1.0) != 1 :
    error("!!! ERROR: DOUBLE EQUAL? 1.0 1.0\n")
  if (0.0 == 1.0) != 0 :
    error("!!! ERROR: DOUBLE EQUAL? 0.0 1.0\n")
  if (- 1.0) != -1.0 :
    error("!!! ERROR: DOUBLE NEG\n")
  if (1.0 + 2.0) != 3.0 :
    error("!!! ERROR: DOUBLE PLUS\n")
  if (1.0 - 2.0) != -1.0 :
    error("!!! ERROR: DOUBLE MINUS\n")
  if (2.0 * 3.0) != 6.0 :
    error("!!! ERROR: DOUBLE MUL\n")
  if (6.0 / 3.0) != 2.0 :
    error("!!! ERROR: DOUBLE DIV\n")
  if (1.0 < 2.0) != 1 :
    error("!!! ERROR: DOUBLE LESS\n")
  if (1.0 > 2.0) != 0 :
    error("!!! ERROR: DOUBLE GREATER\n")
  if (1.0 <= 2.0) != 1 :
    error("!!! ERROR: DOUBLE LESS EQUAL\n")
  if (1.0 >= 2.0) != 0 :
    error("!!! ERROR: DOUBLE GREATER EQUAL\n")

  if (1Y == 1Y) != 1 :
    error("!!! ERROR: BYTE EQUAL? 1 1\n")
  if (0Y == 1Y) != 0 :
    error("!!! ERROR: BYTE EQUAL? 0 1\n")
  if (~ (0 as byte)) != 255Y :
    error("!!! ERROR: BYTE NOT\n")
  if (1Y + 2Y) != 3Y :
    error("!!! ERROR: BYTE PLUS\n")
  if (3Y - 2Y) != 1Y :
    error("!!! ERROR: BYTE MINUS\n")
  if ((2 as byte) * (3 as byte)) != 6Y :
    error("!!! ERROR: BYTE MUL\n")
  if ((6 as byte) / (3 as byte)) != 2Y :
    error("!!! ERROR: BYTE DIV\n")
  if ((5 as byte) % (2 as byte)) != 1Y :
    error("!!! ERROR: BYTE MOD\n")
  if (3Y & 2Y) != 2Y :
    error("!!! ERROR: BYTE AND\n")
  if (3Y | 2Y) != 3Y :
    error("!!! ERROR: BYTE OR\n")
  if (3Y ^ 2Y) != 1Y :
    error("!!! ERROR: BYTE XOR\n")
  if (3Y << 2Y) != 12Y :
    error("!!! ERROR: BYTE SHL\n")
  if (12Y >> 2Y) != 3Y :
    error("!!! ERROR: BYTE SHR\n")
  if (1Y < 2Y) != 1 :
    error("!!! ERROR: BYTE LESS\n")
  if (1Y > 2Y) != 0 :
    error("!!! ERROR: BYTE GREATER\n")
  if (1Y <= 2Y) != 1 :
    error("!!! ERROR: BYTE LESS EQUAL\n")
  if (1Y >= 2Y) != 0 :
    error("!!! ERROR: BYTE GREATER EQUAL\n")

  if (1 == 1) != 1 :
    error("!!! ERROR: INT EQUAL? 1 1\n")
  if (0 == 1) != 0 :
    error("!!! ERROR: INT EQUAL? 0 1\n")
  if (~ 0) != 0xffffffff :
    error("!!! ERROR: INT NOT\n")
  if (- 1) != -1 :
    error("!!! ERROR: INT NEG\n")
  if (1 + 2) != 3 :
    error("!!! ERROR: INT PLUS\n")
  if (1 - 2) != -1 :
    error("!!! ERROR: INT MINUS\n")
  if (2 * 3) != 6 :
    error("!!! ERROR: INT MUL\n")
  if (6 / 3) != 2 :
    error("!!! ERROR: INT DIV\n")
  if (5 % 2) != 1 :
    error("!!! ERROR: INT MOD\n")
  if (3 & 2) != 2 :
    error("!!! ERROR: INT AND\n")
  if (3 | 2) != 3 :
    error("!!! ERROR: INT OR\n")
  if (3 ^ 2) != 1 :
    error("!!! ERROR: INT XOR\n")
  if (3 << 2) != 12 :
    error("!!! ERROR: INT SHL\n")
  if (12 >> 2) != 3 :
    error("!!! ERROR: INT SHR\n")
  if (-12 >>> 2) != -3 :
    error("!!! ERROR: INT ASHR\n")
  if (1 < 2) != 1 :
    error("!!! ERROR: INT LESS\n")
  if (1 > 2) != 0 :
    error("!!! ERROR: INT GREATER\n")
  if (1 <= 2) != 1 :
    error("!!! ERROR: INT LESS EQUAL\n")
  if (1 >= 2) != 0 :
    error("!!! ERROR: INT GREATER EQUAL\n")

  if (1L == 1L) != 1 :
    error("!!! ERROR: LONG EQUAL? 1 1\n")
  if (0L == 1L) != 0 :
    error("!!! ERROR: LONG EQUAL? 0 1\n")
  if (~ 0L) != 0xffffffffffffffffL :
    error("!!! ERROR: LONG NOT\n")
  if (- 1L) != -1L :
    error("!!! ERROR: LONG NEG\n")
  if (1L + 2L) != 3L :
    error("!!! ERROR: LONG PLUS\n")
  if (1L - 2L) != -1L :
    error("!!! ERROR: LONG MINUS\n")
  if (2L * 3L) != 6L :
    error("!!! ERROR: LONG MUL\n")
  if (6L / 3L) != 2L :
    error("!!! ERROR: LONG DIV\n")
  if (5L % 2L) != 1L :
    error("!!! ERROR: LONG MOD\n")
  if (3L & 2L) != 2L :
    error("!!! ERROR: LONG AND\n")
  if (3L | 2L) != 3L :
    error("!!! ERROR: LONG OR\n")
  if (3L ^ 2L) != 1L :
    error("!!! ERROR: LONG XOR\n")
  if (3L << 2L) != 12L :
    error("!!! ERROR: LONG SHL\n")
  if (12L >> 2L) != 3L :
    error("!!! ERROR: LONG SHR\n")
  if (-12L >>> 2L) != -3L :
    error("!!! ERROR: LONG ASHR\n")
  if (1L < 2L) != 1L :
    error("!!! ERROR: LONG LESS\n")
  if (1L > 2L) != 0L :
    error("!!! ERROR: LONG GREATER\n")
  if (1L <= 2L) != 1L :
    error("!!! ERROR: LONG LESS EQUAL\n")
  if (1L >= 2L) != 0L :
    error("!!! ERROR: LONG GREATER EQUAL\n")
  return false

arithmetic-tests()

lostanza defn f12 () -> ref<False> :
  return dump("=== CONVERSIONS\n")
f12()

lostanza defn conversion-tests () -> ref<False> :
  ;Conversions
  if (1L as int) != 1 :
    error("!!! ERROR: LONG TO INT CONVERSION\n")
  if (1 as long) != 1L :
    error("!!! ERROR: INT TO LONG CONVERSION\n")
  if (1Y as int) != 1 :
    call-c printf("BYTE TO INT %d\n", 1Y as int)
    error("!!! ERROR: BYTE TO INT CONVERSION\n")
  if (1 as byte) != 1Y :
    error("!!! ERROR: INT TO BYTE CONVERSION\n")
  if (1Y as long) != 1L :
    call-c printf("BYTE TO LONG %lld EQ? %d\n", (1Y as long), (1Y as long) == 1L)
    error("!!! ERROR: BYTE TO LONG CONVERSION\n")
  if (1L as byte) != 1Y :
    error("!!! ERROR: LONG TO BYTE CONVERSION\n")

  if (1.0f as int) != 1 :
    error("!!! ERROR: FLOAT TO INT CONVERSION\n")
  if (1 as float) != 1.0f :
    error("!!! ERROR: INT TO FLOAT CONVERSION\n")
  if (1.0f as long) != 1L :
    error("!!! ERROR: FLOAT TO LONG CONVERSION\n")
  if (1L as float) != 1.0f :
    error("!!! ERROR: LONG TO FLOAT CONVERSION\n")
  if (1.0f as byte) != 1Y :
    error("!!! ERROR: FLOAT TO BYTE CONVERSION\n")
  if (1Y as float) != 1.0f :
    error("!!! ERROR: BYTE TO FLOAT CONVERSION\n")

  if (1.0 as int) != 1 :
    error("!!! ERROR: DOUBLE TO INT CONVERSION\n")
  if (1 as double) != 1.0 :
    error("!!! ERROR: INT TO DOUBLE CONVERSION\n")
  if (1.0 as long) != 1L :
    error("!!! ERROR: DOUBLE TO LONG CONVERSION\n")
  if (1L as double) != 1.0 :
    error("!!! ERROR: LONG TO DOUBLE CONVERSION\n")
  if (1.0 as byte) != 1Y :
    error("!!! ERROR: DOUBLE TO BYTE CONVERSION\n")
  if (1Y as double) != 1.0 :
    error("!!! ERROR: BYTE TO DOUBLE CONVERSION\n")
  if (1.0 as float) != 1.0f :
    error("!!! ERROR: DOUBLE TO FLOAT CONVERSION\n")
  if (1.0f as double) != 1.0 :
    error("!!! ERROR: FLOAT TO DOUBLE CONVERSION\n")
  return false

conversion-tests()

; OVERLOADED FUNCTIONS

lostanza defn f13 () -> ref<False> :
  return dump("=== OVERLOADED FUNCTIONS\n")
f13()

defn f (a:Int) : a + 1
defn f (a:Float) : a
 
defn g (a:Int|Float) : f(a)

defn overloaded-functions-test () :
  val r1 = (g(1) as Int)
  if not (r1 == 2) : error(9, 1, r1)

overloaded-functions-test()

; MULTI DISPATCH

lostanza defn f14 () -> ref<False> :
  return dump("=== MULTI DISPATCH\n")
f14()

defmulti m (a:?) -> Int|Float
defmethod m (a:Int) : a + 1
defmethod m (a:Float) : a
 
defn mg (a:Int|Float) : m(a)

defn multi-methods-test () :
  val r1 = (mg(1) as Int)
  if not (r1 == 2) : error(10, 1, r1)

multi-methods-test()

; lostanza defn jump-tests () -> ref<False> :
;   if 1 < 2 :
;     error("!!! ERROR: INT LESS? 1 2\n")
;   return false
; 
; jump-tests()

; BIG MULTI DISPATCH

lostanza defn f15 () -> ref<False> :
  return dump("=== BIG MULTI DISPATCH\n")
f15()

public deftype Comparable<T> :
  Char <: Comparable<Char>
  Byte <: Comparable<Byte>
  Int <: Comparable<Int>
  Long <: Comparable<Long>
  Float <: Comparable<Float>
  Double <: Comparable<Double>

public defmulti l?<?T> (a:Comparable<?T>, b:T) -> True|False

defmethod l?<?T> (a:Comparable<?T>, b:T) : false

lostanza defmethod l? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod l? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

defmethod l? (a:Int, b:Int) -> True|False :
  ($prim lt a b)

lostanza defmethod l? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod l? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod l? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

defn big-multi-methods-test () :
  val r1 = l?(1, 2)
  if not r1 : error(16, 0, 0)
  val r2 = l?('a', 'b')
  if not r2 : error(16, 1, 0)

big-multi-methods-test()

lostanza deftype Fudge :
  var pool-index:int

lostanza defn test-fudge () -> ref<False> :
  val f = new Fudge{-1}
  if f.pool-index != -1 :
    call-c printf("BAD POOL INDEX %d\n", f.pool-index)
  return false

test-fudge()

report-errors()

defpackage math :
   import core

public lostanza val PI:ref<Double> = new Double{3.141592653589793}

defpackage collections :
  import core

deftype Sentinel