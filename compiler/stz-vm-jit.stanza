defpackage stz/vm-jit :
  import core
  import collections
  import stz/vm-ir
  import stz/typeset
  import stz/vm-ids
  import stz/basic-ops
  import stz/call-records
  import stz/backend
  import stz/utils
  import stz/set-utils
  import stz/conversion-utils
  import stz/dispatch-dag
  import stz/asmjit
  import core/stack-trace

val debugging? = false
val tracing? = false

defn plop (x) : println(x) when debugging?

extern c_trampoline: (ptr<?>, ptr<?>, ptr<?>) -> int

defn hex (n:Long) -> String :
  var chars:List<Char> = List()
  let loop (n:Long = n) :
    if n != 0L :
      val temp = to-int(n % 16L)
      val c = to-char(temp + 48) when (temp < 10) else to-char(temp + 55)
      chars = cons(c, chars)
      loop(n / 16L)
  val buf = StringBuffer()
  add-all(buf, chars)
  to-string(buf)

defn hex (n:Int) -> String : hex(to-long(n))

;TODO: DUMMY
defn Func (rt:JitRuntime) -> Func :
  add(rt, code-holder-new(rt))

public deftype EncodingResolver
public defmulti liveness-map (r:EncodingResolver, live:Tuple<Int>, num-locals:Int) -> Int
public defmulti object-header-size (r:EncodingResolver) -> Int
public defmulti object-size-on-heap (r:EncodingResolver, sz:Int) -> Int
public defmulti stack-size (r:EncodingResolver) -> Int
public defmulti dispatch-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti match-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti method-format (r:EncodingResolver, multi:Int, num-header-args:Int, num-args:Int) -> Int
public defmulti marker (r:EncodingResolver, type:Int) -> Int
public defmulti void-marker (r:EncodingResolver) -> Int
public defmulti ref-offset (r:EncodingResolver) -> Int
public defmulti type-is-final? (r:EncodingResolver, n:Int) -> True|False
public defmulti marker? (r:EncodingResolver, n:Int) -> True|False
public defmulti tagbits (r:EncodingResolver, typeid:Int) -> Int

public defstruct EncodedFunction :
  func: Func
  trace-entries: Vector<TraceTableEntry>

public defstruct TraceTableEntry :
  pc: Int
  entry: StackTraceEntry

public defn value (ef:EncodedFunction) -> Long :
  value(func(ef))
  
defn c-params () : [rdi(), rsi(), rdx(), rcx(), r8(), r9()]

defn bind-parameters (a:Assembler, args:Seqable<Gp>) :
  val params = c-params()
  ;TODO: CHECK NOT TOO MANY ARGS
  for (param in params, arg in args) do :
    mov(a, param, arg)

; extern c_trampoline_stub: (long, ptr<long>, ptr<long>) -> int

lostanza defn c-call (a:ref<Assembler>, faddr:ref<Long>, args:ref<Tuple<Gp>>) -> ref<Gp> :
  caller-save-registers(a)
  bind-parameters(a, args)
  mov(a, tmp1(), faddr)
  call(a, tmp1())
  caller-restore-registers(a)
  return rax()

lostanza defn c-trampoline-addr () -> ref<Long> :
  return new Long{addr!(c_trampoline) as long}

defn c-trampoline (a:Assembler, faddr:Gp, registers:Gp, returns:Gp) :
  c-call(a, c-trampoline-addr(), [faddr, registers, returns])

extern read_dispatch_table: (ptr<?>, int) -> int

lostanza defn read-dispatch-table-addr () -> ref<Long> :
  return new Long{addr!(read_dispatch_table) as long}

defn read-dispatch-table (a:Assembler, dst:Gp, vmstate:Gp, format:Gp) -> Gp :
  c-call(a, read-dispatch-table-addr(), [vmstate, format])
  mov(a, dst, rax())
  dst

extern call_garbage_collector: (ptr<?>, long) -> int

lostanza defn call-garbage-collector-addr () -> ref<Long> :
  return new Long{addr!(call_garbage_collector) as long}

defn call-garbage-collector (a:Assembler, vmstate:Gp, size:Gp) -> Gp :
  c-call(a, call-garbage-collector-addr(), [vmstate, size])

extern call_print_stack_trace: (ptr<?>, long) -> int

lostanza defn call-print-stack-trace-addr () -> ref<Long> :
  return new Long{addr!(call_print_stack_trace) as long}

defn call-print-stack-trace (a:Assembler, vmstate:Gp, stack:Gp) -> Gp :
  c-call(a, call-print-stack-trace-addr(), [vmstate, stack])

extern call_collect_stack_trace: (ptr<?>, long) -> int

lostanza defn call-collect-stack-trace-addr () -> ref<Long> :
  return new Long{addr!(call_collect_stack_trace) as long}

defn call-collect-stack-trace (a:Assembler, vmstate:Gp, stack:Gp) -> Gp :
  c-call(a, call-collect-stack-trace-addr(), [vmstate, stack])

extern retrieve_class_name: (ptr<?>, long) -> int

lostanza defn retrieve-class-name-addr () -> ref<Long> :
  return new Long{addr!(retrieve_class_name) as long}

defn retrieve-class-name (a:Assembler, vmstate:Gp, stack:Gp) -> Gp :
  c-call(a, retrieve-class-name-addr(), [vmstate, stack])

val SIZEOF-BYTE = 1
val SIZEOF-INT  = 4
val SIZEOF-LONG = 8

defn vmstate-get (a:Assembler, offset:Int, dst:Gp) -> Gp :
  mov(a, dst, MemPtr(vmstate(), offset))
  dst
defn vmstate-get (a:Assembler, offset:Int) -> Gp :
  vmstate-get(a, offset, rcx())

defn vmstate-set (a:Assembler, offset:Int, value:Gp) :
  mov(a, MemPtr(vmstate(), offset), value)

val vmstate-offsets = Counter(0)
val VMSTATE-INSTRUCTIONS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-REGISTERS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-GLOBAL-OFFSETS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-GLOBAL-MEM-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-CONST-TABLE-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-CONST-MEM-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-DATA-OFFSETS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-DATA-MEM-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-FUNCTIONS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-HEAP-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-HEAP-TOP-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-HEAP-LIMIT-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-FREE-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-FREE-LIMIT-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-CURRENT-STACK-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-SYSTEM-STACK-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-SYSTEM-REGISTERS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-TRIE-TABLE-OFFSET = next(vmstate-offsets, SIZEOF-LONG)

defn get-instructions (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-INSTRUCTIONS-OFFSET, dst)
defn set-instructions (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-INSTRUCTIONS-OFFSET, value)
defn get-registers (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-REGISTERS-OFFSET, dst)
defn set-registers (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-REGISTERS-OFFSET, value)
defn get-global-offsets (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-GLOBAL-OFFSETS-OFFSET, dst)
defn set-global-offsets (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-GLOBAL-OFFSETS-OFFSET, value)
defn get-global-mem (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-GLOBAL-MEM-OFFSET, dst)
defn set-global-mem (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-GLOBAL-MEM-OFFSET, value)
defn get-const-table (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-CONST-TABLE-OFFSET, dst)
defn set-const-table (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-CONST-TABLE-OFFSET, value)
defn get-const-mem (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-CONST-MEM-OFFSET, dst)
defn set-const-mem (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-CONST-MEM-OFFSET, value)
defn get-data-offsets (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-DATA-OFFSETS-OFFSET, dst)
defn set-data-offsets (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-DATA-OFFSETS-OFFSET, value)
defn get-data-mem (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-DATA-MEM-OFFSET, dst)
defn set-data-mem (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-DATA-MEM-OFFSET, value)
defn get-functions (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-FUNCTIONS-OFFSET, dst)
defn set-functions (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-FUNCTIONS-OFFSET, value)
defn get-heap (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-HEAP-OFFSET, dst)
defn set-heap (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-HEAP-OFFSET, value)
defn get-heap-top (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-HEAP-TOP-OFFSET, dst)
defn set-heap-top (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-HEAP-TOP-OFFSET, value)
defn get-heap-limit (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-HEAP-LIMIT-OFFSET, dst)
defn set-heap-limit (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-HEAP-LIMIT-OFFSET, value)
defn get-free (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-FREE-OFFSET, dst)
defn set-free (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-FREE-OFFSET, value)
defn get-free-limit (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-FREE-LIMIT-OFFSET, dst)
defn set-free-limit (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-FREE-LIMIT-OFFSET, value)
defn get-current-stack (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-CURRENT-STACK-OFFSET, dst)
defn set-current-stack (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-CURRENT-STACK-OFFSET, value)
defn get-system-stack (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-SYSTEM-STACK-OFFSET, dst)
defn set-system-stack (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-SYSTEM-STACK-OFFSET, value)
defn get-system-registers (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-SYSTEM-REGISTERS-OFFSET, dst)
defn set-system-registers (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-SYSTEM-REGISTERS-OFFSET, value)
defn get-trie-table (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-TRIE-TABLE-OFFSET, dst)
defn set-trie-table (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-TRIE-TABLE-OFFSET, value)

defn stack-frame-get (a:Assembler, offset:Int, dst:Gp) -> Gp :
  mov(a, dst, MemPtr(stack-pointer(), offset))
  dst
defn stack-frame-get (a:Assembler, offset:Int) -> Gp :
  stack-frame-get(a, offset, rcx())

defn stack-frame-set (a:Assembler, offset:Int, value:Gp) :
  mov(a, MemPtr(stack-pointer(), offset), value)

val stack-frame-offsets = Counter(0)
val STACK-FRAME-RETURN-OFFSET = next(stack-frame-offsets, SIZEOF-LONG)
val STACK-FRAME-LIVENESS-MAP-OFFSET = next(stack-frame-offsets, SIZEOF-LONG)
val SIZEOF-STACK-FRAME = value(stack-frame-offsets)
val STACK-FRAME-SLOTS-OFFSET = next(stack-frame-offsets, SIZEOF-LONG)

defn get-return (a:Assembler, dst:Gp) : stack-frame-get(a, STACK-FRAME-RETURN-OFFSET, dst)
defn set-return (a:Assembler, value:Gp) : stack-frame-set(a, STACK-FRAME-RETURN-OFFSET, value)
defn get-liveness-map (a:Assembler, dst:Gp) : stack-frame-get(a, STACK-FRAME-LIVENESS-MAP-OFFSET, dst)
defn set-liveness-map (a:Assembler, value:Gp) : stack-frame-set(a, STACK-FRAME-LIVENESS-MAP-OFFSET, value)
; defn get-slots (a:Assembler, dst:Gp) : stack-frame-get(a, STACK-FRAME-SLOTS-OFFSET, dst)
; defn set-slots (a:Assembler, value:Gp) : stack-frame-set(a, STACK-FRAME-SLOTS-OFFSET, value)

defn stack-get (a:Assembler, offset:Int, dst:Gp) -> Gp :
  mov(a, dst, MemPtr(stk(), offset))
  dst
defn stack-get (a:Assembler, offset:Int) -> Gp :
  stack-get(a, offset, rcx())

defn stack-set (a:Assembler, offset:Int, value:Gp) :
  mov(a, MemPtr(stk(), offset), value)

val stack-offsets = Counter(0)
val STACK-SIZE-OFFSET = next(stack-offsets, SIZEOF-LONG)
val STACK-FRAMES-OFFSET = next(stack-offsets, SIZEOF-LONG)
val STACK-STACK-POINTER-OFFSET = next(stack-offsets, SIZEOF-LONG)
val STACK-PC-OFFSET = next(stack-offsets, SIZEOF-LONG)

defn get-size (a:Assembler, dst:Gp) : stack-get(a, STACK-SIZE-OFFSET, dst)
defn set-size (a:Assembler, value:Gp) : stack-set(a, STACK-SIZE-OFFSET, value)
defn get-frames (a:Assembler, dst:Gp) : stack-get(a, STACK-FRAMES-OFFSET, dst)
defn set-frames (a:Assembler, value:Gp) : stack-set(a, STACK-FRAMES-OFFSET, value)
defn get-stack-pointer (a:Assembler, dst:Gp) : stack-get(a, STACK-STACK-POINTER-OFFSET, dst)
defn set-stack-pointer (a:Assembler, value:Gp) : stack-set(a, STACK-STACK-POINTER-OFFSET, value)
defn get-pc (a:Assembler, dst:Gp) : stack-get(a, STACK-PC-OFFSET, dst)
defn set-pc (a:Assembler, value:Gp) : stack-set(a, STACK-PC-OFFSET, value)

val function-offsets = Counter(0)
val FUNCTION-NUM-SLOTS-OFFSET = next(function-offsets, SIZEOF-LONG)
val FUNCTION-CODE-OFFSET = next(function-offsets, SIZEOF-LONG)
val FUNCTION-SLOTS-OFFSET = next(function-offsets, SIZEOF-LONG)

defn vmstate () :        r8()
defn registers () :      r9()
defn stack-pointer () :  r10()
defn stk () :            r11()
defn functions () :      r12()
defn tmp1 () :           r13()
defn tmp2 () :           r14()
defn tmp1i () :          r13d()
defn tmp2i () :          r14d()
defn tmp1b () :          r13b()
defn tmp2b () :          r14b()
defn tmp3 () :           r15()
defn tmp3i () :          r15d()
defn tmp3b () :          r15b()
; defn caller-saved-registers () : [r8(), r9(), r10(), r11(), rdx()] ;TODO: this is what the C calling convention says you have to save
defn caller-saved-registers () : [vmstate(), registers(), functions(), stack-pointer(), stk(), tmp1(), tmp2(), tmp3()]
defn etc-saved-registers () : [vmstate(), registers(), functions(), stack-pointer(), stk(), tmp1(), tmp2(), tmp3()]
defn low-saved-registers () : [rbx(), rcx(), rsi(), rdi() rdx()]
defn all-saved-registers () : cat(low-saved-registers(), caller-saved-registers())

defn untag-stack (a:Assembler, dst:Gp, stk:Gp) -> Gp :
  lea(a, dst, MemPtr(stk, 8 - 1))
  dst
defn untag-stack (a:Assembler, stk:Gp) -> Gp :
  untag-stack(a, tmp1(), stk)

val INT-TAG-BITS = 0
val REF-TAG-BITS = 1
val MARKER-TAG-BITS = 2
val BYTE-TAG-BITS = 3
val CHAR-TAG-BITS = 4
val FLOAT-TAG-BITS = 5

val SYSTEM-RETURN-STUB = -2

defn do-BOOLREF (a:Assembler, x:Gp) -> Gp :
  dump(a, "BOOLREF %d -> " x) when debugging?
  shl(a, x, 3)
  add(a, x, MARKER-TAG-BITS)
  dump(a, "%p\n" x) when debugging?
  x

extern malloc: (long) -> ptr<?>
extern strcpy: (ptr<byte>, ptr<byte>) -> ptr<?>
extern printf: (ptr<byte>, ? ...) -> int

lostanza defn printf-format (s:ref<String>) -> ref<Long> :
  val n = length(s)
  val d = call-c malloc(n.value + 1)
  call-c strcpy(d, addr!(s.chars))
  return new Long{d as long}

lostanza defn printf-addr () -> ref<Long> :
  return new Long{addr!(printf) as long}

defn etc-save-registers (a:Assembler) :
  for reg in etc-saved-registers() do :
    push(a, reg)

defn etc-restore-registers (a:Assembler) :
  for reg in reverse $ to-list $ etc-saved-registers() do :
    pop(a, reg)

defn caller-save-registers (a:Assembler) :
  for reg in caller-saved-registers() do :
    push(a, reg)

defn caller-restore-registers (a:Assembler) :
  for reg in reverse $ to-list $ caller-saved-registers() do :
    pop(a, reg)

defn all-save-registers (a:Assembler) :
  for reg in all-saved-registers() do :
    push(a, reg)

defn all-restore-registers (a:Assembler) :
  for reg in reverse $ to-list $ all-saved-registers() do :
    pop(a, reg)

defn dump (a:Assembler, format:String, a0:Gp, a1:Gp, a2:Gp) :
  all-save-registers(a)
  mov(a, r8(), printf-format(format))
  mov(a, r9(), a0)
  mov(a, r10(), a1)
  mov(a, r11(), a2)
  mov(a, rdi(), r8())
  mov(a, rsi(), r9())
  mov(a, rdx(), r10())
  mov(a, rcx(), r11())
  mov(a, rax(), 0L)
  mov(a, tmp1(), printf-addr())
  call(a, tmp1())
  all-restore-registers(a)

defn dump (a:Assembler, format:String) : dump(a, format, rax(), rax(), rax())
defn dump (a:Assembler, format:String, a0:Gp) : dump(a, format, a0, rax(), rax())
defn dump (a:Assembler, format:String, a0:Gp, a1:Gp) : dump(a, format, a0, a1, rax())

extern dump_registers: () -> int

lostanza defn dump-registers (a:ref<Assembler>) -> ref<False> :
  caller-save-registers(a)
  mov(a, tmp1(), new Long{addr!(dump_registers) as long})
  call(a, tmp1())
  caller-restore-registers(a)
  return false

extern dump_memory_8: (ptr<long>, int) -> int

lostanza defn dump-memory-8-addr () -> ref<Long> :
  return new Long{addr!(dump_memory_8) as long}

extern dump_memory_32: (ptr<int>, int) -> int

lostanza defn dump-memory-32-addr () -> ref<Long> :
  return new Long{addr!(dump_memory_32) as long}

extern dump_memory_64: (ptr<long>, int) -> int

lostanza defn dump-memory-64-addr () -> ref<Long> :
  return new Long{addr!(dump_memory_64) as long}

lostanza defn dump-memory-x (a:ref<Assembler>, faddr:ref<Long>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  caller-save-registers(a)
  mov(a, rdi(), start)
  mov(a, rsi(), n)
  mov(a, rax(), new Long{0L})
  mov(a, tmp1(), faddr)
  call(a, tmp1())
  caller-restore-registers(a)
  return false

lostanza defn dump-memory-8 (a:ref<Assembler>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  return dump-memory-x(a, dump-memory-8-addr(), start, n)

lostanza defn dump-memory-32 (a:ref<Assembler>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  return dump-memory-x(a, dump-memory-32-addr(), start, n)

lostanza defn dump-memory-64 (a:ref<Assembler>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  return dump-memory-x(a, dump-memory-64-addr(), start, n)

public defn make-jit-launch (rt:JitRuntime, vms:Long, init-id:Int) -> Func :
  val code = code-holder-new(rt)
  val a = assembler-new(code)
  ; SEGFAULT
  ; mov(a, rax(), 0L)
  ; mov(a, rax(), MemPtr(rax(), 0, 0))
  ; Setup JIT registers
  val out? = debugging? ; or tracing?
  mov(a, tmp1(), c-params()[0])
  push(a, tmp1()) ;PUSHING RSP
  dump(a, "JIT CRSP TMP1 %p SP %p\n" tmp1(), rsp()) when out?
  mov(a, tmp1(), MemPtr(rsp(), 0))
  dump(a, "JIT CRSP SP[0] %p\n" tmp1()) when out?
  mov(a, vmstate(), vms)
  dump(a, "JIT VMSTATE %p\n" vmstate()) when out?
  get-registers(a, registers())
  get-functions(a, functions())
  untag-stack(a, stk(), get-current-stack(a, tmp1()))
  dump(a, "JIT STK %p\n" stk()) when out?
  ; dump-memory-64(a, stk(), 4L)
  get-stack-pointer(a, stack-pointer())
  dump(a, "JIT STACK-POINTER %p\n" stack-pointer()) when out?
  dump(a, "REGISTERS:\n") when out?
  dump-memory-64(a, get-registers(a, rcx()), 4L) when out?
  dump(a, "CONST-TABLE:\n") when out?
  dump-memory-64(a, get-const-table(a, rcx()), 16L) when out?

  val ret-label = new-label(a)
  lea(a, tmp2(), MemPtr(ret-label))
  dump(a, "RET-LABEL %p\n" tmp2()) when out?
  set-return(a, tmp2())
  ; set-instructions(a, CONST(a, tmp1(), 0))
  ; call init
  plop("INIT-ID %_" % [init-id])
  dump(a, "INIT-ID %d" CONST(a, tmp1(), init-id)) when out?
  get-heap-top(a, tmp1())
  dump(a, "%p\n", tmp1()) when (out? or tracing?)
  get-global-mem(a, tmp1())
  dump(a, ">>> %p\n", tmp1()) when (out? or tracing?)
  mov(a, tmp1(), MemPtr(functions(), init-id * SIZEOF-LONG))
  dump(a, "JMP %p\n", tmp1()) when (out? or tracing?)
  jmp(a, tmp1())
  bind(a, ret-label)
  dump(a, "RET-LABEL\n") when out?
  dump(a, "JIT STACK-POINTER %p\n" stack-pointer()) when out?
  SAVE-STATE-ONLY(a)
  pop(a, tmp1()) ;POPPING CRSP
  ret(a)
  add(rt, code)
  ; TODO: CLEANUP

defn CONST (a:Assembler, x:Gp, id:Int|Long) -> Gp :
  mov(a, x, id)
  x
defn SET-REG (a:Assembler, r:Int, v:Gp) :
  mov(a, MemPtr(registers(), r * SIZEOF-LONG), v)
  dump(a, "SET-REG[%d] = %p\n", CONST(a, rax(), r), v) when tracing?

defn dump-stack-frame (a:Assembler, sp:Gp) :
  dump(a, "STACK-FRAME:\n") when debugging?
  dump-memory-64(a, sp, 3L) when debugging?

defn dump-state (a:Assembler, msg:String) :
  if debugging? :
    dump(a, msg)
    dump-memory-64(a, vmstate(), 17L)
    dump(a, "REGISTERS:     %p\n", registers())
    dump(a, "STK:           %p\n", stk())
    dump(a, "STACK-POINTER: %p\n", stack-pointer())
    dump-memory-64(a, stack-pointer(), 6L)

defn SAVE-STATE-ONLY (a:Assembler) :
  set-stack-pointer(a, stack-pointer())

defn SAVE-STATE (a:Assembler) :
  SAVE-STATE-ONLY(a)
  etc-save-registers(a)

defn RESTORE-STATE (a:Assembler) :
  etc-restore-registers(a)
  untag-stack(a, stk(), get-current-stack(a, tmp1()))
  get-stack-pointer(a, stack-pointer())

public defn make-extend-stack-launch (rt:JitRuntime, stack-overflow-return:Func) -> Func : 
  val end-label = tmp2()
  val size-required = tmp3()
  val code = code-holder-new(rt)
  val a = assembler-new(code)
  dump(a, "EXTEND-STACK %p LABEL %p\n", size-required, end-label) 
  ;Save current stack
  set-stack-pointer(a, stack-pointer())
  set-pc(a, end-label)
  dump(a, "SAVING STK %p PC %p\n", stk(), end-label) 
  ;Swap stack and registers
  get-current-stack(a, tmp1())
  set-current-stack(a, get-system-stack(a, rax()))
  set-system-stack(a, tmp1())
  set-registers(a, get-system-registers(a, rax()))
  set-system-registers(a, registers())
  ;Restore stack state
  untag-stack(a, stk(), get-current-stack(a, tmp1()))
  get-stack-pointer(a, stack-pointer())
  get-registers(a, registers())
  ;Set arguments
  SET-REG(a, 0, do-BOOLREF(a, CONST(a, tmp1(), 0)))
  SET-REG(a, 1, CONST(a, tmp1(), 1))
  SET-REG(a, 1, size-required)
  get-frames(a, stack-pointer())
  set-return(a, CONST(a, tmp1(), value(stack-overflow-return)))
  mov(a, tmp2(), MemPtr(functions(), SIZEOF-LONG * EXTEND-STACK-FN))
  jmp(a, tmp2())
  add(rt, code)

public defn make-extend-stack-return (rt:JitRuntime) -> Func :
  val code = code-holder-new(rt)
  val a = assembler-new(code)
  ;System stack no longer needed
  dump(a, "EXTEND-STACK-RETURN\n") ; when debugging?
  set-stack-pointer(a, CONST(a, tmp1(), 0))
  dump(a, "SWAP-STACK-AND-REGISTERS\n") ; when debugging?
  ;Swap stack and registers
  get-current-stack(a, tmp1())
  set-current-stack(a, get-system-stack(a, rax()))
  set-system-stack(a, tmp1())
  set-registers(a, get-system-registers(a, rax()))
  set-system-registers(a, registers())
  dump(a, "RESTORE-STACK-STATE\n") ; when debugging?
  ;Restore stack state
  untag-stack(a, stk(), get-current-stack(a, tmp1()))
  get-stack-pointer(a, stack-pointer())
  get-registers(a, registers())
  ;Continue where we were
  get-pc(a, tmp1())
  dump(a, "CONTINUE WHERE WE LEFT OFF STK %p PC %p\n", stk(), tmp1()) ; when debugging?
  jmp(a, tmp1())
  add(rt, code)

defn compute-stack-limit (a:Assembler, dst:Gp) -> Gp :
  get-frames(a, dst)
  get-size(a, tmp1())
  add(a, dst,    tmp1())
  dst

val covered = IntSet()
public defn opcode-coverage () -> IntSet : covered

public defn encode (fid:Int, func:VMFunction,
                    rt:JitRuntime,
                    resolver:EncodingResolver,
                    extend-stack-launch:Func,
                    extend-stack-return:Func,
                    backend:Backend) -> EncodedFunction :
  val extend-stack-launch-value = value(extend-stack-launch)
  val code = code-holder-new(rt)
  val a = assembler-new(code)
    
  plop("--- ENCODING %_" % [fid])

  defn CONST (x:Gp, id:Int|Long) -> Gp : (mov(a, x, to-long(id)), x)
  defn CONST (id:Int|Long) -> Gp : CONST(tmp1(), id)
  defn BOOLREF (x:Gp) -> Gp : do-BOOLREF(a, x)

  dump(a, "--- ENTERING FUNC %d\n" CONST(fid)) when debugging?

  defn stack-limit (dst:Gp) :    compute-stack-limit(a, dst)
  defn heap-top (dst:Gp) :       get-heap-top(a, dst)
  defn heap-limit (dst:Gp) :     get-heap-limit(a, dst)
  defn global-offsets (dst:Gp) : get-global-offsets(a, dst)
  defn global-mem (dst:Gp) :     get-global-mem(a, dst)
  defn data-offsets (dst:Gp) :   get-data-offsets(a, dst)
  defn data-mem (dst:Gp) :       get-data-mem(a, dst)
  defn const-table (dst:Gp) :    get-const-table(a, dst)
  defn const-mem (dst:Gp) :      get-const-mem(a, dst)

  ;Encode instructions into this byte buffer
  ;TODO: REMOVE
  val buffer = ByteBuffer()
  defn buffer-pos () : write-position(buffer) / 4

  ;Accumulate file information entries for implementing
  ;stack traces.
  val trace-entry-table = Vector<TraceTableEntry>()
  defn record-trace-entry (entry:StackTraceEntry|False) :
    match(entry:StackTraceEntry) :
      dump(a, "+++ %s\n", CONST(tmp1(), printf-format(to-string(entry)))) when debugging?
      add(trace-entry-table, TraceTableEntry(buffer-pos(), entry))

  ;Calculation of sizes
  defn object-size (num-obj:Int, size-on-heap:Int) :
    num-obj * object-header-size(resolver) + size-on-heap
  defn stack-size () :
    object-size(1, /stack-size(resolver))

  ;Split a tuple of VMBranch into typesets and destinations
  defn split-types-and-dests (bs:Tuple<VMBranch>) -> [Tuple<Tuple<TypeSet>>, Tuple<Int>] :
    val types = map(types, bs)
    val targets = map(n, bs)
    [types, targets]

  ;Check whether type is final.
  ;If the function returns true, it means that the type cannot be redefined.
  defn type-is-final? (t:TypeSet) :
    match(t) :
      (t:SingleType) : /type-is-final?(resolver, type(t))
      (t:OrType) : all?(type-is-final?, types(t))
      (t:AndType) : any?(type-is-final?, types(t))
      (t:TopType) : true

  ;Check whether all types in branch are final.
  defn branch-is-final? (b:VMBranch) :
    all?(type-is-final?, types(b))

  defn GET-CRSP (dst:Gp) -> Gp :
    mov(a, dst, MemPtr(rsp(), 0))
    dst
  defn GET-REG (dst:Gp, r:Int) :
    mov(a, dst, MemPtr(registers(), r * SIZEOF-LONG))
    dst
  defn SET-REG (r:Int, v:Gp) :
    mov(a, MemPtr(registers(), r * SIZEOF-LONG), v)
    dump(a, "SET-REG[%d] = %p\n", CONST(rax(), r), v) when debugging?
    dump(a, "  SET-REG[%d] = %p\n", CONST(rax(), r), v) when tracing?
  defn SET-REG-INT (r:Int, v:Gp) :
    movsxd(a, v, v)
    SET-REG(r, v)
  defn SET-LOCAL (l:Int, v:Gp) :
    mov(a, MemPtr(stack-pointer(), l * SIZEOF-LONG + STACK-FRAME-SLOTS-OFFSET), v)
    dump(a, "  SET-LOCAL[%d] = %p\n", CONST(rax(), l), v) when debugging? 
    dump(a, "  SET-LOCAL[%d] = %p\n", CONST(rax(), l), v) when tracing? 
  defn SET-LOCAL-BYTE (l:Int, v:Gp) :
    and-op(a, v, 0xff)
    SET-LOCAL(l, v)
  defn SET-LOCAL-INT (l:Int, v:Gp) :
    movsxd(a, v, v)
    SET-LOCAL(l, v)
  defn SET-LOCAL-FLOAT (l:Int,v:Xmm) :
    movsd(a, MemPtr(stack-pointer(), l * SIZEOF-LONG + STACK-FRAME-SLOTS-OFFSET), v)
    dump(a, "SET-LOCAL-FLOAT[%d] %p\n", CONST(rax(), l), LOCAL(tmp1(), l)) when debugging? 
  defn SET-LOCAL-DOUBLE (l:Int, v:Xmm) :
    movsd(a, MemPtr(stack-pointer(), l * SIZEOF-LONG + STACK-FRAME-SLOTS-OFFSET), v)
    false

  defn LOCAL (dst:Gp, l:Int) -> Gp :
    mov(a, dst, MemPtr(stack-pointer(), l * SIZEOF-LONG + STACK-FRAME-SLOTS-OFFSET)) 
    dst
  defn LOCAL (l:Int) -> Gp : LOCAL(tmp2(), l)
  defn LOCAL-FLOAT (dst:Xmm, l:Int) -> Xmm :
    movss(a, dst, MemPtr(stack-pointer(), l * SIZEOF-LONG + STACK-FRAME-SLOTS-OFFSET, SIZEOF-INT))
    dst
  defn LOCAL-FLOAT (l:Int) -> Xmm :
    LOCAL-FLOAT(xmm0(), l)
  defn LOCAL-DOUBLE (dst:Xmm, l:Int) -> Xmm :
    movsd(a, dst, MemPtr(stack-pointer(), l * SIZEOF-LONG + STACK-FRAME-SLOTS-OFFSET))
    dst
  defn LOCAL-DOUBLE (l:Int) -> Xmm :
    LOCAL-DOUBLE(xmm0(), l)

  defn PUSH-FRAME (num-locals:Int, ret-addr:Label) :
    add(a, stack-pointer(), SIZEOF-STACK-FRAME + num-locals * SIZEOF-LONG)
    lea(a, tmp1(), MemPtr(ret-addr, 0))
    set-return(a, tmp1())
    dump(a, "PUSH-FRAME %p RET %p\n" stack-pointer(), tmp1()) when debugging?

  defn POP-FRAME (num-locals:Int) :
    add(a, stack-pointer(), -1 * (SIZEOF-STACK-FRAME + num-locals * SIZEOF-LONG))

  defn c-call (fptr:Long) :
    push(a, r10())
    push(a, r11())
    mov(a, rax(), fptr)
    call(a, rax())
    pop(a, r11())
    pop(a, r10())
    
  defn do-tcall (f:Gp) :
    mov(a, tmp1(), MemPtr(functions(), f, 3, 0, SIZEOF-LONG))
    dump(a, "CALLING %d %p\n", f, tmp1()) when debugging?
    jmp(a, tmp1())

  defn do-call (f:Gp, num-locals:Int) :
    val end-label = new-label(a)
    PUSH-FRAME(num-locals, end-label)
    do-tcall(f)
    bind(a, end-label)

  defn trace-opcode (opcode:Int) :
    val name = string-join([ "%d: " opcode-names[opcode] "\n" ])
    if tracing? :
      val counter = rdi()
      get-instructions(a, counter)
      dump(a, name, counter) when tracing?
      add(a, counter, 1)
      set-instructions(a, counter)
    add(covered, opcode)

  defn emit-ins-a (opcode:Int, value:Label) :
    trace-opcode(opcode)
    switch(opcode) :
      GOTO-OPCODE : 
        plop("A GOTO")
        dump(a, "GOTO\n") when debugging?
        jmp(a, value as Label)

  defn emit-ins-a (opcode:Int, value:Int) :
    trace-opcode(opcode)
    switch(opcode) :
      FNENTRY-OPCODE :
        plop("A FNENTRY")
        ; dump-state(a, "FNENTRY:\n")
        val all-good-label = new-label(a)
        val extend-return-label = new-label(a)
        val frame-size = value * SIZEOF-LONG + SIZEOF-STACK-FRAME
        val size-required = frame-size + SIZEOF-STACK-FRAME
        ;Size-required must be in tmp3 to line up for extend-stack-launch
        add(a, CONST(tmp3(), size-required), stack-pointer())
        val limit = stack-limit(tmp2())
        dump(a, "STACK CHECK STK %p %p %p\n", stk(), tmp3(), limit) when debugging?
        cmp(a, tmp3(), limit)
        jle(a, all-good-label)
        CONST(tmp3(), size-required)
        lea(a, tmp2(), MemPtr(extend-return-label, 0))
        dump(a, "STACK-OVERFLOW %p RETURN-LABEL %p\n", tmp3(), tmp2()) ; when debugging?
        jmp(a, CONST(tmp1(), extend-stack-launch-value))
        bind(a, extend-return-label)
        dump(a, "STACK GOOD TOP %p LIMIT %p\n", heap-top(rax()), heap-limit(rax())) ; when debugging?
        bind(a, all-good-label)
      DISPATCH-OPCODE :
        plop("A DISPATCH")
        val tgts = new-label(a)
        val idx = read-dispatch-table(a, tmp1(), vmstate(), CONST(tmp1(), value))
        lea(a, tmp2(), MemPtr(tgts, 0))
        mov(a, tmp2(), MemPtr(tmp2(), idx, 3, 0))
        dump(a, "DISPATCH %lld %p\n", idx, tmp2()) when debugging?
        jmp(a, tmp2())
        bind(a, tgts)
      TCALL-CLOSURE-OPCODE :
        plop("A TCALL-CLOSURE")
        dump(a, "TCALL-CLOSURE\n") when debugging?
        LOCAL(tmp1(), value)
        mov(a, rcx(), MemPtr(tmp1(), FUNCTION-CODE-OFFSET + SIZEOF-LONG - REF-TAG-BITS))
        dump(a, "TCODE %p\n", rcx()) when debugging?
        do-tcall(rcx())
      POP-FRAME-OPCODE :
        plop("A POP-FRAME")
        val num-locals = value
        POP-FRAME(num-locals)
      ENTER-STACK-OPCODE :
        plop("A ENTER-STACK")
        dump(a, "ENTER STACK %d\n" CONST(tmp1(), value)) when debugging?
        ;Save current stack
        set-stack-pointer(a, stack-pointer())
        val saved-label = new-label(a)
        lea(a, tmp1(), MemPtr(saved-label, 0))
        set-pc(a, tmp1())
        dump(a, "SET STK-PC %p\n" tmp1()) when debugging?
        ;Load next stack
        set-current-stack(a, LOCAL(tmp1(), value))
        dump(a, "ENTER STACK %p\n" tmp1()) when debugging?
        untag-stack(a, stk(), tmp1())
        dump(a, "ENTER STK %p\n" stk()) when debugging?
        get-frames(a, stack-pointer())
        ;Load starting address
        get-pc(a, tmp1())
        dump(a, "ENTER STACK JUMP FID %p\n" tmp1()) when debugging?
        mov(a, tmp2(), MemPtr(functions(), tmp1(), 3, 0))
        dump(a, "ENTER STACK JUMP ADDR %p\n" tmp2()) when debugging?
        jmp(a, tmp2())
        bind(a, saved-label)
      YIELD-OPCODE :
        plop("A YIELD")
        dump(a, "YIELD\n") when debugging?
        val continue-label = new-label(a)
        ;Save current stack
        set-stack-pointer(a, stack-pointer())
        lea(a, tmp2(), MemPtr(continue-label, 0))
        set-pc(a, tmp2())
        ;Load next stack
        set-current-stack(a, LOCAL(tmp1(), value))
        untag-stack(a, stk(), tmp1())
        get-stack-pointer(a, stack-pointer())
        dump(a, "YIELD STK %p\n" stk()) when debugging?
        ;Load starting address
        get-pc(a, tmp1())
        dump(a, "SAVED PC %p\n", tmp1()) when debugging?
        jmp(a, tmp1())
        bind(a, continue-label)
      RETURN-OPCODE : 
        plop("A RETURN")
        get-return(a, tmp1())
        dump(a, "RETURNING TO %p\n", tmp1()) when debugging?
        jmp(a, tmp1())
      DUMP-OPCODE :
        plop("A DUMP XXX")
      LIVE-OPCODE :
        plop("A LIVE")
        mov(a, tmp2(), value)
        ; dump(a, "LIVE %p %p\n", stack-pointer(), tmp2())
        set-liveness-map(a, tmp2())
      DISPATCH-METHOD-OPCODE :
        plop("A DISPATCH-METHOD")
        val code-label = new-label(a)
        val tgts = new-label(a)
        read-dispatch-table(a, tmp3(), vmstate(), CONST(tmp1(), value))
        cmp(a, tmp3(), CONST(tmp1(), 2)) ; < 2 are targets and >= 2 are methods to goto
        jge(a, code-label)
        lea(a, tmp2(), MemPtr(tgts, 0))
        mov(a, tmp2(), MemPtr(tmp2(), tmp3(), 3, 0))
        dump(a, "DISPATCH LABELS %lld %p\n", tmp3(), tmp2()) when debugging?
        jmp(a, tmp2())
        bind(a, code-label)
        mov(a, tmp2(), MemPtr(functions(), tmp3(), 3, -2 * SIZEOF-LONG))
        dump(a, "DISPATCH METHOD %lld %p\n", tmp3(), tmp2()) when debugging?
        jmp(a, tmp2())
        bind(a, tgts)
      FLUSH-VM-OPCODE :
        plop("A FLUSH-VM")
        SAVE-STATE-ONLY(a)
        dump(a, "FLUSH-VM\n") when debugging?
        SET-LOCAL(value, vmstate())
      C-RSP-OPCODE :
        plop("A C-RSP")
        dump(a, "C-RSP\n") when debugging?
        SET-LOCAL(value, GET-CRSP(tmp1()))
      else :
        plop("MISSING A OPCODE %_" % [opcode])

  defn TAG (dst:Gp, x:Gp, tag:Int) -> Gp:
    ;MIGHT BE ABLE TO DO THIS WITH ADDRESSING MODE
    mov(a, dst, x)
    shl(a, dst, 32)
    add(a, dst, tag)
    dst
    
  defn DETAG (dst:Gp, x:Gp) -> Gp:
    mov(a, dst, x)
    shr(a, dst, 32)
    dst

  defn ptr-to-ref (dst:Gp, p:Gp) -> Gp :
    lea(a, dst, MemPtr(p, REF-TAG-BITS))
    dst

  defn emit-ins-b (opcode:Int, x:Int, value:Int) :
    trace-opcode(opcode)
    switch(opcode) :
      INT-NOT-OPCODE :
        plop("B INT-NOT")
        not-op(a, LOCAL(tmp1(), value))
        shr(a, tmp1(), 32)
        shl(a, tmp1(), 32)
        SET-LOCAL(x, tmp1())
      INT-NEG-OPCODE : 
        plop("B INT-NEG")
        neg(a, LOCAL(tmp1(), value))
        SET-LOCAL(x, tmp1())
      NOT-OPCODE-BYTE :
        plop("B NOT-BYTE")
        xor-op(a, tmp1(), tmp1())
        not-op(a, LOCAL(tmp1b(), value))
        SET-LOCAL-BYTE(x, tmp1())
      NOT-OPCODE-INT :
        plop("B NOT-INT")
        xor-op(a, tmp1(), tmp1()) ; TODO: REMOVE?
        not-op(a, LOCAL(tmp1i(), value))
        SET-LOCAL-INT(x, tmp1())
        dump(a, "NOT-INT %p %p\n", tmp1(), LOCAL(tmp2(), x)) when debugging?
      NOT-OPCODE-LONG :
        plop("B NOT-LONG")
        not-op(a, LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp2())
      NEG-OPCODE-INT :
        plop("B NEG-INT")
        neg(a, LOCAL(tmp1(), value))
        SET-LOCAL-INT(x, tmp1())
      NEG-OPCODE-LONG :
        plop("B NEG-LONG")
        neg(a, LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp2())
      NEG-OPCODE-FLOAT :
        plop("B NEG-FLOAT")
        xor-op(a, tmp1(), tmp1()) ; TOOD: REMOVE?
        cvtsi2ss(a, xmm0(), tmp1())
        subss(a, xmm0(), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      NEG-OPCODE-DOUBLE :
        plop("B NEG-DOUBLE")
        xor-op(a, tmp1(), tmp1()) ; TODO: REMOVE?
        cvtsi2sd(a, xmm0(), tmp1())
        subsd(a, xmm0(), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      CONV-OPCODE-BYTE-FLOAT :
        plop("B CONV-BYTE-FLOAT")
        cvtss2si(a, tmp1b(), LOCAL-FLOAT(xmm0(), value))
        SET-LOCAL-BYTE(x, tmp1())
      CONV-OPCODE-BYTE-DOUBLE :
        plop("B CONV-BYTE-DOUBLE")
        cvtsd2si(a, tmp1(), LOCAL-DOUBLE(xmm0(), value))
        SET-LOCAL-BYTE(x, tmp1())
      CONV-OPCODE-INT-BYTE :
        plop("B CONV-INT-BYTE")
        xor-op(a, tmp1(), tmp1()) ; TODO: REMOVE?
        mov(a, tmp1i(), LOCAL(tmp1b(), value))
        SET-LOCAL-INT(x, tmp1())
      CONV-OPCODE-INT-FLOAT :
        plop("B CONV-INT-FLOAT")
        cvtss2si(a, tmp1i(), LOCAL-FLOAT(xmm0(), value))
        SET-LOCAL-INT(x, tmp1())
      CONV-OPCODE-INT-DOUBLE :
        plop("B CONV-INT-DOUBLE")
        cvtsd2si(a, tmp1i(), LOCAL-DOUBLE(xmm0(), value))
        SET-LOCAL-INT(x, tmp1())
      CONV-OPCODE-LONG-BYTE :
        plop("B CONV-LONG-BYTE")
        SET-LOCAL-BYTE(x, tmp1())
        dump(a, "CONV-LONG-BYTE %p %p\n", tmp1(), LOCAL(tmp2(), x)) when debugging?
      CONV-OPCODE-LONG-INT :
        plop("B CONV-LONG-INT X %_ VALUE %_" % [x, value])
        movsxd(a, tmp2(), LOCAL(tmp1i(), value)) ; TODO: REMOVE?
        SET-LOCAL(x, tmp2())
        dump(a, "CONV-LONG-INT %p %p\n" tmp1(), tmp2()) when debugging?
      CONV-OPCODE-LONG-FLOAT :
        plop("B CONV-LONG-FLOAT")
        cvtss2si(a, tmp2(), LOCAL-FLOAT(xmm0(), value))
        SET-LOCAL(x, tmp2())
      CONV-OPCODE-LONG-DOUBLE :
        plop("B CONV-LONG-DOUBLE")
        cvtsd2si(a, tmp2(), LOCAL-DOUBLE(xmm0(), value))
        SET-LOCAL(x, tmp2())
      CONV-OPCODE-FLOAT-BYTE :
        plop("B CONV-FLOAT-BYTE")
        cvtsi2ss(a, xmm0(), LOCAL(tmp1b(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      CONV-OPCODE-FLOAT-INT :
        plop("B CONV-FLOAT-INT")
        cvtsi2ss(a, xmm0(), LOCAL(tmp1i(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      CONV-OPCODE-FLOAT-LONG :
        plop("B CONV-FLOAT-LONG")
        cvtsi2ss(a, xmm0(), LOCAL(tmp2(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      CONV-OPCODE-FLOAT-DOUBLE :
        plop("B CONV-FLOAT-DOUBLE")
        cvtsd2ss(a, xmm1(), LOCAL-DOUBLE(xmm0(), value))
        SET-LOCAL-FLOAT(x, xmm1())
      CONV-OPCODE-DOUBLE-BYTE :
        plop("B CONV-DOUBLE-BYTE")
        cvtsi2sd(a, xmm0(), LOCAL(tmp1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
        dump(a, "CONV-DOUBLE-BYTE %p %p\n" LOCAL(tmp1(), value), LOCAL(tmp2(), x)) when debugging?
      CONV-OPCODE-DOUBLE-INT :
        plop("B CONV-DOUBLE-INT")
        cvtsi2sd(a, xmm0(), LOCAL(tmp1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      CONV-OPCODE-DOUBLE-LONG :
        plop("B CONV-DOUBLE-LONG")
        cvtsi2sd(a, xmm0(), LOCAL(tmp2(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      CONV-OPCODE-DOUBLE-FLOAT :
        plop("B CONV-DOUBLE-FLOAT")
        dump(a, "CONV-DOUBLE-FLOAT %p\n", LOCAL(tmp1(), value)) when debugging?
        cvtss2sd(a, xmm1(), LOCAL-FLOAT(xmm0(), value))
        SET-LOCAL-DOUBLE(x, xmm1())
      TAG-OPCODE-BYTE :
        plop("B TAG-BYTE")
        dump(a, "TAG-BYTE\n") when debugging?
        TAG(tmp2(), LOCAL(tmp1(), value), BYTE-TAG-BITS)
        SET-LOCAL(x, tmp2())
      TAG-OPCODE-CHAR :
        plop("B TAG-CHAR")
        dump(a, "TAG-CHAR\n") when debugging?
        TAG(tmp2(), LOCAL(tmp1(), value), CHAR-TAG-BITS)
        SET-LOCAL(x, tmp2())
      TAG-OPCODE-INT :
        plop("B TAG-INT X %_ VALUE %_" % [x, value])
        TAG(tmp2(), LOCAL(tmp1(), value), INT-TAG-BITS)
        dump(a, "TAG-INT %p %p\n" tmp1() tmp2()) when debugging?
        SET-LOCAL(x, tmp2())
      TAG-OPCODE-FLOAT :
        plop("B TAG-FLOAT")
        dump(a, "TAG-FLOAT %p\n" LOCAL(tmp1(), value)) when debugging?
        TAG(tmp2(), LOCAL(tmp1(), value), FLOAT-TAG-BITS)
        SET-LOCAL(x, tmp2())
      DETAG-OPCODE :
        plop("B DETAG X %_ VALUE %_" % [x, value])
        DETAG(tmp2(), LOCAL(tmp1(), value))
        dump(a, "DETAG %p\n" tmp2()) when debugging?
        SET-LOCAL(x, tmp2())
      DEREF-OPCODE :
        plop("B DEREF")
        LOCAL(tmp2(), value)
        add(a, tmp2(), 8 - REF-TAG-BITS)
        SET-LOCAL(x, tmp2())
      GC-OPCODE :
        plop("B GC")
        dump(a, "START GC TOP %p LIMIT %p\n", heap-top(tmp1()), heap-limit(tmp2())) when debugging?
        LOCAL(tmp1(), value)
        SAVE-STATE(a)
        call-garbage-collector(a, vmstate(), tmp1())
        RESTORE-STATE(a)
        SET-LOCAL(x, rax())
        dump(a, "DONE GC TOP %p LIMIT %p\n", heap-top(tmp1()), heap-limit(tmp2())) when debugging?
      CLASS-NAME-OPCODE :
        plop("B CLASS-NAME")
        dump(a, "RETRIEVE CLASS-NAME %d\n", LOCAL(tmp1(), value))
        SET-LOCAL(x, retrieve-class-name(a, vmstate(), LOCAL(tmp1(), value)))
      PRINT-STACK-TRACE-OPCODE :
        plop("B PRINT-STACK-TRACE")
        SET-LOCAL(x, call-print-stack-trace(a, vmstate(), LOCAL(tmp1(), value)))
      COLLECT-STACK-TRACE-OPCODE :
        plop("B PRINT-STACK-TRACE")
        SET-LOCAL(x, call-collect-stack-trace(a, vmstate(), LOCAL(tmp1(), value)))
      GET-REG-OPCODE :
        plop("B GET-REG %_ %_" % [x value])
        SET-LOCAL(x, GET-REG(tmp1(), value))
      else :
        plop("MISSING B OPCODE %_" % [opcode])

  defn emit-ins-c (opcode:Int, x:Int, value:Int) :
    trace-opcode(opcode)
    switch(opcode) :
      TCALL-OPCODE-LOCAL :
        plop("C TCALL-LOCAL")
        dump(a, "TCALL-LOCAL: ") when debugging?
        do-tcall(LOCAL(tmp2(), value))
      TCALL-OPCODE-CODE :
        plop("C TCALL-CODE")
        dump(a, "TCALL-LOCAL: ") when debugging?
        do-tcall(CONST(tmp2(), value))
      CALL-OPCODE-LOCAL :
        plop("C CALL-LOCAL %_" % [value])
        dump(a, "CALL-LOCAL\n") when debugging?
        do-call(LOCAL(tmp2(), value), x)
      CALL-OPCODE-CODE :
        plop("C CALL-CODE %_" % [value])
        dump(a, "CALL-CODE\n") when debugging?
        do-call(CONST(tmp2(), value), x)
      CALL-CLOSURE-OPCODE :
        plop("C CALL-CLOSURE")
        mov(a, tmp2(), MemPtr(LOCAL(tmp1(), value), FUNCTION-CODE-OFFSET + SIZEOF-LONG - REF-TAG-BITS))
        dump(a, "CALL-CLOSURE %p %p\n", tmp1(), tmp2()) when debugging?
        do-call(tmp2(), x)
      CALLC-OPCODE-LOCAL :
        plop("C CALLC-LOCAL")
        val end-label = new-label(a)
        val num-locals = x
        PUSH-FRAME(num-locals, end-label)
        SAVE-STATE(a)
        val faddr = LOCAL(value)
        c-trampoline(a, faddr, registers(), registers())
        RESTORE-STATE(a)
        get-return(a, tmp1())
        jmp(a, tmp1())
        POP-FRAME(num-locals)
        bind(a, end-label)
      TYPEOF-OPCODE :
        plop("C TYPEOF")
        read-dispatch-table(a, tmp3(), vmstate(), CONST(tmp2(), value))
        SET-LOCAL(x, tmp3())
      SET-REG-OPCODE-LOCAL :
        plop("C SET-REG-LOCAL")
        SET-REG(x, LOCAL(value))
      SET-REG-OPCODE-UNSIGNED :
        plop("C SET-REG-UNSIGNED")
        mov(a, tmp1(), to-long(value) & 0xffffffffL)
        SET-REG(x, tmp1())
      SET-REG-OPCODE-WIDE :
        plop("C SET-REG-WIDE")
        SET-REG(x, CONST(tmp1(), value))
      SET-REG-OPCODE-CODE :
        plop("C SET-REG-CODE")
        SET-REG(x, CONST(tmp1(), value))
      SET-REG-OPCODE-GLOBAL :
        plop("C SET-REG-GLOBAL")
        mov(a, tmp2(), MemPtr(global-offsets(rax()), CONST(tmp1(), value), 3, 0))
        lea(a, tmp1(), MemPtr(global-mem(rax()), tmp2(), 0, 0))
        SET-REG(x, tmp1())
      SET-REG-OPCODE-DATA :
        plop("C SET-REG-DATA x=%_ value=%_" % [x, value])
        mov(a, tmp2i(), MemPtr(data-offsets(rax()), CONST(tmp1(), value), 2, 0, SIZEOF-INT))
        lea(a, tmp1(), MemPtr(data-mem(rax()), tmp2i(), 3, 0))
        SET-REG(x, tmp1())
        dump(a, "SET-REG-DATA %x %p\n" CONST(tmp2(), x) tmp1()) when debugging?
      SET-REG-OPCODE-CONST :
        plop("C SET-REG-CONST X %_ VALUE %_" % [x, value])
        dump(a, "SET-REG-CONST %d\n", CONST(tmp3(), value)) when debugging?
        mov(a, tmp1(), MemPtr(const-table(rax()), CONST(tmp3(), value), 3, 0))
        SET-REG(x, tmp1())
      SET-REG-OPCODE-UNSIGNED :
        plop("C SET-REG-UNSIGNED")
        SET-REG(x, CONST(tmp1(), value))
      SET-REG-OPCODE-SIGNED :
        plop("C SET-REG-UNSIGNED")
        SET-REG-INT(x, CONST(tmp1(), value))
      SET-OPCODE-LOCAL :
        plop("C SET-LOCAL X %_ VALUE %_" % [x, value])
        SET-LOCAL(x, LOCAL(value))
      SET-OPCODE-UNSIGNED :
        plop("C SET-UNSIGNED X %_ VALUE 0x%_" % [x, hex(to-long(value))])
        SET-LOCAL(x, CONST(tmp1(), value))
      SET-OPCODE-WIDE :
        plop("C SET-WIDE X %_ VALUE %_" % [x, value])
        SET-LOCAL(x, CONST(tmp1(), value))
      SET-OPCODE-CODE :
        plop("C SET-CODE")
        SET-LOCAL(x, CONST(tmp1(), value))
      SET-OPCODE-GLOBAL :
        plop("C SET-GLOBAL")
        mov(a, tmp2(), MemPtr(global-offsets(rax()), CONST(tmp1(), value), 3, 0))
        lea(a, tmp1(), MemPtr(global-mem(rax()), tmp2(), 0, 0))
        SET-LOCAL(x, tmp1())
      SET-OPCODE-DATA :
        plop("C SET-DATA")
        mov(a, tmp2i(), MemPtr(data-offsets(rax()), CONST(tmp1(), value), 2, 0, SIZEOF-INT))
        lea(a, tmp1(), MemPtr(data-mem(rax()), tmp2i(), 3, 0))
        SET-LOCAL(x, tmp1())
      SET-OPCODE-CONST :
        plop("C SET-CONST")
        mov(a, tmp2(), MemPtr(const-table(rax()), CONST(tmp1(), value), 3, 0))
        dump(a, "SET-CONST %d %p\n", CONST(tmp1(), value), tmp2()) when debugging?
        SET-LOCAL(x, tmp2())
      else :
        plop("MISSING C OPCODE %_" % [opcode])

  defn emit-ins-c (opcode:Int, x:Label, y:Int, value:Int) :
    trace-opcode(opcode)
    defn do-reserve (size:Gp, num-locals:Int) :
      add(a, heap-top(tmp2()), size)
      dump(a, "RESERVE SIZE %d TOP %p " size, heap-top(rcx())) when debugging?
      dump(a, "DESIRED %p LIMIT %p\n" tmp2(), heap-limit(rcx())) when debugging?
      cmp(a, tmp2(), heap-limit(rax()))
      jle(a, x)
      dump(a, "EXTENDING HEAP %d\n" size) when debugging?
      dump(a, "EXTENDING HEAP\n") when tracing?
      SET-REG(0, BOOLREF(CONST(tmp1(), 0)))
      SET-REG(1, CONST(tmp1(), 1L))
      SET-REG(2, size)
      mov(a, tmp2(), MemPtr(functions(), SIZEOF-LONG * EXTEND-HEAP-FN))
      val end-label = new-label(a)
      PUSH-FRAME(num-locals, end-label)
      jmp(a, tmp2())
      bind(a, end-label)
      dump(a, "RESERVED\n") when debugging?
    switch(opcode) :
      RESERVE-OPCODE-LOCAL :
        plop("C RESERVE-LOCAL Y %_ VALUE %_" % [y, value])
        val size = tmp3()
        add(a, LOCAL(size, value), 8 + 7)
        and-op(a, size, CONST(tmp2(), (- 8L)))
        do-reserve(size, y)
      RESERVE-OPCODE-CONST :
        plop("C RESERVE-CONST Y %_ VALUE %_" % [y, value])
        do-reserve(CONST(tmp3(), value), y)

  defn emit-ins-c (opcode:Int, x:Int, y:Int, value:Label) :
    trace-opcode(opcode)
    switch(opcode) :
      JUMP-REG-OPCODE :
        val reg = x
        val arity = y
        cmp(a, GET-REG(tmp1(), reg), CONST(tmp2(), arity))
        je(a, value as Label)
        plop("C JUMP-REG")

  defn cmp-set (a:Assembler, x:Gp, y:Gp, z:Gp, zb:Gp, set:(Assembler, Gp) -> False) -> Gp :
    xor-op(a, z, z)
    cmp(a, x, y)
    set(a, zb)
    z

  defn cmpf-set (a:Assembler, x:Xmm, y:Xmm, z:Gp, zb:Gp, set:(Assembler, Gp) -> False) -> Gp :
    xor-op(a, z, z)
    ucomiss(a, x, y)
    set(a, zb)
    z

  defn cmpd-set (a:Assembler, x:Xmm, y:Xmm, z:Gp, zb:Gp, set:(Assembler, Gp) -> False) -> Gp :
    xor-op(a, z, z)
    ucomisd(a, x, y)
    set(a, zb)
    z

  defn emit-ins-c (opcode:Int, x:Int, y:Int, value:Int) :
    trace-opcode(opcode)
    defn do-alloc (type:Int, num-bytes:Gp) :
      val top = tmp2()
      heap-top(top)
      dump(a, "--> ALLOC %p %d\n", top, num-bytes, rax()) when (debugging? or tracing?)
      mov(a, MemPtr(top, 0), CONST(tmp1(), value))
      dump(a, "TYPE = %p\n", tmp1()) when debugging?
      SET-LOCAL(x, ptr-to-ref(tmp1(), top))
      add(a, top, num-bytes)
      set-heap-top(a, top)
    switch(opcode) :
      INT-ADD-OPCODE :
        plop("C INT-ADD")
        add(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        dump(a, "INT-ADD %p\n" tmp1()) when debugging?
        SET-LOCAL(x, tmp1())
      INT-SUB-OPCODE :
        plop("C INT-SUB")
        sub(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        dump(a, "INT-SUB %p\n" tmp1()) when debugging?
        SET-LOCAL(x, tmp1())
      INT-MUL-OPCODE :
        plop("C INT-MUL")
        shr(a, LOCAL(tmp1(), y), 32)
        imul(a, tmp1(), LOCAL(tmp2(), value))
        dump(a, "INT-MUL %p\n" tmp1()) when debugging?
        SET-LOCAL(x, tmp1())
      INT-DIV-OPCODE :
        plop("C INT-DIV")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y), 
        div(a, LOCAL(tmp2(), value))
        shl(a, rax(), 32)
        dump(a, "INT-DIV %p\n" rax()) when debugging?
        SET-LOCAL(x, rax())
      INT-MOD-OPCODE :
        plop("C INT-MOD")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y), 
        div(a, LOCAL(tmp2(), value))
        dump(a, "INT-MOD %p\n" rdx()) when debugging?
        SET-LOCAL(x, rdx())
      INT-AND-OPCODE :
        plop("C INT-AND")
        and-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        dump(a, "INT-AND %p\n" tmp1()) when debugging?
        SET-LOCAL(x, tmp1())
      INT-OR-OPCODE :
        plop("C INT-OR")
        or-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        dump(a, "INT-OR %p\n" tmp1()) when debugging?
        SET-LOCAL(x, tmp1())
      INT-XOR-OPCODE :
        plop("C INT-XOR")
        xor-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        dump(a, "INT-XOR %p\n" tmp1()) when debugging?
        SET-LOCAL(x, tmp1())
      INT-SHL-OPCODE :
        plop("C INT-SHL X %_ Y %_ VALUE %_" % [x, y, value])
        shr(a, LOCAL(rcx(), value), 32) 
        shl(a, LOCAL(tmp1(), y), rcx())
        SET-LOCAL(x, tmp1())
        dump(a, "INT-SHL %p << %d\n" tmp1(), rcx()) when debugging?
      INT-SHR-OPCODE :
        plop("C INT-SHR")
        shr(a, LOCAL(rcx(), value), 32)
        shr(a, LOCAL(tmp1(), y), rcx())
        shr(a, tmp1(), 32)
        shl(a, tmp1(), 32)
        dump(a, "INT-SHR %p >> %d\n" tmp1(), tmp2()) when debugging?
        SET-LOCAL(x, tmp1())
      INT-ASHR-OPCODE :
        plop("C INT-ASHR")
        shr(a, LOCAL(rcx(), value), 32)
        ashr(a, LOCAL(tmp1(), y), rcx())
        shr(a, tmp1(), 32)
        shl(a, tmp1(), 32)
        SET-LOCAL(x, tmp1())
      INT-LT-OPCODE :
        plop("C INT-LT")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-l)
        dump(a, "LT? %d\n" res) when debugging?
        SET-LOCAL(x, BOOLREF(res))
      INT-GT-OPCODE :
        plop("C INT-GT X %_ Y %_ VALUE %_" % [x, y, value])
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-g)
        dump(a, "GT? %p %p: " tmp1() tmp2()) when debugging?
        dump(a, "%d\n" res) when debugging?
        SET-LOCAL(x, BOOLREF(res))
      INT-LE-OPCODE :
        plop("C INT-LE")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-le)
        dump(a, "LE? %d\n" res) when debugging?
        SET-LOCAL(x, BOOLREF(res))
      INT-GE-OPCODE :
        plop("C INT-GE")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ge)
        dump(a, "GE? %d\n" res) when debugging?
        SET-LOCAL(x, BOOLREF(res))
      REF-EQ-OPCODE :
        plop("C REF-EQ-OPCODE")
        dump(a, "EQ? %p %p\n" LOCAL(tmp1(), y), LOCAL(tmp2(), value)) when debugging?
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-e)
        dump(a, "> REF-EQ? %d\n" res) when debugging?
        SET-LOCAL(x, BOOLREF(res))
      EQ-OPCODE-REF :
        plop("C EQ-REF")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-BYTE :
        plop("C EQ-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-INT :
        plop("C EQ-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-LONG :
        plop("C EQ-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-FLOAT :
        plop("C EQ-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-DOUBLE :
        plop("C EQ-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      REF-NE-OPCODE :
        plop("C REF-NE")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
        dump(a, "REF-EQ? %d\n" res) when debugging?
        SET-LOCAL(x, BOOLREF(res))
      NE-OPCODE-REF :
        plop("C NE-REF")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
        SET-LOCAL(x, res)
      NE-OPCODE-BYTE :
        plop("C NE-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-ne)
        dump(a, "NE-BYTE %p\n", res) when debugging?
        SET-LOCAL(x, res)
      NE-OPCODE-INT :
        plop("C NE-INT")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
        SET-LOCAL(x, res)
        dump(a, "NE-INT(%p %p) -> %p\n", LOCAL(tmp1(), y), LOCAL(tmp2(), value), res) when debugging?
      NE-OPCODE-LONG :
        plop("C NE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
        dump(a, "NE-LONG -> %p\n", res) when debugging?
        SET-LOCAL(x, res)
      NE-OPCODE-FLOAT :
        plop("C NE-FLOAT")
        dump(a, "NE-FLOAT %p %p\n", LOCAL(tmp1(), y), LOCAL(tmp2(), value)) when debugging?
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-ne)
        SET-LOCAL(x, res)
        dump(a, "NE-FLOAT %p\n", res) when debugging?
      NE-OPCODE-DOUBLE :
        plop("C NE-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-ne)
        SET-LOCAL(x, res)
      ADD-OPCODE-BYTE :
        plop("C ADD-BYTE")
        add(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        dump(a, "ADD-BYTE %p\n" tmp1b()) when debugging?
        SET-LOCAL-BYTE(x, tmp1())
      ADD-OPCODE-INT :
        plop("C ADD-INT")
        add(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        dump(a, "ADD-INT %p\n" tmp1i()) when debugging?
        SET-LOCAL-INT(x, tmp1())
      ADD-OPCODE-LONG :
        plop("C ADD-LONG X %_ Y %_ VALUE %_" % [x, y, value])
        add(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      ADD-OPCODE-FLOAT :
        plop("C ADD-FLOAT")
        addss(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
        mov(a, tmp1(), xmm0())
        mov(a, tmp2(), xmm1())
      ADD-OPCODE-DOUBLE :
        plop("C ADD-DOUBLE")
        addsd(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      SUB-OPCODE-BYTE :
        plop("C SUB-BYTE")
        sub(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        SET-LOCAL-BYTE(x, tmp1())
      SUB-OPCODE-INT :
        plop("C SUB-INT")
        sub(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        dump(a, "SUB-INT %p\n" tmp1i()) when debugging?
        SET-LOCAL-INT(x, tmp1())
      SUB-OPCODE-LONG :
        plop("C SUB-LONG")
        sub(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      SUB-OPCODE-FLOAT :
        plop("C SUB-FLOAT")
        subss(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      SUB-OPCODE-DOUBLE :
        plop("C SUB-DOUBLE")
        subsd(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      MUL-OPCODE-BYTE :
        plop("C MUL-BYTE")
        imul(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        SET-LOCAL-BYTE(x, tmp1())
        dump(a, "MUL-BYTE %p %p\n" tmp2(), tmp1()) when debugging?
      MUL-OPCODE-INT :
        plop("C MUL-INT")
        imul(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        dump(a, "MUL-INT %p\n" tmp1i()) when debugging?
        SET-LOCAL-INT(x, tmp1())
      MUL-OPCODE-LONG :
        plop("C MUL-LONG X %_ Y %_ VALUE %_" % [x, y, value])
        imul(a, LOCAL(tmp3(), y), LOCAL(tmp2(), value))
        dump(a, "MUL-LONG %p\n" tmp3()) when debugging?
        SET-LOCAL(x, tmp3())
      MUL-OPCODE-FLOAT :
        plop("C MUL-FLOAT")
        mulss(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      MUL-OPCODE-DOUBLE :
        plop("C MUL-DOUBLE")
        mulsd(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      DIV-OPCODE-BYTE :
        plop("C DIV-BYTE")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y), 
        div(a, LOCAL(tmp2(), value))
        SET-LOCAL-BYTE(x, rax())
      DIV-OPCODE-INT :
        plop("C DIV-INT")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y), 
        div(a, LOCAL(tmp2(), value))
        dump(a, "DIV-INT %p\n" rax()) when debugging?
        SET-LOCAL-INT(x, rax())
      DIV-OPCODE-LONG :
        plop("C DIV-LONG")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y)
        div(a, LOCAL(tmp2(), value))
        SET-LOCAL(x, rax())
      DIV-OPCODE-FLOAT :
        plop("C DIV-FLOAT")
        divss(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      DIV-OPCODE-DOUBLE :
        plop("C DIV-DOUBLE")
        divsd(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      MOD-OPCODE-BYTE :
        plop("C MOD-BYTE")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y)
        div(a, LOCAL(tmp2(), value))
        dump(a, "MOD-BYTE %p %p\n" rdx(), rax()) when debugging?
        SET-LOCAL-BYTE(x, rdx())
      MOD-OPCODE-INT :
        plop("C MOD-INT")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y)
        div(a, LOCAL(tmp2(), value))
        dump(a, "MOD-INT %p\n" edx()) when debugging?
        SET-LOCAL-INT(x, rdx())
      MOD-OPCODE-LONG :
        plop("C MOD-LONG")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y)
        div(a, LOCAL(tmp2(), value))
        SET-LOCAL(x, rdx())
      AND-OPCODE-BYTE :
        plop("C AND-BYTE")
        and-op(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        SET-LOCAL-BYTE(x, tmp1())
      AND-OPCODE-INT :
        plop("C AND-INT")
        and-op(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        dump(a, "AND-INT %p\n" tmp1i()) when debugging?
        SET-LOCAL-INT(x, tmp1())
      AND-OPCODE-LONG :
        plop("C AND-LONG")
        and-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      OR-OPCODE-BYTE :
        plop("C OR-BYTE")
        or-op(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        SET-LOCAL-BYTE(x, tmp1())
      OR-OPCODE-INT :
        plop("C OR-INT")
        or-op(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        dump(a, "OR-INT %p\n" tmp1i()) when debugging?
        SET-LOCAL-INT(x, tmp1())
      OR-OPCODE-LONG :
        plop("C OR-LONG")
        or-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      XOR-OPCODE-BYTE :
        plop("C XOR-BYTE")
        xor-op(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        dump(a, "XOR-INT %p\n" tmp1i()) when debugging?
        SET-LOCAL-BYTE(x, tmp1())
      XOR-OPCODE-INT :
        plop("C XOR-INT")
        xor-op(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        SET-LOCAL-INT(x, tmp1())
      XOR-OPCODE-LONG :
        plop("C XOR-LONG")
        xor-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      SHL-OPCODE-BYTE :
        plop("C SHL-BYTE")
        shl(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        SET-LOCAL-BYTE(x, tmp1())
      SHL-OPCODE-INT :
        plop("C SHL-INT")
        shl(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        dump(a, "SHL-INT %p\n" tmp1()) when debugging?
        SET-LOCAL-INT(x, tmp1())
      SHL-OPCODE-LONG :
        plop("C SHL-LONG")
        shl(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        SET-LOCAL(x, tmp1())
      SHR-OPCODE-BYTE :
        plop("C SHR-BYTE")
        shr(a, LOCAL(tmp1b(), y), LOCAL(rcx(), value))
        SET-LOCAL-BYTE(x, tmp1())
      SHR-OPCODE-INT :
        plop("C SHR-INT")
        shr(a, LOCAL(tmp1i(), y), LOCAL(rcx(), value))
        dump(a, "SHR-INT %p\n" tmp1i()) when debugging?
        SET-LOCAL-INT(x, tmp1())
      SHR-OPCODE-LONG :
        plop("C SHR-LONG")
        shr(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        SET-LOCAL(x, tmp1())
      ASHR-OPCODE-INT :
        plop("C ASHR-INT")
        ashr(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        dump(a, "ASHR-INT %p\n" tmp1i()) when debugging?
        SET-LOCAL-INT(x, tmp1())
      ASHR-OPCODE-LONG :
        plop("C ASHR-LONG")
        ashr(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        SET-LOCAL(x, tmp1())
      LT-OPCODE-INT :
        plop("C LT-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-l)
        dump(a, "LT-INT %p\n" res) when debugging?
        SET-LOCAL(x, res)
      LT-OPCODE-LONG :
        plop("C LT-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-l)
        SET-LOCAL(x, res)
      LT-OPCODE-FLOAT :
        plop("C LT-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-b)
        dump(a, "LT-FLOAT %d\n", res) when debugging?
        SET-LOCAL(x, res)
      LT-OPCODE-DOUBLE :
        plop("C LT-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-b)
        dump(a, "LT-DOUBLE %d\n", res) when debugging?
        SET-LOCAL(x, res)
      GT-OPCODE-INT :
        plop("C GT-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-g)
        dump(a, "GT-INT %p\n" res) when debugging?
        SET-LOCAL(x, res)
      GT-OPCODE-LONG :
        plop("C GT-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-g)
        SET-LOCAL(x, res)
      GT-OPCODE-FLOAT :
        plop("C GT-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-a)
        dump(a, "GT-FLOAT %d\n" res) when debugging?
        SET-LOCAL(x, res)
      GT-OPCODE-DOUBLE :
        plop("C GT-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-a)
        dump(a, "GT-DOUBLE %d\n", res) when debugging?
        SET-LOCAL(x, res)
      LE-OPCODE-INT :
        plop("C LE-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-le)
        dump(a, "LE-INT %p\n" res) when debugging?
        SET-LOCAL(x, res)
      LE-OPCODE-LONG :
        plop("C LE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-le)
        SET-LOCAL(x, res)
      LE-OPCODE-FLOAT :
        plop("C LE-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-be)
        dump(a, "LE-FLOAT %d\n" res) when debugging?
        SET-LOCAL(x, res)
      LE-OPCODE-DOUBLE :
        plop("C LE-DOUBLE")
        val res = cmpd-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-be)
        dump(a, "LE-DOUBLE %d\n", res) when debugging?
        SET-LOCAL(x, res)
      GE-OPCODE-INT :
        plop("C GE-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-ge)
        dump(a, "GE-INT %p\n" res) when debugging?
        SET-LOCAL(x, res)
      GE-OPCODE-LONG :
        plop("C GE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ge)
        SET-LOCAL(x, res)
      GE-OPCODE-FLOAT :
        plop("C GE-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-ae)
        dump(a, "GE-FLOAT %d\n" res) when debugging?
        SET-LOCAL(x, res)
      GE-OPCODE-DOUBLE :
        plop("C GE-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-ae)
        dump(a, "GE-DOUBLE %d\n", res) when debugging?
        SET-LOCAL(x, res)
      ULT-OPCODE-BYTE :
        plop("C ULT-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-b)
        SET-LOCAL(x, res)
      ULT-OPCODE-INT :
        plop("C ULT-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-b)
        SET-LOCAL(x, res)
      ULT-OPCODE-LONG :
        plop("C ULT-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-b)
        SET-LOCAL(x, res)
      ULE-OPCODE-BYTE :
        plop("C ULE-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-be)
        SET-LOCAL(x, res)
      ULE-OPCODE-INT :
        plop("C ULE-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-be)
        SET-LOCAL(x, res)
      ULE-OPCODE-LONG :
        plop("C ULE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-be)
        SET-LOCAL(x, res)
      UGT-OPCODE-BYTE :
        plop("C UGT-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-a)
        SET-LOCAL(x, res)
      UGT-OPCODE-INT :
        plop("C UGT-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-a)
        SET-LOCAL(x, res)
      UGT-OPCODE-LONG :
        plop("C UGT-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-a)
        SET-LOCAL(x, res)
      UGE-OPCODE-BYTE :
        plop("C UGE-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-ae)
        SET-LOCAL(x, res)
      UGE-OPCODE-INT :
        plop("C UGE-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-ae)
        SET-LOCAL(x, res)
      UGE-OPCODE-LONG :
        plop("C UGE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ae)
        SET-LOCAL(x, res)
      ALLOC-OPCODE-LOCAL :
        plop("C ALLOC-LOCAL X %_ Y %_ VALUE %_" % [x, y, value])
        dump(a, "ALLOC-LOCAL\n") when debugging?
        val num-bytes = tmp3()
        LOCAL(num-bytes, y)
        add(a, num-bytes, 8 + 7)
        and-op(a, num-bytes, CONST(rdi(), (- 8L)))
        do-alloc(value, num-bytes)
      ALLOC-OPCODE-CONST :
        plop("C ALLOC-CONST X %_ Y %_ VALUE %_" % [x, y, value])
        dump(a, "ALLOC-CONST\n") when debugging?
        do-alloc(value, CONST(tmp3(), 8 + y))
      else :
        plop("MISSING C OPCODE %_" % [opcode])

  defn emit-ins-d (opcode:Int, x:Int, value:Long) :
    trace-opcode(opcode)
    switch(opcode) :
      CALLC-OPCODE-WIDE : 
        plop("D CALLC-WIDE")
        val end-label = new-label(a)
        val faddr = value
        val num_locals = x
        PUSH-FRAME(num_locals, end-label)
        SAVE-STATE(a)
        mov(a, tmp1(), faddr)
        dump(a, "CALLC-WIDE %p\n" tmp1()) when debugging?
        c-trampoline(a, tmp1(), registers(), registers())
        RESTORE-STATE(a)
        POP-FRAME(num_locals)
        bind(a, end-label)
      SET-OPCODE-WIDE :
        plop("D SET-WIDE X %_ VALUE %_" % [x, value])
        SET-LOCAL(x, CONST(tmp1(), value))
      SET-REG-OPCODE-WIDE :
        plop("D SET-REG-WIDE")
        SET-REG(x, CONST(tmp1(), value))
      else :
        plop("MISSING D OPCODE %_" % [opcode])

  defn emit-ins-e (opcode:Int, x:Int, y:Int, z:Int, value:Int) :
    trace-opcode(opcode)
    switch(opcode) :
      STORE-OPCODE-1 :
        plop("E STORE-1 X %_ VALUE %_ Z %_" % [x, value, z])
        mov(a, MemPtr(LOCAL(tmp1(), x), CONST(tmp2(), value), 0, 0, SIZEOF-BYTE), LOCAL(al(), z))
        dump(a, "  STORE-1 %p[%d] = %p\n" tmp1() tmp2(), rax()) when (debugging? or tracing?)
      STORE-OPCODE-4 :
        plop("E STORE-4 X %_ VALUE %_ Z %_" % [x, value, z])
        mov(a, MemPtr(LOCAL(tmp1(), x), CONST(tmp2(), value), 0, 0, SIZEOF-INT), LOCAL(eax(), z))
        dump(a, "  STORE-4 %p[%d] = %p\n" tmp1() tmp2(), rax()) when (debugging? or tracing?)
      STORE-OPCODE-8 :
        plop("E STORE-8 X %_ VALUE %_ Z %_" % [x, value, z])
        mov(a, MemPtr(LOCAL(tmp1(), x), CONST(tmp2(), value), 0, 0, SIZEOF-LONG), LOCAL(rax(), z))
        dump(a, "  STORE-8 %p[%d] = %p\n" tmp1() tmp2(), rax()) when (debugging? or tracing?)
      STORE-OPCODE-1-VAR-OFFSET :
        plop("E STORE-1-VAR-OFFSET")
        mov(a, MemPtr(LOCAL(tmp1(), x), LOCAL(tmp2(), y), 0, value, SIZEOF-BYTE), LOCAL(al(), z))
        dump(a, "  STORE-1* %p[%d] = %p\n", tmp1(), tmp2(), rax()) when (debugging? or tracing?)
      STORE-OPCODE-4-VAR-OFFSET :
        plop("E STORE-4-VAR-OFFSET")
        mov(a, MemPtr(LOCAL(tmp1(), x), LOCAL(tmp2(), y), 0, value, SIZEOF-INT), LOCAL(eax(), z))
        dump(a, "  STORE-4* %p[%d] = %p\n", tmp1(), tmp2(), rax()) when (debugging? or tracing?)
      STORE-OPCODE-8-VAR-OFFSET :
        plop("E STORE-8-VAR-OFFSET")
        mov(a, MemPtr(LOCAL(tmp1(), x), LOCAL(tmp2(), y), 0, value, SIZEOF-LONG), LOCAL(tmp3(), z))
        dump(a, "  STORE-8* %p[%d] = %p\n", tmp1(), tmp2(), tmp3()) when (debugging? or tracing?)
      LOAD-OPCODE-1 : 
        plop("D LOAD-1 X %_ Y %_ VALUE %_" % [x, y, value])
        mov(a, tmp3(), MemPtr(LOCAL(tmp1(), y), CONST(tmp2(), value), 0, 0, SIZEOF-BYTE))
        dump(a, "LOAD-1 %p[%] -> %p\n", LOCAL(tmp1(), y), CONST(tmp2(), value), tmp3()) when debugging?
        SET-LOCAL-BYTE(x, tmp3())
      LOAD-OPCODE-4 : 
        plop("D LOAD-4 X %_ Y %_ VALUE %_" % [x, y, value])
        mov(a, tmp3(), MemPtr(LOCAL(tmp1(), y), CONST(tmp2(), value), 0, 0, SIZEOF-INT))
        dump(a, "LOAD-4 %p[%d] -> %p\n", tmp1(), tmp2(), tmp3()) when debugging?
        SET-LOCAL-INT(x, tmp3())
      LOAD-OPCODE-8 :
        plop("D LOAD-8 X %_ Y %_ VALUE %_" % [x, y, value])
        mov(a, tmp3(), MemPtr(LOCAL(tmp1(), y), CONST(tmp2(), value), 0, 0, SIZEOF-LONG))
        dump(a, "LOAD-8 %p[%d] -> %p\n", tmp1(), tmp2(), tmp3()) when debugging?
        SET-LOCAL(x, tmp3())
      LOAD-OPCODE-1-VAR-OFFSET :
        plop("E LOAD-1-VAR-OFFSET")
        xor-op(a, tmp3(), tmp3())
        mov(a, tmp3(), MemPtr(LOCAL(tmp2(), y), LOCAL(tmp1(), z), 0, value, SIZEOF-BYTE))
        dump(a, "LOAD-1* %p[%d] -> %p\n", tmp2(), tmp1(), tmp3()) when debugging?
        SET-LOCAL-BYTE(x, tmp3())
      LOAD-OPCODE-4-VAR-OFFSET :
        plop("E LOAD-4-VAR-OFFSET X %_ Y %_ Z %_ VALUE %_" % [x, y, z, value])
        xor-op(a, tmp3(), tmp3())
        mov(a, tmp3(), MemPtr(LOCAL(tmp2(), y), LOCAL(tmp1(), z), 0, value, SIZEOF-INT))
        dump(a, "LOAD-4* %p[%d] -> %p\n", tmp2(), tmp1(), tmp3()) when debugging?
        SET-LOCAL-INT(x, tmp3())
      LOAD-OPCODE-8-VAR-OFFSET :
        plop("E LOAD-8-VAR-OFFSET")
        mov(a, tmp3(), MemPtr(LOCAL(tmp2(), y), LOCAL(tmp1(), z), 0, value, SIZEOF-LONG))
        dump(a, "LOAD-8* %p[%d] -> %p\n", tmp2(), tmp1(), tmp3()) when debugging?
        SET-LOCAL(x, tmp3())
      else :
        plop("MISSING E OPCODE %_" % [opcode])

  defn jump-op-reg (x:Gp, y:Gp, f:(Assembler, Label) -> False, cmp:(Assembler, Gp, Gp) -> False, n1:Label, n2:Label) :
    cmp(a, x, y)
    f(a,  n1)
    jmp(a, n2)
    
  defn jump-op (x:Int, y:Int, f:(Assembler, Label) -> False, cmp:(Assembler, Gp, Gp) -> False, n1:Label, n2:Label) :
    jump-op-reg(LOCAL(tmp1(), x), LOCAL(tmp2(), y), f, cmp, n1, n2)
    
  defn jump-op-xmm (x:Xmm, y:Xmm, f:(Assembler, Label) -> False, cmp:(Assembler, Xmm, Xmm) -> False, n1:Label, n2:Label) :
    cmp(a, x, y)
    f(a,  n1)
    jmp(a, n2)
    
  defn jump-float-op (x:Int, y:Int, f:(Assembler, Label) -> False, n1:Label, n2:Label) :
    jump-op-xmm(LOCAL-FLOAT(xmm0(), x), LOCAL-FLOAT(xmm1(), y), f, ucomiss, n1, n2)
    
  defn jump-double-op (x:Int, y:Int, f:(Assembler, Label) -> False, n1:Label, n2:Label) :
    jump-op-xmm(LOCAL-DOUBLE(xmm0(), x), LOCAL-DOUBLE(xmm1(), y), f, ucomisd, n1, n2)
    
  defn emit-ins-f (opcode:Int, x:Int, y:Int, n1:Label, n2:Label) :
    trace-opcode(opcode)
    switch(opcode) :
      JUMP-TAGBITS-OPCODE :
        plop("F JUMP-TAGBITS")
        and-op(a, LOCAL(tmp1(), x), CONST(tmp2(), 0x7))
        cmp(a, tmp1(), CONST(tmp2(), y))
        je(a, n1)
        jmp(a, n2)
      JUMP-TAGWORD-OPCODE :
        plop("F JUMP-TAGWORD")
        LOCAL(tmp1(), x) ; OBJ
        and-op(a, LOCAL(tmp2(), x), CONST(tmp3(), 7)) ; TAGBITS
        LOCAL(tmp3(), y) ; TAG
        cmp(a, tmp2(), CONST(rax(), 1)) ; tagbits == 1
        jne(a, n2)
        mov(a, tmp1(), MemPtr(tmp1(), -1, SIZEOF-INT)) ; *p = *((int*)(obj - 1))
        jump-op-reg(tmp1(), tmp3(), je, cmp, n1, n2)    ; *p == tag
      JUMP-SET-OPCODE :
        plop("F JUMP-SET")
        dump(a, "JUMP-SET[%lld] %p\n" CONST(tmp2(), x), LOCAL(tmp1(), x)) when debugging?
        jump-op-reg(LOCAL(tmp1(), x), CONST(tmp2(), 0), jne, cmp, n1, n2)
      JUMP-INT-LT-OPCODE :
        plop("F JUMP-LT-REF")
        dump(a, "JUMP-LT-REF %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jl, cmp, n1, n2)
      JUMP-INT-GT-OPCODE :
        plop("F JUMP-GT-REF")
        dump(a, "JUMP-GT-REF %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jg, cmp, n1, n2)
      JUMP-INT-LE-OPCODE :
        plop("F JUMP-LE-REF")
        dump(a, "JUMP-LE-REF %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jle, cmp, n1, n2)
      JUMP-INT-GE-OPCODE :
        plop("F JUMP-GE-REF")
        dump(a, "JUMP-GE-REF %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jge, cmp, n1, n2)
      JUMP-EQ-OPCODE-REF :
        plop("F JUMP-EQ-REF")
        dump(a, "JUMP-EQ-REF %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, je, cmp, n1, n2)
      JUMP-EQ-OPCODE-BYTE :
        plop("F JUMP-EQ-BYTE")
        dump(a, "JUMP-EQ-BYTE %p %p\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), je, cmp, n1, n2)
      JUMP-EQ-OPCODE-INT :
        plop("F JUMP-EQ-INT")
        dump(a, "JUMP-EQ-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), je, cmp, n1, n2)
      JUMP-EQ-OPCODE-LONG :
        plop("F JUMP-EQ-LONG")
        dump(a, "JUMP-EQ-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, je, cmp, n1, n2)
      JUMP-EQ-OPCODE-FLOAT :
        plop("F JUMP-EQ-FLOAT")
        jump-float-op(x, y, je, n1, n2)
      JUMP-EQ-OPCODE-DOUBLE :
        plop("F JUMP-EQ-DOUBLE")
        jump-double-op(x, y, je, n1, n2)
      JUMP-NE-OPCODE-REF :
        plop("F JUMP-NE-REF")
        dump(a, "JUMP-NE-REF %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jne, cmp, n1, n2)
      JUMP-NE-OPCODE-BYTE :
        plop("F JUMP-NE-BYTE")
        dump(a, "JUMP-NE-BYTE %p %p\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), jne, cmp, n1, n2)
      JUMP-NE-OPCODE-INT :
        plop("F JUMP-NE-INT")
        dump(a, "JUMP-NE-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jne, cmp, n1, n2)
      JUMP-NE-OPCODE-LONG :
        plop("F JUMP-NE-LONG")
        dump(a, "JUMP-NE-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jne, cmp, n1, n2)
      JUMP-NE-OPCODE-FLOAT :
        plop("F JUMP-NE-FLOAT")
        jump-float-op(x, y, jne, n1, n2)
      JUMP-NE-OPCODE-DOUBLE :
        plop("F JUMP-NE-DOUBLE")
        jump-double-op(x, y, jne, n1, n2)
      JUMP-LT-OPCODE-INT :
        plop("F JUMP-LT-INT")
        dump(a, "JUMP-LT-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jl, cmp, n1, n2)
      JUMP-LT-OPCODE-LONG :
        plop("F JUMP-LT-LONG")
        dump(a, "JUMP-LT-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jl, cmp, n1, n2)
      JUMP-LT-OPCODE-FLOAT :
        plop("F JUMP-LT-FLOAT")
        jump-float-op(x, y, jb, n1, n2)
      JUMP-LT-OPCODE-DOUBLE :
        plop("F JUMP-LT-DOUBLE")
        jump-double-op(x, y, jb, n1, n2)
      JUMP-GT-OPCODE-INT :
        plop("F JUMP-GT-INT")
        dump(a, "JUMP-GT-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jg, cmp, n1, n2)
      JUMP-GT-OPCODE-LONG :
        plop("F JUMP-GT-LONG")
        dump(a, "JUMP-GT-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jg, cmp, n1, n2)
      JUMP-GT-OPCODE-FLOAT :
        plop("F JUMP-GT-FLOAT")
        jump-float-op(x, y, ja, n1, n2)
      JUMP-GT-OPCODE-DOUBLE :
        plop("F JUMP-GT-DOUBLE")
        jump-double-op(x, y, ja, n1, n2)
      JUMP-LE-OPCODE-INT :
        plop("F JUMP-LE-INT")
        dump(a, "JUMP-LE-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jle, cmp, n1, n2)
      JUMP-LE-OPCODE-LONG :
        plop("F JUMP-LE-LONG")
        dump(a, "JUMP-LE-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jle, cmp, n1, n2)
      JUMP-LE-OPCODE-FLOAT :
        plop("F JUMP-LE-FLOAT")
        jump-float-op(x, y, jbe, n1, n2)
      JUMP-LE-OPCODE-DOUBLE :
        plop("F JUMP-LE-DOUBLE")
        jump-double-op(x, y, jbe, n1, n2)
      JUMP-GE-OPCODE-INT :
        plop("F JUMP-GE-INT")
        dump(a, "JUMP-GE-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jge, cmp, n1, n2)
      JUMP-GE-OPCODE-LONG :
        plop("F JUMP-GE-LONG")
        dump(a, "JUMP-GE-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jge, cmp, n1, n2)
      JUMP-GE-OPCODE-FLOAT :
        plop("F JUMP-GE-FLOAT")
        jump-float-op(x, y, jae, n1, n2)
      JUMP-GE-OPCODE-DOUBLE :
        plop("F JUMP-GE-DOUBLE")
        jump-double-op(x, y, jae, n1, n2)
      JUMP-ULT-OPCODE-BYTE :
        plop("F JUMP-ULT-BYTE")
        dump(a, "JUMP-ULT-INT %p %p\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), jb, cmp, n1, n2)
      JUMP-ULT-OPCODE-INT :
        plop("F JUMP-ULT-INT")
        dump(a, "JUMP-ULT-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jb, cmp, n1, n2)
      JUMP-ULT-OPCODE-LONG :
        plop("F JUMP-ULT-LONG")
        dump(a, "JUMP-ULT-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jb, cmp, n1, n2)
      JUMP-ULE-OPCODE-BYTE :
        plop("F JUMP-ULE-BYTE")
        dump(a, "JUMP-ULE-BYTE %p %p\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), jbe, cmp, n1, n2)
      JUMP-ULE-OPCODE-INT :
        plop("F JUMP-ULE-INT")
        dump(a, "JUMP-ULE-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jbe, cmp, n1, n2)
      JUMP-ULE-OPCODE-LONG :
        plop("F JUMP-ULE-LONG")
        dump(a, "JUMP-ULE-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jbe, cmp, n1, n2)
      JUMP-UGT-OPCODE-BYTE :
        plop("F JUMP-UGT-BYTE")
        dump(a, "JUMP-UGT-INT %p %p\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), ja, cmp, n1, n2)
      JUMP-UGT-OPCODE-INT :
        plop("F JUMP-UGT-INT")
        dump(a, "JUMP-UGT-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), ja, cmp, n1, n2)
      JUMP-UGT-OPCODE-LONG :
        plop("F JUMP-UGT-LONG")
        dump(a, "JUMP-UGT-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, ja, cmp, n1, n2)
      JUMP-UGE-OPCODE-BYTE :
        plop("F JUMP-UGE-BYTE")
        dump(a, "JUMP-UGE-INT %p %p\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), jae, cmp, n1, n2)
      JUMP-UGE-OPCODE-INT :
        plop("F JUMP-UGE-INT")
        dump(a, "JUMP-UGE-INT %p %p\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y)) when debugging?
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jae, cmp, n1, n2)
      JUMP-UGE-OPCODE-LONG :
        plop("F JUMP-UGE-LONG")
        dump(a, "JUMP-UGE-LONG %p %p\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y)) when debugging?
        jump-op(x, y, jae, cmp, n1, n2)
      else : 
        plop("MISSING F OPCODE %_" % [opcode])

  defn emit-ins-targets (dests:Tuple<Label>) :
    for (d in dests, i in 0 to false) do :
      plop("TARGET %_" % [i])
      embed(a, d)

  ;Encode multivarity functions
  defn encode (multi:VMMultifn) :
    ;Declare function labels
    val labels = for entry in funcs(multi) map : new-label(a)
    ;Emit branch instructions
    for (entry in funcs(multi), flabel in labels) do :
      val arity = key(entry)
      emit-ins-c(JUMP-REG-OPCODE, arg(multi), arity, flabel)
    ;Emit default branch
    encode(default(multi))
    ;Emit other branches, and compute their positions
    for (entry in funcs(multi), flabel in labels) do :
      bind(a, flabel)
      encode(value(entry))

  defn encode (func:VMFunc) :
    ;==================================================
    ;============== Fundamental State =================
    ;==================================================
    ; extra 3 locals for temporary moving
    val max-local = maximum(-1, seq(local, defs(func)))
    val num-locals = max-local + 1 + 3

    ;Definitions
    val deftable = to-inttable(id, defs(func))

    ;Labels
    val label-table = IntTable<Label>()
    val used-labels = to-intset(seq(n, filter-by<LabelIns>(ins(func))))
    val label-counter = to-seq(0 to false)

    ;==================================================
    ;============== Overall Algorithm =================
    ;==================================================
    defn driver () :
      emit-prelude()
      do(emit-ins, ins(func))

    ;Enter a function
    defn emit-prelude () :
      ;Enter function
      emit-ins-a(FNENTRY-OPCODE, num-locals)
      ;Retrieve arguments
      get-regs(args(func))

    ;Encode a match statement that can be redefined later.
    defn emit-non-final-match (ys:Tuple<VMImm>, bs:Tuple<VMBranch>, default:Int) :
      ;Retrieve the format index of this match statement.
      val [types, dests] = split-types-and-dests(bs)
      val format = match-format(resolver, types)

      ;Push arguments onto registers
      set-regs(ys)

      ;One target for default and then each branch for dispatch.
      val num-targets = 1 + length(bs)
      val targets = jump-offsets([default], dests)
      emit-ins-a(DISPATCH-OPCODE, format)
      emit-ins-targets(targets)

    ;Encode a match statement that cannot be redefined later.
    defn emit-final-match (ys:Tuple<VMImm>, bs:Tuple<VMBranch>, default-label:Int) :
      defn compute-dag () :
        val branch-table = BranchTable(to-branches(seq(types,bs), {[_]}))
        compute-dispatch-dag(branch-table, false)

      defn emit-dag (dag:Dag) :
        ;Create labels for all entries
        val labels = map(gen-label{}, entries(dag))
        ;Convert a value into a label
        defn to-label (x:Int|Soln) :
          match(x) :
            (x:Int) : labels[x]
            (x:UniqueSoln) : n(bs[index(x)])
            (x:NoSoln) : default-label
        ;Compile a given entry
        defn emit-entry (e:DagEntry) :
          if empty?(entries(e)) :
            emit-ins(GotoIns(to-label(default(e))))
          else :
            within (entry, last?) = expanded-entries(e) :
              val n1 = to-label(value(entry))
              val n2 = to-label(default(e)) when last? else gen-label()
              emit-ins(Branch1Ins(n1, n2, InstanceofOp(SingleType(key(entry))), ys[depth(e)]))
              emit-ins(LabelIns(n2)) when not last?
        ;Compile all entries
        for (e in entries(dag), l in labels) do :
          emit-ins(LabelIns(l))
          emit-entry(e)

      ;Expand the given entries and compute whether it is the last entry
      defn expanded-entries (f:(KeyValue<Int,Int|Soln>, True|False) -> ?, e:DagEntry) :
        val es = for e in entries(e) seq-cat :
          for v in values(key(e)) seq :
            v => value(e)
        let loop () :
          val e = next(es)
          f(e, empty?(es))
          loop() when not empty?(es)

      ;Launch
      emit-dag(compute-dag())

    ;Emit instanceof operation
    defn emit-instanceof (n1:Int, n2:Int, x:VMImm, type:TypeSet) :
      if (type is SingleType) and type-is-final?(type) :
        defn driver () :
          val tag = /type(type as SingleType)
          switch(tag) :
            BYTE-TYPE : compare-tag-bits(BYTE-TYPE)
            CHAR-TYPE : compare-tag-bits(CHAR-TYPE)
            INT-TYPE : compare-tag-bits(INT-TYPE)
            FLOAT-TYPE :  compare-tag-bits(FLOAT-TYPE)
            else :
              if marker?(resolver, tag) : compare-marker(tag)
              else : compare-tag-word(tag)
        defn compare-tag-bits (typeid:Int) :
          val bits = tagbits(resolver,typeid)
          emit-ins-f(JUMP-TAGBITS-OPCODE, to-local(x,0), bits, jump-offset(n1), jump-offset(n2))
        defn compare-marker (typeid:Int) :
          emit-ins(Branch2Ins(n1, n2, EqOp(), x, Marker(typeid)))
        defn compare-tag-word (typeid:Int) :
          val typetag-local = to-local(NumConst(typeid), 0)
          val x-local = to-local(x,1)
          emit-ins-f(JUMP-TAGWORD-OPCODE, x-local, typetag-local, jump-offset(n1), jump-offset(n2))
        driver()
      else :
        ;Retrieve format
        val format = match-format(resolver, [[type]])
        ;Push argument into register
        set-reg(0, x)
        ;Emit dispatch instruction
        ;Two targets, match success and default
        val num-targets = 2
        val targets = jump-offsets([n2, n1])
        emit-ins-a(DISPATCH-OPCODE, format)
        emit-ins-targets(targets)

    defn maybe-add-new-label (n:Int) -> Label :
      if not key?(label-table, n) :
        label-table[n] = new-label(a)
      label-table[n]
      
    defn before-call-dump (entry:False|StackTraceEntry) :
      match(entry:StackTraceEntry) :
        dump(a, ">>> %s\n", CONST(tmp1(), printf-format(to-string(entry)))) when (debugging? or tracing?)

    ;Encode each instruction
    defn emit-ins (ins:VMIns) :
      match(ins) :
        (ins:LabelIns) :
          val lab = maybe-add-new-label(n(ins))
          plop("LABEL %_" % [n(ins)])
          bind(a, lab)
        (ins:UnreachableIns) :
          false
        (ins:TCallIns) :
          set-regs(ys(ins))
          emit-ins-c(tcall-opcode(f(ins)), 0, to-function-local(f(ins)))
        (ins:TCallClosureIns) :
          set-regs(ys(ins))
          emit-ins-a(TCALL-CLOSURE-OPCODE, to-local(f(ins), 0))
        (ins:CallIns) :
          set-regs(ys(ins))
          before-call-dump(trace-entry(ins))
          emit-ins-c(call-opcode(f(ins)), num-locals, to-function-local(f(ins)))
          record-trace-entry(trace-entry(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallClosureIns) :
          set-regs(ys(ins))
          before-call-dump(trace-entry(ins))
          emit-ins-c(CALL-CLOSURE-OPCODE, num-locals, to-local(f(ins), 0))
          record-trace-entry(trace-entry(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallCIns) :
          ;Convert a VMType into an ArgType for call-record analysis
          defn to-arg-type (t:VMType) :
            match(t) :
              (t:VMFloat|VMDouble) : RealArg()
              (t) : IntArg()
          ;Compute C calling convention
          val records = callc-records(ytypes, xtype, backend) where :
            val ytypes = map(to-arg-type, map(imm-type, ys(ins)))
            val xtypes = map(to-arg-type, map(imm-type, xs(ins)))
            val xtype = IntArg() when empty?(xtypes) else xtypes[0]
          ;Compute register locations
          var layout-counter:Int = 0
          defn next-index (n:Int) :
            val c = layout-counter
            layout-counter = layout-counter + n
            c
          val num-stack-args-index = next-index(1)
          val stack-args-index = next-index(num-mem-args(records))
          val num-float-args-index = next-index(1)
          val float-args-index = next-index(num-real-args(records))
          val num-int-args-index = next-index(1)
          val int-args-index = next-index(num-int-args(records))
          val num-floats-in-call-index = next-index(1)
          ;Given the location that the argument should be stored,
          ;return the index in the register buffer that we should
          ;store the argument that is desired by the trampoline code.
          defn register-index (l:CallLoc) -> Int :
            match(l) :
              (l:RegLoc) : num-floats-in-call-index - 1 - index(l)
              (l:FRegLoc) : num-int-args-index - 1 - index(l)
              (l:MemLoc) : num-float-args-index - 1 - index(l)
          ;Assign registers
          for arg in args(records) do :
            val r = register-index(loc(arg))
            val v = value(arg) as StdArg|ShadowArg
            val y = ys(ins)[index(v)]
            set-reg(r, y)
          ;Set number of arguments
          set-reg(num-stack-args-index, NumConst(num-mem-args(records)))
          set-reg(num-float-args-index, NumConst(num-real-args(records)))
          set-reg(num-int-args-index, NumConst(num-int-args(records) + 1))
          set-reg(num-floats-in-call-index, NumConst(num-real-args(records)))
          ;Call function
          before-call-dump(trace-entry(ins))
          match(f(ins)) :
            (f:Local) :
              emit-ins-c(CALLC-OPCODE-LOCAL, num-locals, slot(f))
            (f:ExternId) :
              val address = to-bits(f) as Long
              emit-ins-d(CALLC-OPCODE-WIDE, num-locals, address)
          record-trace-entry(trace-entry(ins))
          ;Retrieve return registers
          defn return-register-index (l:CallLoc) :
            match(l) :
              (l:RegLoc) : 0
              (l:FRegLoc) : 1
          if not empty?(xs(ins)) :
            val x = xs(ins)[0]
            dump(a, "GET-REG RET\n") when debugging?
            get-reg(x, return-register-index(return(records)))
        (ins:YieldIns) :
          set-regs(ys(ins))
          val opcode = ENTER-STACK-OPCODE when enter?(ins) else YIELD-OPCODE
          emit-ins-a(opcode, to-local(f(ins), 0))
          record-trace-entry(trace-entry(ins))
          get-regs(xs(ins))
        (ins:ReturnIns) :
          set-regs(xs(ins))
          plop("RET SET-REGS %_" % [xs(ins)])
          emit-ins-a(RETURN-OPCODE, 0)
        (ins:DumpIns) :
          for x in xs(ins) do :
            emit-ins-a(DUMP-OPCODE, slot(x))
        (ins:RecordLiveIns) :
          val live-map = liveness-map(resolver, map(slot, live(ins)), num-locals)
          emit-ins-a(LIVE-OPCODE, live-map)
        (ins:StoreIns) :
          val code = store-opcode(y(ins), imm-type(z(ins)))
          val offset* = match(imm-type(x(ins))) :
            (xt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
            (xt) : offset(ins)
          val x* = to-local(x(ins),0)
          val z* = to-local(z(ins),1)
          val y* = match(y(ins)) :
            (y:VMImm) : to-local(y,2)
            (y:False) : 0
          emit-ins-e(code, x*, y*, z*, offset*)
        (ins:LoadIns) :
          val code = load-opcode(z(ins), imm-type(x(ins)))
          val offset* = match(imm-type(y(ins))) :
            (yt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
            (yt) : offset(ins)
          val y* = to-local(y(ins),0)
          val z* = match(z(ins)) :
            (z:VMImm) : to-local(z,1)
            (z:False) : 0
          emit-ins-e(code, slot(x(ins)), y*, z*, offset*)
        (ins:Op0Ins) :
          val code = op0-opcode(op(ins))
          emit-ins-a(code, slot(x(ins)))
        (ins:Op1Ins) :
          match(op(ins)) :
            (op:InstanceofOp) :
              ;Push argument into register
              set-reg(0, y(ins))
              val format = match-format(resolver, [[type(op)]])
              ;Emit typeof instruction
              emit-ins-c(TYPEOF-OPCODE, slot(x(ins)), format)
            (op) :
              val opcode = op1-opcode(op, imm-type(x(ins)), imm-type(y(ins)))
              match(opcode:Int) :
                val x* = slot(x(ins))
                val y* = to-local(y(ins), 0)
                emit-ins-b(opcode, x*, y*)
              else :
                set-local(slot(x(ins)), y(ins))
        (ins:Op2Ins) :
          val opcode = op2-opcode(op(ins), imm-type(x(ins)), imm-type(y(ins)))
          val x* = slot(x(ins))
          val y* = to-local(y(ins), 0)
          val z* = to-local(z(ins), 1)
          emit-ins-c(opcode, x*, y*, z*)
        (ins:GotoIns) :
          emit-ins-a(GOTO-OPCODE, jump-offset(n(ins)))
        (ins:Branch1Ins) :
          match(op(ins)) :
            (op:InstanceofOp) :
              emit-instanceof(n1(ins), n2(ins), x(ins), type(op))
            (op:False) :
              emit-ins-f(JUMP-SET-OPCODE, to-local(x(ins), 0), 0, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:Branch2Ins) :
          val code = branch2-opcode(op(ins), imm-type(x(ins)))
          val x* = to-local(x(ins), 0)
          val y* = to-local(y(ins), 1)
          emit-ins-f(code, x*, y*, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:AllocIns) :
          val continue-label = new-label(a)
          if all?({_ is NumConst}, sizes(ins)) :
            val num-obj = length(sizes(ins))
            val obj-sizes = for s in sizes(ins) map :
              object-size-on-heap(resolver, value(s as NumConst) as Int)
            ;Big sizes don't fit in instruction encoding
            val sum-of-sizes = object-size(num-obj, sum(obj-sizes))
            if sum-of-sizes >= 1024 :
              val size-local = to-local(NumConst(sum-of-sizes),0)
              emit-ins-c(RESERVE-OPCODE-LOCAL, continue-label, num-locals, size-local)
            else :
              emit-ins-c(RESERVE-OPCODE-CONST, continue-label, num-locals, sum-of-sizes)
            record-trace-entry(trace-entry(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            bind(a, continue-label)
            for (x in xs(ins), t in types(ins), sz in obj-sizes) do :
              ;Big object doesn't fit in instruction encoding
              if sz >= 1024 :
                val size-local = to-local(NumConst(sz),0)
                emit-ins-c(ALLOC-OPCODE-LOCAL, slot(x), size-local, t)
              else :
                emit-ins-c(ALLOC-OPCODE-CONST, slot(x), sz, t)
          else:
            fatal("Multiple variable-sized allocations.") when length(sizes(ins)) > 1
            val x = xs(ins)[0]
            val type = types(ins)[0]
            val size = to-local(sizes(ins)[0], 0)
            emit-ins-c(RESERVE-OPCODE-LOCAL, continue-label, num-locals, size)
            record-trace-entry(trace-entry(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            bind(a, continue-label)
            emit-ins-c(ALLOC-OPCODE-LOCAL, slot(x), size, type)
        (ins:DispatchIns) :
          ;Push arguments onto registers
          set-regs(ys(ins))
          val [types, dests] = split-types-and-dests(branches(ins))
          val format = dispatch-format(resolver, types)
          ;Two targets for default and amb and then each branch for dispatch.
          val num-targets = 2 + length(branches(ins))
          val targets = jump-offsets([default(ins), amb(ins)], dests)
          emit-ins-a(DISPATCH-OPCODE, format)
          emit-ins-targets(targets)
        (ins:MatchIns) :
          if all?(branch-is-final?, branches(ins)) :
            emit-final-match(ys(ins), branches(ins), default(ins))
          else :
            emit-non-final-match(ys(ins), branches(ins), default(ins))
        (ins:MethodDispatchIns) :
          ;Push arguments onto registers
          set-regs(cat(ys(ins), zs(ins)))
          ;Retrieve format
          val format = method-format(resolver, multi(ins), length(ys(ins)), length(zs(ins)))
          ;Only two targets for default and amb
          val num-targets = 2
          val targets = jump-offsets([default(ins), amb(ins)])
          emit-ins-a(DISPATCH-METHOD-OPCODE, format)
          emit-ins-targets(targets)
        (ins:SetIns) :
          set-local(slot(x(ins)), y(ins))

    ;==================================================
    ;============= Immediate Utilities ================
    ;==================================================
    ;Retrieve type of immediate
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:VMType) :
      x

    ;Use deftable to retrieve the slot of a local
    defn slot (x:Local) :
      local(deftable[index(x)])

    ;==================================================
    ;============= Label Utilities ====================
    ;==================================================
    ;Create mapping from label ID to position
    defn jump-offset (n:Int) -> Label :
      maybe-add-new-label(n)
    defn jump-offsets (xs:Seqable<Int>) -> Tuple<Label> :
      to-tuple(seq(jump-offset, xs))
    defn jump-offsets (xs:Seqable<Int>, ys:Seqable<Int>) -> Tuple<Label> :
      jump-offsets(cat(xs,ys))

    ;Generate new unique label
    defn* gen-label () :
      val l = next(label-counter)
      gen-label() when used-labels[l] else l

    ;==================================================
    ;============= Compilation Utilities ==============
    ;==================================================
    ;Retrieve the corresponding bits for the given immediate
    defn to-bits (y:VMImm) -> Int|Long :
      match(y) :
        (y:Local) : slot(y)
        (y:NumConst) :
          match(value(y)) :
            (v:Char) : to-int(v)
            (v:Byte) : to-int(v)
            (v:Int) : v
            (v:Long) : v
            (v:Float) : bits(v)
            (v:Double) : bits(v)
        (y:Marker) : marker(resolver, typeid(y))
        (y:Tag) : typeid(y)
        (y:VoidMarker) : void-marker(resolver)
        (y:CodeId) : id(y)
        (y:ExternId) : extern-address(id(y))
        (y:GlobalId) : id(y)
        (y:DataId) : id(y)
        (y:ConstId) : (plop("CONST ID %_" % [id(y)]), id(y))

    ;Set register
    defn set-reg (i:Int, y:VMImm) :
      match(to-bits(y)) :
        (v:Int) : emit-ins-c(set-reg-opcode(y), i, v)
        (v:Long) : emit-ins-d(set-reg-opcode(y), i, v)
    defn set-regs (ys:Seqable<VMImm>) :
      do(set-reg, 0 to false, ys)
    defn get-reg (x:Local|VMType, i:Int) :
      match(x:Local) :
        emit-ins-b(GET-REG-OPCODE, slot(x), i)
    defn get-regs (xs:Seqable<Local|VMType>) :
      do(get-reg, xs, 0 to false)

    ;Set local
    defn set-local (x:Int, y:VMImm) :
      match(to-bits(y)) :
        (v:Int) : emit-ins-c(set-opcode(y), x, v)
        (v:Long) : emit-ins-d(set-opcode(y), x, v)

    ;Put immediate in temporary local if not a local
    defn to-local (x:VMImm, num:Int) :
      match(x:Local) :
        slot(x)
      else :
        val index = max-local + num + 1
        set-local(index, x)
        index

    ;Number of words needed to hold immediate in local
    defn words-for-to-local (x:VMImm) :
      match(x:Local) :
        0
      else :
        match(to-bits(x)) :
          (v:Int) : 2
          (v:Long) : 3

    ;Put immediate in register if not a function immediate
    defn to-function-local (f:VMImm) :
      match(f) :
        (f:CodeId) : id(f)
        (f) : to-local(f, 0)

    ;==================================================
    ;===================== Launch =====================
    ;==================================================
    driver()
  
  encode(func as VMMultifn|VMFunc)
  val f = add(rt, code)
  plop("FUNC %_" % [hex(value(f))])
  EncodedFunction(f, trace-entry-table)

;============================================================
;======================= Opcodes ============================
;============================================================

val SET-OPCODE-LOCAL = 0
val SET-OPCODE-UNSIGNED = 1
val SET-OPCODE-SIGNED = 2
val SET-OPCODE-CODE = 3
val SET-OPCODE-GLOBAL = 5
val SET-OPCODE-DATA = 6
val SET-OPCODE-CONST = 7
val SET-OPCODE-WIDE = 8
val SET-REG-OPCODE-LOCAL = 9
val SET-REG-OPCODE-UNSIGNED = 10
val SET-REG-OPCODE-SIGNED = 11
val SET-REG-OPCODE-CODE = 12
val SET-REG-OPCODE-GLOBAL = 14
val SET-REG-OPCODE-DATA = 15
val SET-REG-OPCODE-CONST = 16
val SET-REG-OPCODE-WIDE = 17
val GET-REG-OPCODE = 18
val CALL-OPCODE-LOCAL = 19
val CALL-OPCODE-CODE = 20
val CALL-CLOSURE-OPCODE = 22
val TCALL-OPCODE-LOCAL = 23
val TCALL-OPCODE-CODE = 24
val TCALL-CLOSURE-OPCODE = 26
val CALLC-OPCODE-LOCAL = 27
val CALLC-OPCODE-WIDE = 28
val POP-FRAME-OPCODE = 30
val LIVE-OPCODE = 31
val YIELD-OPCODE = 32
val RETURN-OPCODE = 33
val DUMP-OPCODE = 34
;2-arity operations
val INT-ADD-OPCODE = 35
val INT-SUB-OPCODE = 36
val INT-MUL-OPCODE = 37
val INT-DIV-OPCODE = 38
val INT-MOD-OPCODE = 39
val INT-AND-OPCODE = 40
val INT-OR-OPCODE = 41
val INT-XOR-OPCODE = 42
val INT-SHL-OPCODE = 43
val INT-SHR-OPCODE = 44
val INT-ASHR-OPCODE = 45
val INT-LT-OPCODE = 46
val INT-GT-OPCODE = 47
val INT-LE-OPCODE = 48
val INT-GE-OPCODE = 49
val REF-EQ-OPCODE = 50
val EQ-OPCODE-REF = 51
val EQ-OPCODE-BYTE = 52
val EQ-OPCODE-INT = 53
val EQ-OPCODE-LONG = 54
val EQ-OPCODE-FLOAT = 55
val EQ-OPCODE-DOUBLE = 56
val REF-NE-OPCODE = 57
val NE-OPCODE-REF = 58
val NE-OPCODE-BYTE = 59
val NE-OPCODE-INT = 60
val NE-OPCODE-LONG = 61
val NE-OPCODE-FLOAT = 62
val NE-OPCODE-DOUBLE = 63
val ADD-OPCODE-BYTE = 64
val ADD-OPCODE-INT = 65
val ADD-OPCODE-LONG = 66
val ADD-OPCODE-FLOAT = 67
val ADD-OPCODE-DOUBLE = 68
val SUB-OPCODE-BYTE = 69
val SUB-OPCODE-INT = 70
val SUB-OPCODE-LONG = 71
val SUB-OPCODE-FLOAT = 72
val SUB-OPCODE-DOUBLE = 73
val MUL-OPCODE-BYTE = 74
val MUL-OPCODE-INT = 75
val MUL-OPCODE-LONG = 76
val MUL-OPCODE-FLOAT = 77
val MUL-OPCODE-DOUBLE = 78
val DIV-OPCODE-BYTE = 79
val DIV-OPCODE-INT = 80
val DIV-OPCODE-LONG = 81
val DIV-OPCODE-FLOAT = 82
val DIV-OPCODE-DOUBLE = 83
val MOD-OPCODE-BYTE = 84
val MOD-OPCODE-INT = 85
val MOD-OPCODE-LONG = 86
val AND-OPCODE-BYTE = 87
val AND-OPCODE-INT = 88
val AND-OPCODE-LONG = 89
val OR-OPCODE-BYTE = 90
val OR-OPCODE-INT = 91
val OR-OPCODE-LONG = 92
val XOR-OPCODE-BYTE = 93
val XOR-OPCODE-INT = 94
val XOR-OPCODE-LONG = 95
val SHL-OPCODE-BYTE = 96
val SHL-OPCODE-INT = 97
val SHL-OPCODE-LONG = 98
val SHR-OPCODE-BYTE = 99
val SHR-OPCODE-INT = 100
val SHR-OPCODE-LONG = 101
val ASHR-OPCODE-INT = 103
val ASHR-OPCODE-LONG = 104
val LT-OPCODE-INT = 105
val LT-OPCODE-LONG = 106
val LT-OPCODE-FLOAT = 107
val LT-OPCODE-DOUBLE = 108
val GT-OPCODE-INT = 109
val GT-OPCODE-LONG = 110
val GT-OPCODE-FLOAT = 111
val GT-OPCODE-DOUBLE = 112
val LE-OPCODE-INT = 113
val LE-OPCODE-LONG = 114
val LE-OPCODE-FLOAT = 115
val LE-OPCODE-DOUBLE = 116
val GE-OPCODE-INT = 117
val GE-OPCODE-LONG = 118
val GE-OPCODE-FLOAT = 119
val GE-OPCODE-DOUBLE = 120
val ULE-OPCODE-BYTE = 121
val ULE-OPCODE-INT = 122
val ULE-OPCODE-LONG = 123
val ULT-OPCODE-BYTE = 124
val ULT-OPCODE-INT = 125
val ULT-OPCODE-LONG = 126
val UGT-OPCODE-BYTE = 127
val UGT-OPCODE-INT = 128
val UGT-OPCODE-LONG = 129
val UGE-OPCODE-BYTE = 130
val UGE-OPCODE-INT = 131
val UGE-OPCODE-LONG = 132
;1-arity operations
val INT-NOT-OPCODE = 133
val INT-NEG-OPCODE = 134
val NOT-OPCODE-BYTE = 135
val NOT-OPCODE-INT = 136
val NOT-OPCODE-LONG = 137
val NEG-OPCODE-INT = 138
val NEG-OPCODE-LONG = 139
val NEG-OPCODE-FLOAT = 140
val NEG-OPCODE-DOUBLE = 141
val DEREF-OPCODE = 142
val TYPEOF-OPCODE = 143
;branch operation
val JUMP-SET-OPCODE = 144
val JUMP-TAGBITS-OPCODE = 240
val JUMP-TAGWORD-OPCODE = 242
val GOTO-OPCODE = 145
;conversion operations
val CONV-OPCODE-BYTE-FLOAT = 146
val CONV-OPCODE-BYTE-DOUBLE = 147
val CONV-OPCODE-INT-BYTE = 148
val CONV-OPCODE-INT-FLOAT = 149
val CONV-OPCODE-INT-DOUBLE = 150
val CONV-OPCODE-LONG-BYTE = 151
val CONV-OPCODE-LONG-INT = 152
val CONV-OPCODE-LONG-FLOAT = 153
val CONV-OPCODE-LONG-DOUBLE = 154
val CONV-OPCODE-FLOAT-BYTE = 155
val CONV-OPCODE-FLOAT-INT = 156
val CONV-OPCODE-FLOAT-LONG = 157
val CONV-OPCODE-FLOAT-DOUBLE = 158
val CONV-OPCODE-DOUBLE-BYTE = 159
val CONV-OPCODE-DOUBLE-INT = 160
val CONV-OPCODE-DOUBLE-LONG = 161
val CONV-OPCODE-DOUBLE-FLOAT = 162
;tagging operations
val DETAG-OPCODE = 163
val TAG-OPCODE-BYTE = 164
val TAG-OPCODE-CHAR = 165
val TAG-OPCODE-INT = 166
val TAG-OPCODE-FLOAT = 167
;storing operations
val STORE-OPCODE-1 = 168
val STORE-OPCODE-4 = 169
val STORE-OPCODE-8 = 170
val STORE-OPCODE-1-VAR-OFFSET = 171
val STORE-OPCODE-4-VAR-OFFSET = 172
val STORE-OPCODE-8-VAR-OFFSET = 173
;loading operations
val LOAD-OPCODE-1 = 174
val LOAD-OPCODE-4 = 175
val LOAD-OPCODE-8 = 176
val LOAD-OPCODE-1-VAR-OFFSET = 177
val LOAD-OPCODE-4-VAR-OFFSET = 178
val LOAD-OPCODE-8-VAR-OFFSET = 179
;Allocation
val RESERVE-OPCODE-LOCAL = 180
val RESERVE-OPCODE-CONST = 181
val ENTER-STACK-OPCODE = 182
val ALLOC-OPCODE-CONST = 183
val ALLOC-OPCODE-LOCAL = 184
;system operations
val GC-OPCODE = 185
val CLASS-NAME-OPCODE = 241
val C-RSP-OPCODE = 243
val PRINT-STACK-TRACE-OPCODE = 186
val COLLECT-STACK-TRACE-OPCODE = 187
val FLUSH-VM-OPCODE = 188
;2-arity branch operations
val JUMP-INT-LT-OPCODE = 192
val JUMP-INT-GT-OPCODE = 193
val JUMP-INT-LE-OPCODE = 194
val JUMP-INT-GE-OPCODE = 195
val JUMP-EQ-OPCODE-REF = 196
val JUMP-EQ-OPCODE-BYTE = 197
val JUMP-EQ-OPCODE-INT = 198
val JUMP-EQ-OPCODE-LONG = 199
val JUMP-EQ-OPCODE-FLOAT = 200
val JUMP-EQ-OPCODE-DOUBLE = 201
val JUMP-NE-OPCODE-REF = 202
val JUMP-NE-OPCODE-BYTE = 203
val JUMP-NE-OPCODE-INT = 204
val JUMP-NE-OPCODE-LONG = 205
val JUMP-NE-OPCODE-FLOAT = 206
val JUMP-NE-OPCODE-DOUBLE = 207
val JUMP-LT-OPCODE-INT = 208
val JUMP-LT-OPCODE-LONG = 209
val JUMP-LT-OPCODE-FLOAT = 210
val JUMP-LT-OPCODE-DOUBLE = 211
val JUMP-GT-OPCODE-INT = 212
val JUMP-GT-OPCODE-LONG = 213
val JUMP-GT-OPCODE-FLOAT = 214
val JUMP-GT-OPCODE-DOUBLE = 215
val JUMP-LE-OPCODE-INT = 216
val JUMP-LE-OPCODE-LONG = 217
val JUMP-LE-OPCODE-FLOAT = 218
val JUMP-LE-OPCODE-DOUBLE = 219
val JUMP-GE-OPCODE-INT = 220
val JUMP-GE-OPCODE-LONG = 221
val JUMP-GE-OPCODE-FLOAT = 222
val JUMP-GE-OPCODE-DOUBLE = 223
val JUMP-ULE-OPCODE-BYTE = 224
val JUMP-ULE-OPCODE-INT = 225
val JUMP-ULE-OPCODE-LONG = 226
val JUMP-ULT-OPCODE-BYTE = 227
val JUMP-ULT-OPCODE-INT = 228
val JUMP-ULT-OPCODE-LONG = 229
val JUMP-UGT-OPCODE-BYTE = 230
val JUMP-UGT-OPCODE-INT = 231
val JUMP-UGT-OPCODE-LONG = 232
val JUMP-UGE-OPCODE-BYTE = 233
val JUMP-UGE-OPCODE-INT = 234
val JUMP-UGE-OPCODE-LONG = 235
;dispatch operation
val DISPATCH-OPCODE = 236
val DISPATCH-METHOD-OPCODE = 237
;jump on register
val JUMP-REG-OPCODE = 238
;function entry
val FNENTRY-OPCODE = 239

defn set-reg-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-REG-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-REG-OPCODE-UNSIGNED
        (v:Byte) : SET-REG-OPCODE-UNSIGNED
        (v:Int) : SET-REG-OPCODE-UNSIGNED
        (v:Long) : SET-REG-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-REG-OPCODE-UNSIGNED
        (v:Double) : SET-REG-OPCODE-WIDE
    (y:Marker) : SET-REG-OPCODE-UNSIGNED
    (y:Tag) : SET-REG-OPCODE-UNSIGNED
    (y:CodeId) : SET-REG-OPCODE-CODE
    (y:ExternId) : SET-REG-OPCODE-WIDE
    (y:GlobalId) : SET-REG-OPCODE-GLOBAL
    (y:DataId) : SET-REG-OPCODE-DATA
    (y:ConstId) : SET-REG-OPCODE-CONST
    (y:VoidMarker) : SET-REG-OPCODE-UNSIGNED

defn set-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-OPCODE-UNSIGNED
        (v:Byte) : SET-OPCODE-UNSIGNED
        (v:Int) : SET-OPCODE-UNSIGNED
        (v:Long) : SET-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-OPCODE-UNSIGNED
        (v:Double) : SET-OPCODE-WIDE
    (y:Marker) : SET-OPCODE-UNSIGNED
    (y:Tag) : SET-OPCODE-UNSIGNED
    (y:CodeId) : SET-OPCODE-CODE
    (y:ExternId) : SET-OPCODE-WIDE
    (y:GlobalId) : SET-OPCODE-GLOBAL
    (y:DataId) : SET-OPCODE-DATA
    (y:ConstId) : SET-OPCODE-CONST
    (y:VoidMarker) : SET-OPCODE-UNSIGNED

defn call-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALL-OPCODE-LOCAL
    (f:CodeId) : CALL-OPCODE-CODE

defn callc-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALLC-OPCODE-LOCAL
    (f:ExternId) :  CALLC-OPCODE-WIDE

defn tcall-opcode (f:VMImm) :
  match(f) :
    (f:Local) : TCALL-OPCODE-LOCAL
    (f:CodeId) : TCALL-OPCODE-CODE

defn store-opcode (offset:VMImm|False, val-type:VMType) :
  match(offset, val-type) :
    (o:False, vt:VMByte) : STORE-OPCODE-1
    (o:False, vt:VMInt) : STORE-OPCODE-4
    (o:False, vt:VMLong) : STORE-OPCODE-8
    (o:False, vt:VMFloat) : STORE-OPCODE-4
    (o:False, vt:VMDouble) : STORE-OPCODE-8
    (o:False, vt:VMRef) : STORE-OPCODE-8
    (o:VMImm, vt:VMByte) : STORE-OPCODE-1-VAR-OFFSET
    (o:VMImm, vt:VMInt) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMLong) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMFloat) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMDouble) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMRef) : STORE-OPCODE-8-VAR-OFFSET

defn load-opcode (offset:VMImm|False, xtype:VMType) :
  match(offset, xtype) :
    (o:False, xt:VMByte) : LOAD-OPCODE-1
    (o:False, xt:VMInt) : LOAD-OPCODE-4
    (o:False, xt:VMLong) : LOAD-OPCODE-8
    (o:False, xt:VMFloat) : LOAD-OPCODE-4
    (o:False, xt:VMDouble) : LOAD-OPCODE-8
    (o:False, xt:VMRef) : LOAD-OPCODE-8
    (o:VMImm, xt:VMByte) : LOAD-OPCODE-1-VAR-OFFSET
    (o:VMImm, xt:VMInt) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMLong) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMFloat) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMDouble) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMRef) : LOAD-OPCODE-8-VAR-OFFSET

defn op0-opcode (op:VMOp) :
  match(op) :
    (op:FlushVMOp) : FLUSH-VM-OPCODE
    (op:CRSPOp) : C-RSP-OPCODE

;Returns false if operation becomes a set operation.
defn op1-opcode (op:VMOp, xt:VMType, yt:VMType) -> Int|False :
  match(op, xt, yt) :
    (op:IntNotOp, xt:VMRef, yt:VMRef) : INT-NOT-OPCODE
    (op:IntNegOp, xt:VMRef, yt:VMRef) : INT-NEG-OPCODE
    (op:NotOp, xt:VMByte, yt:VMByte) : NOT-OPCODE-BYTE
    (op:NotOp, xt:VMInt, yt:VMInt) : NOT-OPCODE-INT
    (op:NotOp, xt:VMLong, yt:VMLong) : NOT-OPCODE-LONG
    (op:NegOp, xt:VMInt, yt:VMInt) : NEG-OPCODE-INT
    (op:NegOp, xt:VMLong, yt:VMLong) : NEG-OPCODE-LONG
    (op:NegOp, xt:VMFloat, yt:VMFloat) : NEG-OPCODE-FLOAT
    (op:NegOp, xt:VMDouble, yt:VMDouble) : NEG-OPCODE-DOUBLE
    (op:InterpretOp, xt, yt) : false
    (op:ConvOp, xt:VMByte, yt:VMByte) : false
    (op:ConvOp, xt:VMByte, yt:VMInt) : false
    (op:ConvOp, xt:VMByte, yt:VMLong) : false
    (op:ConvOp, xt:VMByte, yt:VMFloat) : CONV-OPCODE-BYTE-FLOAT
    (op:ConvOp, xt:VMByte, yt:VMDouble) : CONV-OPCODE-BYTE-DOUBLE
    (op:ConvOp, xt:VMInt, yt:VMByte) : CONV-OPCODE-INT-BYTE
    (op:ConvOp, xt:VMInt, yt:VMInt) : false
    (op:ConvOp, xt:VMInt, yt:VMLong) : false
    (op:ConvOp, xt:VMInt, yt:VMFloat) : CONV-OPCODE-INT-FLOAT
    (op:ConvOp, xt:VMInt, yt:VMDouble) : CONV-OPCODE-INT-DOUBLE
    (op:ConvOp, xt:VMLong, yt:VMByte) : CONV-OPCODE-LONG-BYTE
    (op:ConvOp, xt:VMLong, yt:VMInt) : CONV-OPCODE-LONG-INT
    (op:ConvOp, xt:VMLong, yt:VMLong) : false
    (op:ConvOp, xt:VMLong, yt:VMFloat) : CONV-OPCODE-LONG-FLOAT
    (op:ConvOp, xt:VMLong, yt:VMDouble) : CONV-OPCODE-LONG-DOUBLE
    (op:ConvOp, xt:VMFloat, yt:VMByte) : CONV-OPCODE-FLOAT-BYTE
    (op:ConvOp, xt:VMFloat, yt:VMInt) : CONV-OPCODE-FLOAT-INT
    (op:ConvOp, xt:VMFloat, yt:VMLong) : CONV-OPCODE-FLOAT-LONG
    (op:ConvOp, xt:VMFloat, yt:VMFloat) : false
    (op:ConvOp, xt:VMFloat, yt:VMDouble) : CONV-OPCODE-FLOAT-DOUBLE
    (op:ConvOp, xt:VMDouble, yt:VMByte) : CONV-OPCODE-DOUBLE-BYTE
    (op:ConvOp, xt:VMDouble, yt:VMInt) : CONV-OPCODE-DOUBLE-INT
    (op:ConvOp, xt:VMDouble, yt:VMLong) : CONV-OPCODE-DOUBLE-LONG
    (op:ConvOp, xt:VMDouble, yt:VMFloat) : CONV-OPCODE-DOUBLE-FLOAT
    (op:ConvOp, xt:VMDouble, yt:VMDouble) : false
    (op:TagOp, xt, yt) :
      switch(type(op)) :
        BYTE-TYPE : TAG-OPCODE-BYTE
        CHAR-TYPE : TAG-OPCODE-CHAR
        INT-TYPE : TAG-OPCODE-INT
        FLOAT-TYPE : TAG-OPCODE-FLOAT
    (op:DetagOp, xt, yt) : DETAG-OPCODE
    (op:DerefOp, xt, yt) : DEREF-OPCODE
    (op:GCOp, xt, yt) : GC-OPCODE
    (op:ClassNameOp, xt, yt) : CLASS-NAME-OPCODE
    (op:PrintStackTraceOp, xt, yt) : PRINT-STACK-TRACE-OPCODE
    (op:CollectStackTraceOp, xt, yt) : COLLECT-STACK-TRACE-OPCODE

defn op2-opcode (op:VMOp, xt:VMType, yt:VMType) :
  match(op, xt, yt) :
    (op:IntAddOp, xt:VMRef, yt:VMRef) : INT-ADD-OPCODE
    (op:IntSubOp, xt:VMRef, yt:VMRef) : INT-SUB-OPCODE
    (op:IntMulOp, xt:VMRef, yt:VMRef) : INT-MUL-OPCODE
    (op:IntDivOp, xt:VMRef, yt:VMRef) : INT-DIV-OPCODE
    (op:IntModOp, xt:VMRef, yt:VMRef) : INT-MOD-OPCODE
    (op:IntAndOp, xt:VMRef, yt:VMRef) : INT-AND-OPCODE
    (op:IntOrOp, xt:VMRef, yt:VMRef) : INT-OR-OPCODE
    (op:IntXorOp, xt:VMRef, yt:VMRef) : INT-XOR-OPCODE
    (op:IntShlOp, xt:VMRef, yt:VMRef) : INT-SHL-OPCODE
    (op:IntShrOp, xt:VMRef, yt:VMRef) : INT-SHR-OPCODE
    (op:IntAshrOp, xt:VMRef, yt:VMRef) : INT-ASHR-OPCODE
    (op:IntLtOp, xt:VMRef, yt:VMRef) : INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef, yt:VMRef) : INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef, yt:VMRef) : INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef, yt:VMRef) : INT-GE-OPCODE
    (op:RefEqOp, xt:VMRef, yt:VMRef) : REF-EQ-OPCODE
    (op:RefNeOp, xt:VMRef, yt:VMRef) : REF-NE-OPCODE
    (op:EqOp, xt:VMLong, yt:VMRef) : EQ-OPCODE-REF
    (op:EqOp, xt:VMLong, yt:VMByte) : EQ-OPCODE-BYTE
    (op:EqOp, xt:VMLong, yt:VMInt) : EQ-OPCODE-INT
    (op:EqOp, xt:VMLong, yt:VMLong) : EQ-OPCODE-LONG
    (op:EqOp, xt:VMLong, yt:VMFloat) : EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMLong, yt:VMDouble) : EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMLong, yt:VMRef) : NE-OPCODE-REF
    (op:NeOp, xt:VMLong, yt:VMByte) : NE-OPCODE-BYTE
    (op:NeOp, xt:VMLong, yt:VMInt) : NE-OPCODE-INT
    (op:NeOp, xt:VMLong, yt:VMLong) : NE-OPCODE-LONG
    (op:NeOp, xt:VMLong, yt:VMFloat) : NE-OPCODE-FLOAT
    (op:NeOp, xt:VMLong, yt:VMDouble) : NE-OPCODE-DOUBLE
    (op:AddOp, xt:VMByte, yt:VMByte) : ADD-OPCODE-BYTE
    (op:AddOp, xt:VMInt, yt:VMInt) : ADD-OPCODE-INT
    (op:AddOp, xt:VMLong, yt:VMLong) : ADD-OPCODE-LONG
    (op:AddOp, xt:VMFloat, yt:VMFloat) : ADD-OPCODE-FLOAT
    (op:AddOp, xt:VMDouble, yt:VMDouble) : ADD-OPCODE-DOUBLE
    (op:SubOp, xt:VMByte, yt:VMByte) : SUB-OPCODE-BYTE
    (op:SubOp, xt:VMInt, yt:VMInt) : SUB-OPCODE-INT
    (op:SubOp, xt:VMLong, yt:VMLong) : SUB-OPCODE-LONG
    (op:SubOp, xt:VMFloat, yt:VMFloat) : SUB-OPCODE-FLOAT
    (op:SubOp, xt:VMDouble, yt:VMDouble) : SUB-OPCODE-DOUBLE
    (op:MulOp, xt:VMByte, yt:VMByte) : MUL-OPCODE-BYTE
    (op:MulOp, xt:VMInt, yt:VMInt) : MUL-OPCODE-INT
    (op:MulOp, xt:VMLong, yt:VMLong) : MUL-OPCODE-LONG
    (op:MulOp, xt:VMFloat, yt:VMFloat) : MUL-OPCODE-FLOAT
    (op:MulOp, xt:VMDouble, yt:VMDouble) : MUL-OPCODE-DOUBLE
    (op:DivOp, xt:VMByte, yt:VMByte) : DIV-OPCODE-BYTE
    (op:DivOp, xt:VMInt, yt:VMInt) : DIV-OPCODE-INT
    (op:DivOp, xt:VMLong, yt:VMLong) : DIV-OPCODE-LONG
    (op:DivOp, xt:VMFloat, yt:VMFloat) : DIV-OPCODE-FLOAT
    (op:DivOp, xt:VMDouble, yt:VMDouble) : DIV-OPCODE-DOUBLE
    (op:ModOp, xt:VMByte, yt:VMByte) : MOD-OPCODE-BYTE
    (op:ModOp, xt:VMInt, yt:VMInt) : MOD-OPCODE-INT
    (op:ModOp, xt:VMLong, yt:VMLong) : MOD-OPCODE-LONG
    (op:AndOp, xt:VMByte, yt:VMByte) : AND-OPCODE-BYTE
    (op:AndOp, xt:VMInt, yt:VMInt) : AND-OPCODE-INT
    (op:AndOp, xt:VMLong, yt:VMLong) : AND-OPCODE-LONG
    (op:OrOp, xt:VMByte, yt:VMByte) : OR-OPCODE-BYTE
    (op:OrOp, xt:VMInt, yt:VMInt) : OR-OPCODE-INT
    (op:OrOp, xt:VMLong, yt:VMLong) : OR-OPCODE-LONG
    (op:XorOp, xt:VMByte, yt:VMByte) : XOR-OPCODE-BYTE
    (op:XorOp, xt:VMInt, yt:VMInt) : XOR-OPCODE-INT
    (op:XorOp, xt:VMLong, yt:VMLong) : XOR-OPCODE-LONG
    (op:ShlOp, xt:VMByte, yt:VMByte) : SHL-OPCODE-BYTE
    (op:ShlOp, xt:VMInt, yt:VMInt) : SHL-OPCODE-INT
    (op:ShlOp, xt:VMLong, yt:VMLong) : SHL-OPCODE-LONG
    (op:ShrOp, xt:VMByte, yt:VMByte) : SHR-OPCODE-BYTE
    (op:ShrOp, xt:VMInt, yt:VMInt) : SHR-OPCODE-INT
    (op:ShrOp, xt:VMLong, yt:VMLong) : SHR-OPCODE-LONG
    (op:AshrOp, xt:VMInt, yt:VMInt) : ASHR-OPCODE-INT
    (op:AshrOp, xt:VMLong, yt:VMLong) : ASHR-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMInt) : LT-OPCODE-INT
    (op:LtOp, xt:VMLong, yt:VMLong) : LT-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMFloat) : LT-OPCODE-FLOAT
    (op:LtOp, xt:VMLong, yt:VMDouble) : LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMLong, yt:VMInt) : GT-OPCODE-INT
    (op:GtOp, xt:VMLong, yt:VMLong) : GT-OPCODE-LONG
    (op:GtOp, xt:VMLong, yt:VMFloat) : GT-OPCODE-FLOAT
    (op:GtOp, xt:VMLong, yt:VMDouble) : GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMLong, yt:VMInt) : LE-OPCODE-INT
    (op:LeOp, xt:VMLong, yt:VMLong) : LE-OPCODE-LONG
    (op:LeOp, xt:VMLong, yt:VMFloat) : LE-OPCODE-FLOAT
    (op:LeOp, xt:VMLong, yt:VMDouble) : LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMLong, yt:VMInt) : GE-OPCODE-INT
    (op:GeOp, xt:VMLong, yt:VMLong) : GE-OPCODE-LONG
    (op:GeOp, xt:VMLong, yt:VMFloat) : GE-OPCODE-FLOAT
    (op:GeOp, xt:VMLong, yt:VMDouble) : GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMLong, yt:VMByte) : ULT-OPCODE-BYTE
    (op:UltOp, xt:VMLong, yt:VMInt) : ULT-OPCODE-INT
    (op:UltOp, xt:VMLong, yt:VMLong) : ULT-OPCODE-LONG
    (op:UleOp, xt:VMLong, yt:VMByte) : ULE-OPCODE-BYTE
    (op:UleOp, xt:VMLong, yt:VMInt) : ULE-OPCODE-INT
    (op:UleOp, xt:VMLong, yt:VMLong) : ULE-OPCODE-LONG
    (op:UgtOp, xt:VMLong, yt:VMByte) : UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMLong, yt:VMInt) : UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong, yt:VMLong) : UGT-OPCODE-LONG
    (op:UgeOp, xt:VMLong, yt:VMByte) : UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMLong, yt:VMInt) : UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong, yt:VMLong) : UGE-OPCODE-LONG

defn branch2-opcode (op:VMOp, xt:VMType) :
  match(op, xt) :
    (op:IntLtOp, xt:VMRef) : JUMP-INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef) : JUMP-INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef) : JUMP-INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef) : JUMP-INT-GE-OPCODE
    (op:EqOp, xt:VMRef) : JUMP-EQ-OPCODE-REF
    (op:EqOp, xt:VMByte) : JUMP-EQ-OPCODE-BYTE
    (op:EqOp, xt:VMInt) : JUMP-EQ-OPCODE-INT
    (op:EqOp, xt:VMLong) : JUMP-EQ-OPCODE-LONG
    (op:EqOp, xt:VMFloat) : JUMP-EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMDouble) : JUMP-EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef) : JUMP-NE-OPCODE-REF
    (op:NeOp, xt:VMByte) : JUMP-NE-OPCODE-BYTE
    (op:NeOp, xt:VMInt) : JUMP-NE-OPCODE-INT
    (op:NeOp, xt:VMLong) : JUMP-NE-OPCODE-LONG
    (op:NeOp, xt:VMFloat) : JUMP-NE-OPCODE-FLOAT
    (op:NeOp, xt:VMDouble) : JUMP-NE-OPCODE-DOUBLE
    (op:LtOp, xt:VMInt) : JUMP-LT-OPCODE-INT
    (op:LtOp, xt:VMLong) : JUMP-LT-OPCODE-LONG
    (op:LtOp, xt:VMFloat) : JUMP-LT-OPCODE-FLOAT
    (op:LtOp, xt:VMDouble) : JUMP-LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMInt) : JUMP-GT-OPCODE-INT
    (op:GtOp, xt:VMLong) : JUMP-GT-OPCODE-LONG
    (op:GtOp, xt:VMFloat) : JUMP-GT-OPCODE-FLOAT
    (op:GtOp, xt:VMDouble) : JUMP-GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMInt) : JUMP-LE-OPCODE-INT
    (op:LeOp, xt:VMLong) : JUMP-LE-OPCODE-LONG
    (op:LeOp, xt:VMFloat) : JUMP-LE-OPCODE-FLOAT
    (op:LeOp, xt:VMDouble) : JUMP-LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMInt) : JUMP-GE-OPCODE-INT
    (op:GeOp, xt:VMLong) : JUMP-GE-OPCODE-LONG
    (op:GeOp, xt:VMFloat) : JUMP-GE-OPCODE-FLOAT
    (op:GeOp, xt:VMDouble) : JUMP-GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMByte) : JUMP-ULT-OPCODE-BYTE
    (op:UltOp, xt:VMInt) : JUMP-ULT-OPCODE-INT
    (op:UltOp, xt:VMLong) : JUMP-ULT-OPCODE-LONG
    (op:UleOp, xt:VMByte) : JUMP-ULE-OPCODE-BYTE
    (op:UleOp, xt:VMInt) : JUMP-ULE-OPCODE-INT
    (op:UleOp, xt:VMLong) : JUMP-ULE-OPCODE-LONG
    (op:UgtOp, xt:VMByte) : JUMP-UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMInt) : JUMP-UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong) : JUMP-UGT-OPCODE-LONG
    (op:UgeOp, xt:VMByte) : JUMP-UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMInt) : JUMP-UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong) : JUMP-UGE-OPCODE-LONG

public val opcode-names = IntTable<String>()
opcode-names[SET-OPCODE-LOCAL] = "SET-OPCODE-LOCAL"
opcode-names[SET-OPCODE-UNSIGNED] = "SET-OPCODE-UNSIGNED"
opcode-names[SET-OPCODE-SIGNED] = "SET-OPCODE-SIGNED"
opcode-names[SET-OPCODE-CODE] = "SET-OPCODE-CODE"
opcode-names[SET-OPCODE-GLOBAL] = "SET-OPCODE-GLOBAL"
opcode-names[SET-OPCODE-DATA] = "SET-OPCODE-DATA"
opcode-names[SET-OPCODE-CONST] = "SET-OPCODE-CONST"
opcode-names[SET-OPCODE-WIDE] = "SET-OPCODE-WIDE"
opcode-names[SET-REG-OPCODE-LOCAL] = "SET-REG-OPCODE-LOCAL"
opcode-names[SET-REG-OPCODE-UNSIGNED] = "SET-REG-OPCODE-UNSIGNED"
opcode-names[SET-REG-OPCODE-SIGNED] = "SET-REG-OPCODE-SIGNED"
opcode-names[SET-REG-OPCODE-CODE] = "SET-REG-OPCODE-CODE"
opcode-names[SET-REG-OPCODE-GLOBAL] = "SET-REG-OPCODE-GLOBAL"
opcode-names[SET-REG-OPCODE-DATA] = "SET-REG-OPCODE-DATA"
opcode-names[SET-REG-OPCODE-CONST] = "SET-REG-OPCODE-CONST"
opcode-names[SET-REG-OPCODE-WIDE] = "SET-REG-OPCODE-WIDE"
opcode-names[GET-REG-OPCODE] = "GET-REG-OPCODE"
opcode-names[CALL-OPCODE-LOCAL] = "CALL-OPCODE-LOCAL"
opcode-names[CALL-OPCODE-CODE] = "CALL-OPCODE-CODE"
opcode-names[CALL-CLOSURE-OPCODE] = "CALL-CLOSURE-OPCODE"
opcode-names[TCALL-OPCODE-LOCAL] = "TCALL-OPCODE-LOCAL"
opcode-names[TCALL-OPCODE-CODE] = "TCALL-OPCODE-CODE"
opcode-names[TCALL-CLOSURE-OPCODE] = "TCALL-CLOSURE-OPCODE"
opcode-names[CALLC-OPCODE-LOCAL] = "CALLC-OPCODE-LOCAL"
opcode-names[CALLC-OPCODE-WIDE] = "CALLC-OPCODE-WIDE"
opcode-names[POP-FRAME-OPCODE] = "POP-FRAME-OPCODE"
opcode-names[LIVE-OPCODE] = "LIVE-OPCODE"
opcode-names[YIELD-OPCODE] = "YIELD-OPCODE"
opcode-names[RETURN-OPCODE] = "RETURN-OPCODE"
opcode-names[DUMP-OPCODE] = "DUMP-OPCODE"
opcode-names[INT-ADD-OPCODE] = "INT-ADD-OPCODE"
opcode-names[INT-SUB-OPCODE] = "INT-SUB-OPCODE"
opcode-names[INT-MUL-OPCODE] = "INT-MUL-OPCODE"
opcode-names[INT-DIV-OPCODE] = "INT-DIV-OPCODE"
opcode-names[INT-MOD-OPCODE] = "INT-MOD-OPCODE"
opcode-names[INT-AND-OPCODE] = "INT-AND-OPCODE"
opcode-names[INT-OR-OPCODE] = "INT-OR-OPCODE"
opcode-names[INT-XOR-OPCODE] = "INT-XOR-OPCODE"
opcode-names[INT-SHL-OPCODE] = "INT-SHL-OPCODE"
opcode-names[INT-SHR-OPCODE] = "INT-SHR-OPCODE"
opcode-names[INT-ASHR-OPCODE] = "INT-ASHR-OPCODE"
opcode-names[INT-LT-OPCODE] = "INT-LT-OPCODE"
opcode-names[INT-GT-OPCODE] = "INT-GT-OPCODE"
opcode-names[INT-LE-OPCODE] = "INT-LE-OPCODE"
opcode-names[INT-GE-OPCODE] = "INT-GE-OPCODE"
opcode-names[REF-EQ-OPCODE] = "REF-EQ-OPCODE"
opcode-names[EQ-OPCODE-REF] = "EQ-OPCODE-REF"
opcode-names[EQ-OPCODE-BYTE] = "EQ-OPCODE-BYTE"
opcode-names[EQ-OPCODE-INT] = "EQ-OPCODE-INT"
opcode-names[EQ-OPCODE-LONG] = "EQ-OPCODE-LONG"
opcode-names[EQ-OPCODE-FLOAT] = "EQ-OPCODE-FLOAT"
opcode-names[EQ-OPCODE-DOUBLE] = "EQ-OPCODE-DOUBLE"
opcode-names[REF-NE-OPCODE] = "REF-NE-OPCODE"
opcode-names[NE-OPCODE-REF] = "NE-OPCODE-REF"
opcode-names[NE-OPCODE-BYTE] = "NE-OPCODE-BYTE"
opcode-names[NE-OPCODE-INT] = "NE-OPCODE-INT"
opcode-names[NE-OPCODE-LONG] = "NE-OPCODE-LONG"
opcode-names[NE-OPCODE-FLOAT] = "NE-OPCODE-FLOAT"
opcode-names[NE-OPCODE-DOUBLE] = "NE-OPCODE-DOUBLE"
opcode-names[ADD-OPCODE-BYTE] = "ADD-OPCODE-BYTE"
opcode-names[ADD-OPCODE-INT] = "ADD-OPCODE-INT"
opcode-names[ADD-OPCODE-LONG] = "ADD-OPCODE-LONG"
opcode-names[ADD-OPCODE-FLOAT] = "ADD-OPCODE-FLOAT"
opcode-names[ADD-OPCODE-DOUBLE] = "ADD-OPCODE-DOUBLE"
opcode-names[SUB-OPCODE-BYTE] = "SUB-OPCODE-BYTE"
opcode-names[SUB-OPCODE-INT] = "SUB-OPCODE-INT"
opcode-names[SUB-OPCODE-LONG] = "SUB-OPCODE-LONG"
opcode-names[SUB-OPCODE-FLOAT] = "SUB-OPCODE-FLOAT"
opcode-names[SUB-OPCODE-DOUBLE] = "SUB-OPCODE-DOUBLE"
opcode-names[MUL-OPCODE-BYTE] = "MUL-OPCODE-BYTE"
opcode-names[MUL-OPCODE-INT] = "MUL-OPCODE-INT"
opcode-names[MUL-OPCODE-LONG] = "MUL-OPCODE-LONG"
opcode-names[MUL-OPCODE-FLOAT] = "MUL-OPCODE-FLOAT"
opcode-names[MUL-OPCODE-DOUBLE] = "MUL-OPCODE-DOUBLE"
opcode-names[DIV-OPCODE-BYTE] = "DIV-OPCODE-BYTE"
opcode-names[DIV-OPCODE-INT] = "DIV-OPCODE-INT"
opcode-names[DIV-OPCODE-LONG] = "DIV-OPCODE-LONG"
opcode-names[DIV-OPCODE-FLOAT] = "DIV-OPCODE-FLOAT"
opcode-names[DIV-OPCODE-DOUBLE] = "DIV-OPCODE-DOUBLE"
opcode-names[MOD-OPCODE-BYTE] = "MOD-OPCODE-BYTE"
opcode-names[MOD-OPCODE-INT] = "MOD-OPCODE-INT"
opcode-names[MOD-OPCODE-LONG] = "MOD-OPCODE-LONG"
opcode-names[AND-OPCODE-BYTE] = "AND-OPCODE-BYTE"
opcode-names[AND-OPCODE-INT] = "AND-OPCODE-INT"
opcode-names[AND-OPCODE-LONG] = "AND-OPCODE-LONG"
opcode-names[OR-OPCODE-BYTE] = "OR-OPCODE-BYTE"
opcode-names[OR-OPCODE-INT] = "OR-OPCODE-INT"
opcode-names[OR-OPCODE-LONG] = "OR-OPCODE-LONG"
opcode-names[XOR-OPCODE-BYTE] = "XOR-OPCODE-BYTE"
opcode-names[XOR-OPCODE-INT] = "XOR-OPCODE-INT"
opcode-names[XOR-OPCODE-LONG] = "XOR-OPCODE-LONG"
opcode-names[SHL-OPCODE-BYTE] = "SHL-OPCODE-BYTE"
opcode-names[SHL-OPCODE-INT] = "SHL-OPCODE-INT"
opcode-names[SHL-OPCODE-LONG] = "SHL-OPCODE-LONG"
opcode-names[SHR-OPCODE-BYTE] = "SHR-OPCODE-BYTE"
opcode-names[SHR-OPCODE-INT] = "SHR-OPCODE-INT"
opcode-names[SHR-OPCODE-LONG] = "SHR-OPCODE-LONG"
opcode-names[ASHR-OPCODE-INT] = "ASHR-OPCODE-INT"
opcode-names[ASHR-OPCODE-LONG] = "ASHR-OPCODE-LONG"
opcode-names[LT-OPCODE-INT] = "LT-OPCODE-INT"
opcode-names[LT-OPCODE-LONG] = "LT-OPCODE-LONG"
opcode-names[LT-OPCODE-FLOAT] = "LT-OPCODE-FLOAT"
opcode-names[LT-OPCODE-DOUBLE] = "LT-OPCODE-DOUBLE"
opcode-names[GT-OPCODE-INT] = "GT-OPCODE-INT"
opcode-names[GT-OPCODE-LONG] = "GT-OPCODE-LONG"
opcode-names[GT-OPCODE-FLOAT] = "GT-OPCODE-FLOAT"
opcode-names[GT-OPCODE-DOUBLE] = "GT-OPCODE-DOUBLE"
opcode-names[LE-OPCODE-INT] = "LE-OPCODE-INT"
opcode-names[LE-OPCODE-LONG] = "LE-OPCODE-LONG"
opcode-names[LE-OPCODE-FLOAT] = "LE-OPCODE-FLOAT"
opcode-names[LE-OPCODE-DOUBLE] = "LE-OPCODE-DOUBLE"
opcode-names[GE-OPCODE-INT] = "GE-OPCODE-INT"
opcode-names[GE-OPCODE-LONG] = "GE-OPCODE-LONG"
opcode-names[GE-OPCODE-FLOAT] = "GE-OPCODE-FLOAT"
opcode-names[GE-OPCODE-DOUBLE] = "GE-OPCODE-DOUBLE"
opcode-names[ULE-OPCODE-BYTE] = "ULE-OPCODE-BYTE"
opcode-names[ULE-OPCODE-INT] = "ULE-OPCODE-INT"
opcode-names[ULE-OPCODE-LONG] = "ULE-OPCODE-LONG"
opcode-names[ULT-OPCODE-BYTE] = "ULT-OPCODE-BYTE"
opcode-names[ULT-OPCODE-INT] = "ULT-OPCODE-INT"
opcode-names[ULT-OPCODE-LONG] = "ULT-OPCODE-LONG"
opcode-names[UGT-OPCODE-BYTE] = "UGT-OPCODE-BYTE"
opcode-names[UGT-OPCODE-INT] = "UGT-OPCODE-INT"
opcode-names[UGT-OPCODE-LONG] = "UGT-OPCODE-LONG"
opcode-names[UGE-OPCODE-BYTE] = "UGE-OPCODE-BYTE"
opcode-names[UGE-OPCODE-INT] = "UGE-OPCODE-INT"
opcode-names[UGE-OPCODE-LONG] = "UGE-OPCODE-LONG"
opcode-names[INT-NOT-OPCODE] = "INT-NOT-OPCODE"
opcode-names[INT-NEG-OPCODE] = "INT-NEG-OPCODE"
opcode-names[NOT-OPCODE-BYTE] = "NOT-OPCODE-BYTE"
opcode-names[NOT-OPCODE-INT] = "NOT-OPCODE-INT"
opcode-names[NOT-OPCODE-LONG] = "NOT-OPCODE-LONG"
opcode-names[NEG-OPCODE-INT] = "NEG-OPCODE-INT"
opcode-names[NEG-OPCODE-LONG] = "NEG-OPCODE-LONG"
opcode-names[NEG-OPCODE-FLOAT] = "NEG-OPCODE-FLOAT"
opcode-names[NEG-OPCODE-DOUBLE] = "NEG-OPCODE-DOUBLE"
opcode-names[DEREF-OPCODE] = "DEREF-OPCODE"
opcode-names[TYPEOF-OPCODE] = "TYPEOF-OPCODE"
opcode-names[JUMP-SET-OPCODE] = "JUMP-SET-OPCODE"
opcode-names[JUMP-TAGBITS-OPCODE] = "JUMP-TAGBITS-OPCODE"
opcode-names[JUMP-TAGWORD-OPCODE] = "JUMP-TAGWORD-OPCODE"
opcode-names[GOTO-OPCODE] = "GOTO-OPCODE"
opcode-names[CONV-OPCODE-BYTE-FLOAT] = "CONV-OPCODE-BYTE-FLOAT"
opcode-names[CONV-OPCODE-BYTE-DOUBLE] = "CONV-OPCODE-BYTE-DOUBLE"
opcode-names[CONV-OPCODE-INT-BYTE] = "CONV-OPCODE-INT-BYTE"
opcode-names[CONV-OPCODE-INT-FLOAT] = "CONV-OPCODE-INT-FLOAT"
opcode-names[CONV-OPCODE-INT-DOUBLE] = "CONV-OPCODE-INT-DOUBLE"
opcode-names[CONV-OPCODE-LONG-BYTE] = "CONV-OPCODE-LONG-BYTE"
opcode-names[CONV-OPCODE-LONG-INT] = "CONV-OPCODE-LONG-INT"
opcode-names[CONV-OPCODE-LONG-FLOAT] = "CONV-OPCODE-LONG-FLOAT"
opcode-names[CONV-OPCODE-LONG-DOUBLE] = "CONV-OPCODE-LONG-DOUBLE"
opcode-names[CONV-OPCODE-FLOAT-BYTE] = "CONV-OPCODE-FLOAT-BYTE"
opcode-names[CONV-OPCODE-FLOAT-INT] = "CONV-OPCODE-FLOAT-INT"
opcode-names[CONV-OPCODE-FLOAT-LONG] = "CONV-OPCODE-FLOAT-LONG"
opcode-names[CONV-OPCODE-FLOAT-DOUBLE] = "CONV-OPCODE-FLOAT-DOUBLE"
opcode-names[CONV-OPCODE-DOUBLE-BYTE] = "CONV-OPCODE-DOUBLE-BYTE"
opcode-names[CONV-OPCODE-DOUBLE-INT] = "CONV-OPCODE-DOUBLE-INT"
opcode-names[CONV-OPCODE-DOUBLE-LONG] = "CONV-OPCODE-DOUBLE-LONG"
opcode-names[CONV-OPCODE-DOUBLE-FLOAT] = "CONV-OPCODE-DOUBLE-FLOAT"
opcode-names[DETAG-OPCODE] = "DETAG-OPCODE"
opcode-names[TAG-OPCODE-BYTE] = "TAG-OPCODE-BYTE"
opcode-names[TAG-OPCODE-CHAR] = "TAG-OPCODE-CHAR"
opcode-names[TAG-OPCODE-INT] = "TAG-OPCODE-INT"
opcode-names[TAG-OPCODE-FLOAT] = "TAG-OPCODE-FLOAT"
opcode-names[STORE-OPCODE-1] = "STORE-OPCODE-1"
opcode-names[STORE-OPCODE-4] = "STORE-OPCODE-4"
opcode-names[STORE-OPCODE-8] = "STORE-OPCODE-8"
opcode-names[STORE-OPCODE-1-VAR-OFFSET] = "STORE-OPCODE-1-VAR-OFFSET"
opcode-names[STORE-OPCODE-4-VAR-OFFSET] = "STORE-OPCODE-4-VAR-OFFSET"
opcode-names[STORE-OPCODE-8-VAR-OFFSET] = "STORE-OPCODE-8-VAR-OFFSET"
opcode-names[LOAD-OPCODE-1] = "LOAD-OPCODE-1"
opcode-names[LOAD-OPCODE-4] = "LOAD-OPCODE-4"
opcode-names[LOAD-OPCODE-8] = "LOAD-OPCODE-8"
opcode-names[LOAD-OPCODE-1-VAR-OFFSET] = "LOAD-OPCODE-1-VAR-OFFSET"
opcode-names[LOAD-OPCODE-4-VAR-OFFSET] = "LOAD-OPCODE-4-VAR-OFFSET"
opcode-names[LOAD-OPCODE-8-VAR-OFFSET] = "LOAD-OPCODE-8-VAR-OFFSET"
opcode-names[RESERVE-OPCODE-LOCAL] = "RESERVE-OPCODE-LOCAL"
opcode-names[RESERVE-OPCODE-CONST] = "RESERVE-OPCODE-CONST"
opcode-names[ENTER-STACK-OPCODE] = "ENTER-STACK-OPCODE"
opcode-names[ALLOC-OPCODE-CONST] = "ALLOC-OPCODE-CONST"
opcode-names[ALLOC-OPCODE-LOCAL] = "ALLOC-OPCODE-LOCAL"
opcode-names[GC-OPCODE] = "GC-OPCODE"
opcode-names[CLASS-NAME-OPCODE] = "CLASS-NAME-OPCODE"
opcode-names[C-RSP-OPCODE] = "C-RSP-OPCODE"
opcode-names[PRINT-STACK-TRACE-OPCODE] = "PRINT-STACK-TRACE-OPCODE"
opcode-names[COLLECT-STACK-TRACE-OPCODE] = "COLLECT-STACK-TRACE-OPCODE"
opcode-names[FLUSH-VM-OPCODE] = "FLUSH-VM-OPCODE"
opcode-names[JUMP-INT-LT-OPCODE] = "JUMP-INT-LT-OPCODE"
opcode-names[JUMP-INT-GT-OPCODE] = "JUMP-INT-GT-OPCODE"
opcode-names[JUMP-INT-LE-OPCODE] = "JUMP-INT-LE-OPCODE"
opcode-names[JUMP-INT-GE-OPCODE] = "JUMP-INT-GE-OPCODE"
opcode-names[JUMP-EQ-OPCODE-REF] = "JUMP-EQ-OPCODE-REF"
opcode-names[JUMP-EQ-OPCODE-BYTE] = "JUMP-EQ-OPCODE-BYTE"
opcode-names[JUMP-EQ-OPCODE-INT] = "JUMP-EQ-OPCODE-INT"
opcode-names[JUMP-EQ-OPCODE-LONG] = "JUMP-EQ-OPCODE-LONG"
opcode-names[JUMP-EQ-OPCODE-FLOAT] = "JUMP-EQ-OPCODE-FLOAT"
opcode-names[JUMP-EQ-OPCODE-DOUBLE] = "JUMP-EQ-OPCODE-DOUBLE"
opcode-names[JUMP-NE-OPCODE-REF] = "JUMP-NE-OPCODE-REF"
opcode-names[JUMP-NE-OPCODE-BYTE] = "JUMP-NE-OPCODE-BYTE"
opcode-names[JUMP-NE-OPCODE-INT] = "JUMP-NE-OPCODE-INT"
opcode-names[JUMP-NE-OPCODE-LONG] = "JUMP-NE-OPCODE-LONG"
opcode-names[JUMP-NE-OPCODE-FLOAT] = "JUMP-NE-OPCODE-FLOAT"
opcode-names[JUMP-NE-OPCODE-DOUBLE] = "JUMP-NE-OPCODE-DOUBLE"
opcode-names[JUMP-LT-OPCODE-INT] = "JUMP-LT-OPCODE-INT"
opcode-names[JUMP-LT-OPCODE-LONG] = "JUMP-LT-OPCODE-LONG"
opcode-names[JUMP-LT-OPCODE-FLOAT] = "JUMP-LT-OPCODE-FLOAT"
opcode-names[JUMP-LT-OPCODE-DOUBLE] = "JUMP-LT-OPCODE-DOUBLE"
opcode-names[JUMP-GT-OPCODE-INT] = "JUMP-GT-OPCODE-INT"
opcode-names[JUMP-GT-OPCODE-LONG] = "JUMP-GT-OPCODE-LONG"
opcode-names[JUMP-GT-OPCODE-FLOAT] = "JUMP-GT-OPCODE-FLOAT"
opcode-names[JUMP-GT-OPCODE-DOUBLE] = "JUMP-GT-OPCODE-DOUBLE"
opcode-names[JUMP-LE-OPCODE-INT] = "JUMP-LE-OPCODE-INT"
opcode-names[JUMP-LE-OPCODE-LONG] = "JUMP-LE-OPCODE-LONG"
opcode-names[JUMP-LE-OPCODE-FLOAT] = "JUMP-LE-OPCODE-FLOAT"
opcode-names[JUMP-LE-OPCODE-DOUBLE] = "JUMP-LE-OPCODE-DOUBLE"
opcode-names[JUMP-GE-OPCODE-INT] = "JUMP-GE-OPCODE-INT"
opcode-names[JUMP-GE-OPCODE-LONG] = "JUMP-GE-OPCODE-LONG"
opcode-names[JUMP-GE-OPCODE-FLOAT] = "JUMP-GE-OPCODE-FLOAT"
opcode-names[JUMP-GE-OPCODE-DOUBLE] = "JUMP-GE-OPCODE-DOUBLE"
opcode-names[JUMP-ULE-OPCODE-BYTE] = "JUMP-ULE-OPCODE-BYTE"
opcode-names[JUMP-ULE-OPCODE-INT] = "JUMP-ULE-OPCODE-INT"
opcode-names[JUMP-ULE-OPCODE-LONG] = "JUMP-ULE-OPCODE-LONG"
opcode-names[JUMP-ULT-OPCODE-BYTE] = "JUMP-ULT-OPCODE-BYTE"
opcode-names[JUMP-ULT-OPCODE-INT] = "JUMP-ULT-OPCODE-INT"
opcode-names[JUMP-ULT-OPCODE-LONG] = "JUMP-ULT-OPCODE-LONG"
opcode-names[JUMP-UGT-OPCODE-BYTE] = "JUMP-UGT-OPCODE-BYTE"
opcode-names[JUMP-UGT-OPCODE-INT] = "JUMP-UGT-OPCODE-INT"
opcode-names[JUMP-UGT-OPCODE-LONG] = "JUMP-UGT-OPCODE-LONG"
opcode-names[JUMP-UGE-OPCODE-BYTE] = "JUMP-UGE-OPCODE-BYTE"
opcode-names[JUMP-UGE-OPCODE-INT] = "JUMP-UGE-OPCODE-INT"
opcode-names[JUMP-UGE-OPCODE-LONG] = "JUMP-UGE-OPCODE-LONG"
opcode-names[DISPATCH-OPCODE] = "DISPATCH-OPCODE"
opcode-names[DISPATCH-METHOD-OPCODE] = "DISPATCH-METHOD-OPCODE"
opcode-names[JUMP-REG-OPCODE] = "JUMP-REG-OPCODE"
opcode-names[FNENTRY-OPCODE] = "FNENTRY-OPCODE"
