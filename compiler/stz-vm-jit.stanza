defpackage stz/vm-jit :
  import core
  import collections
  import stz/vm-ir
  import stz/typeset
  import stz/vm-ids
  import stz/basic-ops
  import stz/call-records
  import stz/backend
  import stz/utils
  import stz/set-utils
  import stz/conversion-utils
  import stz/dispatch-dag
  import stz/asmjit

extern c_trampoline: (ptr<?>, ptr<?>, ptr<?>) -> int

defn hex (n:Long) -> String :
  var chars:List<Char> = List()
  let loop (n:Long = n) :
    if n != 0L :
      val temp = to-int(n % 16L)
      val c = to-char(temp + 48) when (temp < 10) else to-char(temp + 55)
      chars = cons(c, chars)
      loop(n / 16L)
  val buf = StringBuffer()
  add-all(buf, chars)
  to-string(buf)

defn hex (n:Int) -> String : hex(to-long(n))

;TODO: DUMMY
defn Func (rt:JitRuntime) -> Func :
  add(rt, code-holder-new(rt))

public deftype EncodingResolver
public defmulti liveness-map (r:EncodingResolver, live:Tuple<Int>, num-locals:Int) -> Int
public defmulti object-header-size (r:EncodingResolver) -> Int
public defmulti object-size-on-heap (r:EncodingResolver, sz:Int) -> Int
public defmulti stack-size (r:EncodingResolver) -> Int
public defmulti dispatch-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti match-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti method-format (r:EncodingResolver, multi:Int, num-header-args:Int, num-args:Int) -> Int
public defmulti marker (r:EncodingResolver, type:Int) -> Int
public defmulti void-marker (r:EncodingResolver) -> Int
public defmulti ref-offset (r:EncodingResolver) -> Int
public defmulti type-is-final? (r:EncodingResolver, n:Int) -> True|False
public defmulti marker? (r:EncodingResolver, n:Int) -> True|False
public defmulti tagbits (r:EncodingResolver, typeid:Int) -> Int

public defstruct EncodedFunction :
  func: Func
  fileinfos: Vector<FileInfoEntry>

public defn value (ef:EncodedFunction) -> Long :
  value(func(ef))
  
public defstruct FileInfoEntry :
  pc: Int
  fileinfo: FileInfo

defn c-params () : [rdi(), rsi(), rdx(), rcx(), r8(), r9()]

defn bind-parameters (a:Assembler, args:Seqable<Gp>) :
  val params = c-params()
  ;TODO: CHECK NOT TOO MANY ARGS
  for (param in params, arg in args) do :
    mov(a, param, arg)

; extern c_trampoline_stub: (long, ptr<long>, ptr<long>) -> int

lostanza defn c-call (a:ref<Assembler>, faddr:ref<Long>, args:ref<Tuple<Gp>>) -> ref<Gp> :
  caller-save-registers(a)
  bind-parameters(a, args)
  mov(a, tmp1(), faddr)
  call(a, tmp1())
  caller-restore-registers(a)
  return rax()

lostanza defn c-trampoline-addr () -> ref<Long> :
  return new Long{addr!(c_trampoline) as long}

defn c-trampoline (a:Assembler, faddr:Gp, registers:Gp, returns:Gp) :
  c-call(a, c-trampoline-addr(), [faddr, registers, returns])

extern read_dispatch_table: (ptr<?>, int) -> int

lostanza defn read-dispatch-table-addr () -> ref<Long> :
  return new Long{addr!(read_dispatch_table) as long}

defn read-dispatch-table (a:Assembler, vmstate:Gp, format:Gp) -> Gp :
  c-call(a, read-dispatch-table-addr(), [vmstate, format])

extern call_garbage_collector: (ptr<?>, long) -> int

lostanza defn call-garbage-collector-addr () -> ref<Long> :
  return new Long{addr!(call_garbage_collector) as long}

defn call-garbage-collector (a:Assembler, vmstate:Gp, size:Gp) -> Gp :
  c-call(a, call-garbage-collector-addr(), [vmstate, size])

extern call_print_stack_trace: (ptr<?>, long) -> int

lostanza defn call-print-stack-trace-addr () -> ref<Long> :
  return new Long{addr!(call_print_stack_trace) as long}

defn call-print-stack-trace (a:Assembler, vmstate:Gp, stack:Gp) -> Gp :
  c-call(a, call-print-stack-trace-addr(), [vmstate, stack])

extern retrieve_class_name: (ptr<?>, long) -> int

lostanza defn retrieve-class-name-addr () -> ref<Long> :
  return new Long{addr!(retrieve_class_name) as long}

defn retrieve-class-name (a:Assembler, vmstate:Gp, stack:Gp) -> Gp :
  c-call(a, retrieve-class-name-addr(), [vmstate, stack])

val SIZEOF-BYTE = 1
val SIZEOF-INT  = 4
val SIZEOF-LONG = 8

val vmstate-offsets = Counter(0)
val VMSTATE-INSTRUCTIONS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-REGISTERS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-GLOBAL-OFFSETS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-GLOBAL-MEM-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-CONST-TABLE-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-CONST-MEM-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-DATA-OFFSETS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-DATA-MEM-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-FUNCTIONS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-HEAP-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-HEAP-TOP-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-HEAP-LIMIT-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-FREE-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-FREE-LIMIT-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-CURRENT-STACK-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
println("VMSTATE-CURRENT-STACK-OFFSET %_" % [VMSTATE-CURRENT-STACK-OFFSET])
val VMSTATE-SYSTEM-STACK-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-SYSTEM-REGISTERS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-TRIE-TABLE-OFFSET = next(vmstate-offsets, SIZEOF-LONG)

val stack-frame-offsets = Counter(0)
val STACK-FRAME-RETURN-OFFSET = next(stack-frame-offsets, SIZEOF-LONG)
val STACK-FRAME-LIVENESS-MAP-OFFSET = next(stack-frame-offsets, SIZEOF-LONG)
val STACK-FRAME-SLOTS-OFFSET = next(stack-frame-offsets, SIZEOF-LONG)
val SIZEOF-STACK-FRAME = value(stack-frame-offsets)

val stack-offsets = Counter(0)
val STACK-SIZE-OFFSET = next(stack-offsets, SIZEOF-LONG)
val STACK-FRAMES-OFFSET = next(stack-offsets, SIZEOF-LONG)
val STACK-STACK-POINTER-OFFSET = next(stack-offsets, SIZEOF-LONG)
val STACK-PC-OFFSET = next(stack-offsets, SIZEOF-LONG)

val function-offsets = Counter(0)
val FUNCTION-NUM-SLOTS-OFFSET = next(function-offsets, SIZEOF-LONG)
val FUNCTION-CODE-OFFSET = next(function-offsets, SIZEOF-LONG)
val FUNCTION-SLOTS-OFFSET = next(function-offsets, SIZEOF-LONG)

println("FUNCTION-CODE-OFFSET %_" % [FUNCTION-CODE-OFFSET])

defn vmstate-reg (a:Assembler, dst:Gp, offset:Int) -> Gp :
  mov(a, dst, MemPtr(vmstate(), offset, SIZEOF-LONG))
  dst
defn vmstate-reg (a:Assembler, offset:Int) -> Gp :
  vmstate-reg(a, rax(), offset)

defn vmstate () :        r8()
defn registers () :      r9()
defn stack-pointer () :  r10()
defn stk () :            r11()
defn current-stack () :  r12()
defn functions () :      r13()
defn tmp1 () :           r14()
defn tmp2 () :           r15()
defn tmp1i () :          r14d()
defn tmp2i () :          r15d()
defn tmp1b () :          r14b()
defn tmp2b () :          r15b()
defn tmp3 () :           rdx()
defn tmp3i () :          edx()
defn tmp3b () :          dl()
defn etc-saved-registers () : [vmstate(), registers(), functions(), stack-pointer(), stk(), tmp1(), tmp2()]
defn low-saved-registers () : [rax(), rbx(), rcx(), rdx(), rsi(), rdi()]
defn all-saved-registers () : cat(low-saved-registers(), etc-saved-registers())

defn untag-stack (a:Assembler, dst:Gp, stk:Gp) -> Gp :
  lea(a, dst, MemPtr(stk, 8 - 1, SIZEOF-LONG))
  dst
defn untag-stack (a:Assembler, stk:Gp) -> Gp :
  untag-stack(a, tmp1(), stk)

val INT-TAG-BITS = 0
val REF-TAG-BITS = 1
val MARKER-TAG-BITS = 2
val BYTE-TAG-BITS = 3
val CHAR-TAG-BITS = 4
val FLOAT-TAG-BITS = 5

val SYSTEM-RETURN-STUB = -2

defn do-BOOLREF (a:Assembler, x:Gp) -> Gp :
  debug(a, "BOOLREF %d -> " x)
  shl(a, x, 3)
  add(a, x, MARKER-TAG-BITS)
  debug(a, "%llx\n" x)
  x

extern malloc: (long) -> ptr<?>
extern strcpy: (ptr<byte>, ptr<byte>) -> ptr<?>
extern printf: (ptr<byte>, ? ...) -> int

lostanza defn printf-format (s:ref<String>) -> ref<Long> :
  val n = length(s)
  val d = call-c malloc(n.value + 1)
  call-c strcpy(d, addr!(s.chars))
  return new Long{d as long}

lostanza defn printf-addr () -> ref<Long> :
  return new Long{addr!(printf) as long}

defn caller-save-registers (a:Assembler) :
  for reg in etc-saved-registers() do :
    push(a, reg)

defn caller-restore-registers (a:Assembler) :
  for reg in reverse $ to-list $ etc-saved-registers() do :
    pop(a, reg)

defn all-save-registers (a:Assembler) :
  for reg in all-saved-registers() do :
    push(a, reg)

defn all-restore-registers (a:Assembler) :
  for reg in reverse $ to-list $ all-saved-registers() do :
    pop(a, reg)

defn debug (a:Assembler, format:String, a0:Gp, a1:Gp) :
  all-save-registers(a)
  mov(a, rdi(), printf-format(format))
  mov(a, rsi(), a0)
  mov(a, rdx(), a1)
  mov(a, rax(), 0L)
  mov(a, tmp1(), printf-addr())
  call(a, tmp1())
  all-restore-registers(a)

defn debug (a:Assembler, format:String) : debug(a, format, rax(), rax())
defn debug (a:Assembler, format:String, a0:Gp) : debug(a, format, a0, rax())

extern dump_registers: () -> int

lostanza defn dump-registers (a:ref<Assembler>) -> ref<False> :
  caller-save-registers(a)
  mov(a, tmp1(), new Long{addr!(dump_registers) as long})
  call(a, tmp1())
  caller-restore-registers(a)
  return false

extern dump_memory_8: (ptr<long>, int) -> int

lostanza defn dump-memory-8-addr () -> ref<Long> :
  return new Long{addr!(dump_memory_8) as long}

extern dump_memory_32: (ptr<int>, int) -> int

lostanza defn dump-memory-32-addr () -> ref<Long> :
  return new Long{addr!(dump_memory_32) as long}

extern dump_memory_64: (ptr<long>, int) -> int

lostanza defn dump-memory-64-addr () -> ref<Long> :
  return new Long{addr!(dump_memory_64) as long}

lostanza defn dump-memory-x (a:ref<Assembler>, faddr:ref<Long>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  caller-save-registers(a)
  mov(a, rdi(), start)
  mov(a, rsi(), n)
  mov(a, rax(), new Long{0L})
  mov(a, tmp1(), faddr)
  call(a, tmp1())
  caller-restore-registers(a)
  return false

lostanza defn dump-memory-8 (a:ref<Assembler>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  return dump-memory-x(a, dump-memory-8-addr(), start, n)

lostanza defn dump-memory-32 (a:ref<Assembler>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  return dump-memory-x(a, dump-memory-32-addr(), start, n)

lostanza defn dump-memory-64 (a:ref<Assembler>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  return dump-memory-x(a, dump-memory-64-addr(), start, n)

public defn make-jit-launch (rt:JitRuntime, vms:Long, init-id:Int) -> Func :
  val code = code-holder-new(rt)
  val a = assembler-new(code)
  ; SEGFAULT
  ; mov(a, rax(), 0L)
  ; mov(a, rax(), MemPtr(rax(), 0, 0))
  ; Setup JIT registers
  mov(a, tmp1(), c-params()[0])
  push(a, tmp1()) ;PUSHING RSP
  debug(a, "JIT CRSP TMP1 %llx\n" tmp1())
  mov(a, tmp1(), MemPtr(rsp(), 0, SIZEOF-LONG))
  debug(a, "JIT CRSP SP[0] %llx\n" tmp1())
  mov(a, vmstate(), vms)
  debug(a, "JIT VMSTATE %llx\n" vmstate())
  vmstate-reg(a, registers(), VMSTATE-REGISTERS-OFFSET)
  vmstate-reg(a, functions(), VMSTATE-FUNCTIONS-OFFSET)
  vmstate-reg(a, current-stack(), VMSTATE-CURRENT-STACK-OFFSET)
  debug(a, "JIT CURRENT-STACK %llx\n" current-stack())
  untag-stack(a, stk(), current-stack())
  debug(a, "JIT STK %llx\n" stk())
  ; dump-memory-64(a, stk(), 4L)
  println("STACK-STACK-POINTER-OFFSET %_" % [STACK-STACK-POINTER-OFFSET])
  mov(a, stack-pointer(), MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG))
  debug(a, "JIT STACK-POINTER %llx\n" stack-pointer())
  debug(a, "REGISTERS:\n")
  dump-memory-64(a, vmstate-reg(a, VMSTATE-REGISTERS-OFFSET), 4L)
  debug(a, "CONST-TABLE:\n")
  dump-memory-64(a, vmstate-reg(a, VMSTATE-CONST-TABLE-OFFSET), 16L)

  val ret-label = new-label(a)
  lea(a, tmp2(), MemPtr(ret-label, 0, SIZEOF-LONG))
  debug(a, "RET-LABEL %llx\n" tmp2())
  mov(a, MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG), tmp2())
  ; call init
  println("INIT-ID %_" % [init-id])
  mov(a, rax(), MemPtr(functions(), init-id * SIZEOF-LONG, SIZEOF-LONG))
  jmp(a, rax())
  bind(a, ret-label)
  debug(a, "RET-LABEL\n")
  pop(a, tmp1()) ;POPPING CRSP
  ret(a)
  add(rt, code)
  ; TODO: CLEANUP

defn CONST (a:Assembler, x:Gp, id:Int|Long) -> Gp : (mov(a, x, to-long(id)), x)
defn SET-REG (a:Assembler, r:Int, v:Gp) :
  mov(a, MemPtr(registers(), r * SIZEOF-LONG, SIZEOF-LONG), v)

defn dump-stack-frame (a:Assembler, sp:Gp) :
  debug(a, "STACK-FRAME:\n")
  dump-memory-64(a, sp, 3L)

defn dump-state (a:Assembler, msg:String) :
  debug(a, msg)
  dump-memory-64(a, vmstate(), 17L)
  debug(a, "REGISTERS:     %llx\n", registers())
  debug(a, "CURRENT-STACK: %llx\n", current-stack())
  debug(a, "STK:           %llx\n", stk())
  debug(a, "STACK-POINTER: %llx\n", stack-pointer())
  dump-memory-64(a, stack-pointer(), 6L)

public defn make-extend-stack-launch (rt:JitRuntime, stack-overflow-return:Func) -> Func :
  val size-required = rdx()
  val code = code-holder-new(rt)
  val a = assembler-new(code)
  val end-label = new-label(a)
  debug(a, "EXTEND-STACK %llx\n", size-required)
  ; dump-state(a, "STATE BEFORE:\n")
  ; mov(a, tmp2(), stack-pointer()) ; SAVE SP
  ;Save current stack
  mov(a, MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG), stack-pointer())
  ; lea(a, tmp1(), MemPtr(end-label, 0, SIZEOF-LONG))
  ;Swap stack and registers
  ; mov(a, MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG), tmp1())
  mov(a, MemPtr(vmstate(), VMSTATE-CURRENT-STACK-OFFSET, SIZEOF-LONG), vmstate-reg(a, VMSTATE-SYSTEM-STACK-OFFSET))
  mov(a, MemPtr(vmstate(), VMSTATE-SYSTEM-STACK-OFFSET, SIZEOF-LONG), current-stack())
  mov(a, MemPtr(vmstate(), VMSTATE-REGISTERS-OFFSET, SIZEOF-LONG), vmstate-reg(a, VMSTATE-SYSTEM-REGISTERS-OFFSET))
  mov(a, MemPtr(vmstate(), VMSTATE-SYSTEM-REGISTERS-OFFSET, SIZEOF-LONG), registers())
  ;Restore stack state
  mov(a, current-stack(), vmstate-reg(a, VMSTATE-CURRENT-STACK-OFFSET))
  untag-stack(a, stk(), current-stack())
  mov(a, stack-pointer(), MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG))
  mov(a, registers(), MemPtr(vmstate(), VMSTATE-REGISTERS-OFFSET, SIZEOF-LONG))
  ;Set arguments
  ; dump-stack-frame(a, tmp2())
  SET-REG(a, 0, do-BOOLREF(a, CONST(a, tmp1(), 0)))
  SET-REG(a, 1, CONST(a, tmp1(), 1))
  SET-REG(a, 1, size-required)
  ; dump-stack-frame(a, tmp2())
  mov(a, stack-pointer(), MemPtr(stk(), STACK-FRAMES-OFFSET, SIZEOF-LONG))
  mov(a, MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG), CONST(a, tmp1(), value(stack-overflow-return)))
  ; dump-stack-frame(a, tmp2())
  ; dump-state(a, "STATE AFTER:\n")
  mov(a, tmp2(), MemPtr(functions(), SIZEOF-LONG * EXTEND-STACK-FN, SIZEOF-LONG))
  jmp(a, tmp2())
  ; ;TEST INVERSE
  ; mov(a, tmp2(), value(stack-overflow-return))
  ; jmp(a, tmp2())
  bind(a, end-label)
  add(rt, code)

public defn make-extend-stack-return (rt:JitRuntime) -> Func :
  val code = code-holder-new(rt)
  val a = assembler-new(code)
  ;System stack no longer needed
  debug(a, "EXTEND-STACK-RETURN\n")
  ; dump-state(a, "STATE BEFORE:\n")
  mov(a, MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG), CONST(a, tmp1(), 0))
  debug(a, "SWAP-STACK-AND-REGISTERS\n")
  ;Swap stack and registers
  mov(a, MemPtr(vmstate(), VMSTATE-CURRENT-STACK-OFFSET, SIZEOF-LONG), vmstate-reg(a, VMSTATE-SYSTEM-STACK-OFFSET))
  mov(a, MemPtr(vmstate(), VMSTATE-SYSTEM-STACK-OFFSET, SIZEOF-LONG), current-stack())
  mov(a, MemPtr(vmstate(), VMSTATE-REGISTERS-OFFSET, SIZEOF-LONG), vmstate-reg(a, VMSTATE-SYSTEM-REGISTERS-OFFSET))
  mov(a, MemPtr(vmstate(), VMSTATE-SYSTEM-REGISTERS-OFFSET, SIZEOF-LONG), registers())
  debug(a, "RESTORE-STACK-STATE\n")
  ;Restore stack state
  mov(a, current-stack(), MemPtr(vmstate(), VMSTATE-CURRENT-STACK-OFFSET, SIZEOF-LONG))
  untag-stack(a, stk(), current-stack())
  mov(a, stack-pointer(), MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG))
  mov(a, registers(), MemPtr(vmstate(), VMSTATE-REGISTERS-OFFSET, SIZEOF-LONG))
  ; dump-state(a, "STATE AFTER:\n")
  ;Continue where we were
  mov(a, tmp1(), MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG))
  debug(a, "CONTINUE-WHERE-WE-WERE %llx\n" tmp1())
  jmp(a, tmp1())
  add(rt, code)

defn compute-stack-limit (a:Assembler) -> Gp :
  mov(a, rax(), MemPtr(stk(), STACK-FRAMES-OFFSET, SIZEOF-LONG))
  mov(a, tmp1(), MemPtr(stk(), STACK-SIZE-OFFSET, SIZEOF-LONG))
  add(a, rax(), tmp1())
  rax()

public defn encode (fid:Int, func:VMFunction,
                    rt:JitRuntime,
                    resolver:EncodingResolver,
                    extend-stack-launch:Func,
                    extend-stack-return:Func,
                    backend:Backend) -> EncodedFunction :
  val extend-stack-launch-value = value(extend-stack-launch)
  val code = code-holder-new(rt)
  val a = assembler-new(code)
    
  defn CONST (x:Gp, id:Int|Long) -> Gp : (mov(a, x, to-long(id)), x)
  defn CONST (id:Int|Long) -> Gp : CONST(tmp1(), id)
  defn BOOLREF (x:Gp) -> Gp : do-BOOLREF(a, x)

  debug(a, "--- ENTERING FUNC %d\n" CONST(fid))

  defn stack-limit () :    compute-stack-limit(a)
  defn heap-top () :       vmstate-reg(a, VMSTATE-HEAP-TOP-OFFSET)
  defn heap-limit () :     vmstate-reg(a, VMSTATE-HEAP-LIMIT-OFFSET)
  defn global-offsets () : vmstate-reg(a, VMSTATE-GLOBAL-OFFSETS-OFFSET)
  defn global-mem () :     vmstate-reg(a, VMSTATE-GLOBAL-MEM-OFFSET)
  defn data-offsets () :   vmstate-reg(a, VMSTATE-DATA-OFFSETS-OFFSET)
  defn data-mem () :       vmstate-reg(a, VMSTATE-DATA-MEM-OFFSET)
  defn const-table () :    vmstate-reg(a, VMSTATE-CONST-TABLE-OFFSET)
  defn const-mem () :      vmstate-reg(a, VMSTATE-CONST-MEM-OFFSET)

  ;Encode instructions into this byte buffer
  ;TODO: REMOVE
  val buffer = ByteBuffer()
  defn buffer-pos () : write-position(buffer) / 4

  ;Accumulate file information entries for implementing
  ;stack traces.
  val fileinfo-table = Vector<FileInfoEntry>()
  defn record-info (info:FileInfo|False) :
    match(info:FileInfo) :
      add(fileinfo-table, FileInfoEntry(buffer-pos(), info))

  ;Calculation of sizes
  defn object-size (num-obj:Int, size-on-heap:Int) :
    num-obj * object-header-size(resolver) + size-on-heap
  defn stack-size () :
    object-size(1, /stack-size(resolver))

  ;Split a tuple of VMBranch into typesets and destinations
  defn split-types-and-dests (bs:Tuple<VMBranch>) -> [Tuple<Tuple<TypeSet>>, Tuple<Int>] :
    val types = map(types, bs)
    val targets = map(n, bs)
    [types, targets]

  ;Check whether type is final.
  ;If the function returns true, it means that the type cannot be redefined.
  defn type-is-final? (t:TypeSet) :
    match(t) :
      (t:SingleType) : /type-is-final?(resolver, type(t))
      (t:OrType) : all?(type-is-final?, types(t))
      (t:AndType) : any?(type-is-final?, types(t))
      (t:TopType) : true

  ;Check whether all types in branch are final.
  defn branch-is-final? (b:VMBranch) :
    all?(type-is-final?, types(b))

  defn stack-frame-slots (dst:Gp) -> Gp :
    lea(a, dst, MemPtr(stack-pointer(), STACK-FRAME-SLOTS-OFFSET, SIZEOF-LONG))
    dst
  defn GET-CRSP (dst:Gp) -> Gp :
    mov(a, dst, MemPtr(rsp(), 0, SIZEOF-LONG))
    dst
  defn GET-REG (dst:Gp, r:Int) :
    mov(a, dst, MemPtr(registers(), CONST(rbx(), r), 3, 0, SIZEOF-LONG))
    dst
  defn SET-REG (r:Int, v:Gp) :
    mov(a, MemPtr(registers(), CONST(rbx(), r), 3, 0, SIZEOF-LONG), v)
    debug(a, "SET-REG %d %llx\n", CONST(rbx(), r), v)
    ; dump-memory-64(a, registers(), 5L)
    ; registers[r] = v
    false
  defn SET-LOCAL (l:Int, v:Gp) :
    ; debug(a, "SET-LOCAL SLOTS %llx\n" stack-frame-slots())
    mov(a, MemPtr(stack-frame-slots(rbx()), CONST(rsi(), l), 3, 0, SIZEOF-LONG), v)
    debug(a, "SET-LOCAL[%d] %llx\n", CONST(rbx(), l), v)
    ; stack_pointer->slots[l] = v;
    false
  defn SET-LOCAL-INT (l:Int, v:Gp) :
    ;COULD MERGE ABOVE WITH THIS
    movsx(a, v, v)
    SET-LOCAL(l, v)
  defn SET-LOCAL-FLOAT (l:Int,v:Xmm) :
    ; mov(a, tmp1(), v)
    ; debug(a, "SET-LOCAL-FLOAT %llx\n", tmp1())
    ; mov(a, MemPtr(stack-frame-slots(rbx()), l * SIZEOF-LONG, SIZEOF-LONG), tmp1())
    ; movss(a, MemPtr(stack-frame-slots(rbx()), l * SIZEOF-LONG, SIZEOF-LONG), v)
    movsd(a, MemPtr(stack-frame-slots(rbx()), CONST(rsi(), l), 3, 0, SIZEOF-LONG), v)
    debug(a, "SET-LOCAL-FLOAT[%d] %llx\n", CONST(rbx(), l), LOCAL(tmp1(), l))
    ; float* addr = (float*)&(stack_pointer->slots[l])
    ; *addr = v
    false
  defn SET-LOCAL-DOUBLE (l:Int, v:Xmm) :
    ; mov(a, tmp1(), v)
    ; debug(a, "SET-LOCAL-DOUBLE %llx\n", tmp1())
    ; mov(a, MemPtr(stack-frame-slots(rbx()), l * SIZEOF-LONG, SIZEOF-LONG), tmp1())
    movsd(a, MemPtr(stack-frame-slots(rbx()), CONST(rsi(), l), 3, 0, SIZEOF-LONG), v)
    ; double* addr = (double*)&(stack_pointer->slots[l])
    ; *addr = v
    false

  defn LOCAL (dst:Gp, l:Int) -> Gp :
    mov(a, dst, MemPtr(stack-frame-slots(rbx()), CONST(rsi(), l), 3, 0, SIZEOF-LONG)) 
    dst
  defn LOCAL (l:Int) -> Gp : LOCAL(rax(), l)
   ; stack_pointer->slots[l]
  defn LOCAL-FLOAT (dst:Xmm, l:Int) -> Xmm :
    movss(a, dst, MemPtr(stack-frame-slots(rbx()), CONST(rsi(), l), 3, 0, SIZEOF-INT))
    ; mov(a, tmp1(), MemPtr(stack-frame-slots(rbx()), l * SIZEOF-LONG, SIZEOF-LONG))
    ; debug(a, "LOCAL-FLOAT %llx\n" tmp1())
    ; mov(a, dst, tmp1()) 
    ; mov(a, tmp2(), dst) 
    ; debug(a, "LOCAL-FLOAT TMP2 %llx\n" tmp2())
    dst
    ; TODO: float register
    ; float* addr = (float*)&(stack_pointer->slots[l])
    ; *addr
  defn LOCAL-FLOAT (l:Int) -> Xmm :
    LOCAL-FLOAT(xmm0(), l)
  defn LOCAL-DOUBLE (dst:Xmm, l:Int) -> Xmm :
    movsd(a, dst, MemPtr(stack-frame-slots(rbx()), CONST(rsi(), l), 3, 0, SIZEOF-INT))
    ; mov(a, tmp1(), MemPtr(stack-frame-slots(rbx()), l * SIZEOF-LONG, SIZEOF-LONG))
    ; mov(a, dst, tmp1()) 
    dst
    ; TODO: double register
    ; double* addr = (double*)&(stack_pointer->slots[l])
    ; *addr
  defn LOCAL-DOUBLE (l:Int) -> Xmm :
    ; TODO: double register
    LOCAL-DOUBLE(xmm0(), l)

  defn PUSH-FRAME (num-locals:Int, ret-addr:Label) :
    add(a, stack-pointer(), SIZEOF-STACK-FRAME + num-locals * SIZEOF-LONG)
    lea(a, tmp1(), MemPtr(ret-addr, 0, SIZEOF-LONG))
    debug(a, "PUSH-FRAME RET %llx\n" tmp1())
    mov(a, MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG), tmp1())
    ; stack_pointer = (StackFrame*)((char*)stack_pointer + sizeof(StackFrame) + (num_locals) * SIZEOF-LONG)
    ; stack_pointer->returnpc = (uint64_t)(pc - instructions)
    false

  defn POP-FRAME (num-locals:Int) :
    add(a, stack-pointer(), -1 * (SIZEOF-STACK-FRAME + num-locals * SIZEOF-LONG))
    ; stack_pointer = (StackFrame*)((char*)stack_pointer - sizeof(StackFrame) - (num_locals) * SIZEOF-LONG)
    false

  defn SAVE-STATE () :
    mov(a, MemPtr(vmstate(), VMSTATE-HEAP-TOP-OFFSET, SIZEOF-LONG), heap-top())
    mov(a, MemPtr(vmstate(), VMSTATE-CURRENT-STACK-OFFSET, SIZEOF-LONG), current-stack())
    mov(a, MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG), stack-pointer())
    caller-save-registers(a)
    ; vms->heap_top = heap_top
    ; vms->current_stack = current_stack
    ; stk->stack_pointer = stack_pointer
    false

  defn RESTORE-STATE () :
    mov(a, heap-top(), MemPtr(vmstate(), VMSTATE-HEAP-TOP-OFFSET, SIZEOF-LONG))
    mov(a, heap-limit(), MemPtr(vmstate(), VMSTATE-HEAP-LIMIT-OFFSET, SIZEOF-LONG))
    mov(a, current-stack(), MemPtr(vmstate(), VMSTATE-CURRENT-STACK-OFFSET, SIZEOF-LONG))
    untag-stack(a, stk(), current-stack())
    mov(a, stack-pointer(), MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG))
    ; mov(a, stack-limit(a), compute-stack-limit(a))
    caller-restore-registers(a)
    ; heap_top = vms->heap_top
    ; heap_limit = vms->heap_limit
    ; current_stack = vms->current_stack
    ; stk = untag_stack(current_stack)
    ; stack_pointer = stk->stack_pointer
    ; stack_limit = (char*)(stk->frames) + stk->size
    false

  defn c-call (fptr:Long) :
    push(a, r10())
    push(a, r11())
    mov(a, rax(), fptr)
    call(a, rax())
    pop(a, r11())
    pop(a, r10())
    
  defn do-tcall (f:Gp) :
    debug(a, "CALLING %d\n", f)
    mov(a, tmp2(), MemPtr(functions(), f, 3, 0, SIZEOF-LONG))
    debug(a, "CALLING %d %llx\n", f, tmp2())
    jmp(a, tmp2())

  defn do-call (f:Gp, num-locals:Int) :
    val end-label = new-label(a)
    PUSH-FRAME(num-locals, end-label)
    do-tcall(f)
    bind(a, end-label)

  defn emit-ins-a (opcode:Int, value:Label) :
    switch(opcode) :
      GOTO-OPCODE : 
        println("A GOTO")
        debug(a, "GOTO\n")
        jmp(a, value as Label)

  defn emit-ins-a (opcode:Int, value:Int) :
    switch(opcode) :
      FNENTRY-OPCODE : ;YYY
        println("A FNENTRY")
        ; dump-state(a, "FNENTRY:\n")
        val all-good-label = new-label(a)
        val frame-size = value * SIZEOF-LONG + SIZEOF-STACK-FRAME
        val size-required = frame-size + SIZEOF-STACK-FRAME
        ;Size-required must be in rax to line up for extend-stack-launch
        add(a, CONST(tmp3(), size-required), stack-pointer())
        debug(a, "STACK CHECK %llx %llx\n", tmp3(), stack-limit())
        cmp(a, tmp3(), stack-limit())
        jle(a, all-good-label)
        CONST(tmp3(), size-required)
        debug(a, "STACK-OVERFLOW %llx\n", tmp3())
        PUSH-FRAME(0, all-good-label)
        jmp(a, CONST(tmp1(), extend-stack-launch-value))
        bind(a, all-good-label)
        false
      DISPATCH-OPCODE :
        println("A DISPATCH")
        val tgts = new-label(a)
        val idx = read-dispatch-table(a, vmstate(), CONST(tmp1(), value as Int))
        mov(a, tmp1(), idx)
        lea(a, tmp2(), MemPtr(tgts, 0, SIZEOF-LONG))
        ; debug(a, "TGTS %llx\n", tmp2())
        ; dump-memory-64(a, tmp2(), 4L)
        mov(a, tmp2(), MemPtr(tmp2(), tmp1(), 3, 0, SIZEOF-LONG))
        debug(a, "DISPATCH %lld %llx\n", tmp1(), tmp2())
        jmp(a, tmp2())
        bind(a, tgts)
      TCALL-CLOSURE-OPCODE : ;YYY
        println("A TCALL-CLOSURE")
        debug(a, "TCALL-CLOSURE\n")
        LOCAL(tmp1(), value as Int)
        mov(a, rbx(), MemPtr(tmp1(), FUNCTION-CODE-OFFSET + SIZEOF-LONG - REF-TAG-BITS, SIZEOF-LONG))
        debug(a, "TCODE %llx\n", rbx())
        do-tcall(rbx())
      POP-FRAME-OPCODE : ;YYY
        println("A POP-FRAME")
        val num-locals = value as Int
        POP-FRAME(num-locals)
      ENTER-STACK-OPCODE : ;YYY
        println("A ENTER-STACK")
        ;Save current stack
        mov(a, MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG), stack-pointer())
        ;Load next stack
        mov(a, current-stack(), LOCAL(tmp1(), value as Int))
        untag-stack(a, stk(), current-stack())
        mov(a, stack-pointer(), MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG))
        ;Load starting address
        mov(a, tmp1(), MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG))
        jmp(a, tmp1())
      YIELD-OPCODE : ;YYY
        println("A YIELD")
        val continue-label = new-label(a)
        ;Save current stack
        mov(a, MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG), stack-pointer())
        lea(a, tmp2(), MemPtr(continue-label, 0, SIZEOF-LONG))
        mov(a, MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG), tmp2())
        ;Load next stack
        mov(a, current-stack(), LOCAL(tmp1(), value as Int))
        untag-stack(a, stk(), current-stack())
        mov(a, stack-pointer(), MemPtr(stk(), STACK-STACK-POINTER-OFFSET, SIZEOF-LONG))
        ;Load starting address
        mov(a, tmp1(), MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG))
        jmp(a, tmp1())
        bind(a, continue-label)
      RETURN-OPCODE : 
        println("A RETURN")
        mov(a, tmp1(), MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG))
        debug(a, "RETURNING TO %llx\n", tmp1())
        jmp(a, tmp1())
        ; int64_t retpc = stack_pointer->returnpc;
        ; pc = instructions + retpc;
        false
      DUMP-OPCODE : ;YYY
        println("A DUMP XXX")
      LIVE-OPCODE : ;YYY
        println("A LIVE")
        mov(a, tmp2(), to-long(value as Int))
        mov(a, MemPtr(stack-pointer(), STACK-FRAME-LIVENESS-MAP-OFFSET, SIZEOF-LONG), tmp2())
        ; stack_pointer->liveness_map = value;
      DISPATCH-METHOD-OPCODE :
        println("A DISPATCH-METHOD")
        val code-label = new-label(a)
        val tgts = new-label(a)
        read-dispatch-table(a, vmstate(), CONST(tmp1(), value as Int))
        cmp(a, rax(), CONST(tmp1(), 2)) ; < 2 are targets and >= 2 are methods to goto
        jge(a, code-label)
        mov(a, tmp2(), MemPtr(tgts, 0, SIZEOF-LONG))
        mov(a, tmp2(), MemPtr(tmp2(), rax(), 3, 0, SIZEOF-LONG))
        debug(a, "DISPATCH %lld %llx\n", tmp1(), tmp2())
        jmp(a, tmp2())
        bind(a, code-label)
        mov(a, tmp2(), MemPtr(functions(), rax(), 3, -2 * SIZEOF-LONG, SIZEOF-LONG))
        debug(a, "DISPATCH METHOD %lld %llx\n", rax(), tmp2())
        jmp(a, tmp2())
      FLUSH-VM-OPCODE : ;YYY
        println("A FLUSH-VM")
        SAVE-STATE()
        SET-LOCAL(value as Int, vmstate())
      C-RSP-OPCODE : ;YYY
        println("A C-RSP")
        SAVE-STATE()
        SET-LOCAL(value, GET-CRSP(tmp1()))
      else :
        println("MISSING A OPCODE %_" % [opcode])

  defn TAG (dst:Gp, x:Gp, tag:Int) -> Gp:
    ;MIGHT BE ABLE TO DO THIS WITH ADDRESSING MODE
    mov(a, dst, x)
    shl(a, dst, 32)
    add(a, dst, tag)
    dst
    
  defn DETAG (dst:Gp, x:Gp) -> Gp:
    mov(a, dst, x)
    shr(a, dst, 32)
    dst

  defn ptr-to-ref (dst:Gp, p:Gp) -> Gp :
    lea(a, dst, MemPtr(p, REF-TAG-BITS, SIZEOF-LONG))
    dst

  defn emit-ins-b (opcode:Int, x:Int, value:Int) :
    switch(opcode) :
      INT-NOT-OPCODE : ;YYY
        println("B INT-NOT")
        not-op(a, LOCAL(tmp1(), value))
        shr(a, tmp1(), 32)
        shl(a, tmp1(), 32)
        SET-LOCAL(x, tmp1())
      INT-NEG-OPCODE :  ;YYY
        println("B INT-NEG")
        neg(a, LOCAL(tmp1(), value))
        SET-LOCAL(x, tmp1())
      NOT-OPCODE-BYTE : ;YYY
        println("B NOT-BYTE")
        not-op(a, LOCAL(tmp1b(), value))
        SET-LOCAL(x, tmp1b())
      NOT-OPCODE-INT : ;YYY
        println("B NOT-INT")
        not-op(a, LOCAL(tmp1i(), value))
        SET-LOCAL(x, tmp1i())
      NOT-OPCODE-LONG : ;YYY
        println("B NOT-LONG")
        not-op(a, LOCAL(rax(), value))
        SET-LOCAL(x, rax())
      NEG-OPCODE-INT : ;YYY
        println("B NEG-INT")
        neg(a, LOCAL(tmp1i(), value))
        SET-LOCAL-INT(x, tmp1())
      NEG-OPCODE-LONG : ;YYY
        println("B NEG-LONG")
        neg(a, LOCAL(rax(), value))
        SET-LOCAL(x, rax())
      NEG-OPCODE-FLOAT : ;YYY
        println("B NEG-FLOAT")
        xor-op(a, tmp1(), tmp1())
        cvtsi2ss(a, xmm0(), tmp1())
        subss(a, xmm0(), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      NEG-OPCODE-DOUBLE : ;YYY
        println("B NEG-DOUBLE")
        xor-op(a, tmp1(), tmp1())
        cvtsi2sd(a, xmm0(), tmp1())
        subsd(a, xmm0(), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      CONV-OPCODE-BYTE-FLOAT : ;YYY
        println("B CONV-BYTE-FLOAT")
        cvtss2si(a, tmp1b(), LOCAL-FLOAT(xmm0(), value))
        SET-LOCAL(x, tmp1b())
      CONV-OPCODE-BYTE-DOUBLE : ;YYY
        println("B CONV-BYTE-DOUBLE")
        cvtsd2si(a, tmp1(), LOCAL-DOUBLE(xmm0(), value))
        and-op(a, tmp1(), 0xff)
        SET-LOCAL(x, tmp1())
      CONV-OPCODE-INT-BYTE : ;YYY
        println("B CONV-INT-BYTE")
        xor-op(a, tmp1(), tmp1())
        mov(a, tmp1i(), LOCAL(tmp1b(), value))
        SET-LOCAL(x, tmp1())
      CONV-OPCODE-INT-FLOAT : ;YYY
        println("B CONV-INT-FLOAT")
        cvtss2si(a, tmp1i(), LOCAL-FLOAT(xmm0(), value))
        SET-LOCAL(x, tmp1i())
      CONV-OPCODE-INT-DOUBLE : ;YYY
        println("B CONV-INT-DOUBLE")
        cvtsd2si(a, tmp1i(), LOCAL-DOUBLE(xmm0(), value))
        SET-LOCAL(x, tmp1i())
      CONV-OPCODE-LONG-BYTE : ;YYY
        println("B CONV-LONG-BYTE")
        and-op(a, LOCAL(tmp1(), value), 0xff)
        SET-LOCAL(x, tmp1())
        debug(a, "CONV-LONG-BYTE %llx %llx\n", tmp1(), LOCAL(tmp2(), x))
      CONV-OPCODE-LONG-INT : ;YYY
        println("B CONV-LONG-INT X %_ VALUE %_" % [x, value])
        movsx(a, rax(), LOCAL(tmp1i(), value))
        SET-LOCAL(x, rax())
        debug(a, "CONV-LONG-INT %llx %llx\n" tmp1(), rax())
      CONV-OPCODE-LONG-FLOAT : ;YYY
        println("B CONV-LONG-FLOAT")
        cvtss2si(a, rax(), LOCAL-FLOAT(xmm0(), value))
        SET-LOCAL(x, rax())
      CONV-OPCODE-LONG-DOUBLE : ;YYY
        println("B CONV-LONG-DOUBLE")
        cvtsd2si(a, rax(), LOCAL-DOUBLE(xmm0(), value))
        SET-LOCAL(x, rax())
      CONV-OPCODE-FLOAT-BYTE : ;YYY
        println("B CONV-FLOAT-BYTE")
        cvtsi2ss(a, xmm0(), LOCAL(tmp1b(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      CONV-OPCODE-FLOAT-INT : ;YYY
        println("B CONV-FLOAT-INT")
        cvtsi2ss(a, xmm0(), LOCAL(tmp1i(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      CONV-OPCODE-FLOAT-LONG : ;YYY
        println("B CONV-FLOAT-LONG")
        cvtsi2ss(a, xmm0(), LOCAL(rax(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      CONV-OPCODE-FLOAT-DOUBLE : ;YYY
        println("B CONV-FLOAT-DOUBLE")
        cvtsd2ss(a, xmm1(), LOCAL-DOUBLE(xmm0(), value))
        SET-LOCAL-FLOAT(x, xmm1())
      CONV-OPCODE-DOUBLE-BYTE : ;YYY
        println("B CONV-DOUBLE-BYTE")
        cvtsi2sd(a, xmm0(), LOCAL(tmp1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
        debug(a, "CONV-DOUBLE-BYTE %llx %llx\n" LOCAL(tmp1(), value), LOCAL(tmp2(), x))
      CONV-OPCODE-DOUBLE-INT : ;YYY
        println("B CONV-DOUBLE-INT")
        cvtsi2sd(a, xmm0(), LOCAL(tmp1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      CONV-OPCODE-DOUBLE-LONG : ;YYY
        println("B CONV-DOUBLE-LONG")
        cvtsi2sd(a, xmm0(), LOCAL(rax(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      CONV-OPCODE-DOUBLE-FLOAT : ;YYY
        println("B CONV-DOUBLE-FLOAT")
        debug(a, "CONV-DOUBLE-FLOAT %llx\n", LOCAL(tmp1(), value))
        cvtss2sd(a, xmm1(), LOCAL-FLOAT(xmm0(), value))
        SET-LOCAL-DOUBLE(x, xmm1())
      TAG-OPCODE-BYTE : ;YYY
        println("B TAG-BYTE")
        debug(a, "TAG-BYTE\n")
        TAG(tmp2(), LOCAL(tmp1(), value), BYTE-TAG-BITS)
        SET-LOCAL(x, tmp2())
      TAG-OPCODE-CHAR : ;YYY
        println("B TAG-CHAR")
        debug(a, "TAG-CHAR\n")
        TAG(tmp2(), LOCAL(tmp1(), value), CHAR-TAG-BITS)
        SET-LOCAL(x, tmp2())
      TAG-OPCODE-INT :
        println("B TAG-INT X %_ VALUE %_" % [x, value])
        TAG(tmp2(), LOCAL(tmp1(), value), INT-TAG-BITS)
        debug(a, "TAG-INT %llx %llx\n" tmp1() tmp2())
        SET-LOCAL(x, tmp2())
      TAG-OPCODE-FLOAT : ;YYY
        println("B TAG-FLOAT")
        debug(a, "TAG-FLOAT %llx\n" LOCAL(tmp1(), value))
        TAG(tmp2(), LOCAL(tmp1(), value), FLOAT-TAG-BITS)
        SET-LOCAL(x, tmp2())
      DETAG-OPCODE : ;YYY
        println("B DETAG X %_ VALUE %_" % [x, value])
        DETAG(tmp2(), LOCAL(tmp1(), value))
        debug(a, "DETAG %llx\n" tmp2())
        SET-LOCAL(x, tmp2())
      DEREF-OPCODE : ;YYY
        println("B DEREF")
        LOCAL(tmp2(), value)
        add(a, tmp2(), 8 - REF-TAG-BITS)
        SET-LOCAL(x, tmp2())
      GC-OPCODE : ;YYY
        println("B GC")
        LOCAL(tmp1(), value)
        SAVE-STATE()
        call-garbage-collector(a, vmstate(), tmp1())
        RESTORE-STATE()
        SET-LOCAL(x, rax())
      CLASS-NAME-OPCODE : ;YYY
        println("B CLASS-NAME")
        SET-LOCAL(x, retrieve-class-name(a, vmstate(), LOCAL(tmp1(), value)))
      PRINT-STACK-TRACE-OPCODE : ;YYY
        println("B PRINT-STACK-TRACE")
        SET-LOCAL(x, call-print-stack-trace(a, vmstate(), LOCAL(tmp1(), value)))
      GET-REG-OPCODE : ;YYY
        println("B GET-REG %_ %_" % [x value])
        debug(a, "GET-REG %d %llx\n" CONST(tmp2(), value) GET-REG(tmp1(), value))
        SET-LOCAL(x, GET-REG(tmp1(), value))
      else :
        println("MISSING B OPCODE %_" % [opcode])

  defn emit-ins-c (opcode:Int, x:Int, value:Int) :
    switch(opcode) :
      TCALL-OPCODE-LOCAL : ;YYY
        println("C TCALL-LOCAL")
        debug(a, "TCALL-LOCAL: ")
        do-tcall(LOCAL(rbx(), value))
      TCALL-OPCODE-CODE : ;YYY
        println("C TCALL-CODE")
        debug(a, "TCALL-LOCAL: ")
        do-tcall(CONST(rbx(), value))
      CALL-OPCODE-LOCAL : ;YYY
        println("C CALL-LOCAL %_" % [value])
        debug(a, "CALL-LOCAL\n")
        do-call(LOCAL(rbx(), value), x)
      CALL-OPCODE-CODE :
        println("C CALL-CODE %_" % [value])
        debug(a, "CALL-CODE\n")
        do-call(CONST(rbx(), value), x)
      CALL-CLOSURE-OPCODE : ;YYY
        println("C CALL-CLOSURE")
        LOCAL(tmp1(), value)
        mov(a, rdx(), MemPtr(tmp1(), FUNCTION-CODE-OFFSET + SIZEOF-LONG - REF-TAG-BITS, SIZEOF-LONG))
        debug(a, "CALL-CLOSURE %llx %llx\n", tmp1(), rdx())
        do-call(rdx(), x)
      CALLC-OPCODE-LOCAL : ;YYY
        println("C CALLC-LOCAL")
        val end-label = new-label(a)
        val num-locals = x
        PUSH-FRAME(num-locals, end-label)
        SAVE-STATE()
        val faddr = LOCAL(value)
        c-trampoline(a, faddr, registers(), registers())
        RESTORE-STATE()
        mov(a, tmp1(), MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG))
        jmp(a, tmp1())
        POP-FRAME(num-locals)
        bind(a, end-label)
      TYPEOF-OPCODE : ;YYY
        println("C TYPEOF")
        read-dispatch-table(a, vmstate(), CONST(tmp2(), value))
        SET-LOCAL(x, rax())
      SET-REG-OPCODE-LOCAL : ;YYY
        println("C SET-REG-LOCAL")
        debug(a, "SET-REG-LOCAL %d\n", CONST(x))
        SET-REG(x, LOCAL(value))
      SET-REG-OPCODE-UNSIGNED : ;YYY
        println("C SET-REG-UNSIGNED")
        mov(a, tmp1(), to-long(value))
        mov(a, tmp2(), to-long(x))
        debug(a, "SET-REG-UNSIGNED %llx %llx\n" tmp2() tmp1())
        mov(a, tmp1(), to-long(value))
        SET-REG(x, tmp1())
        ; debug(a, "REGISTERS:\n")
        ; dump-memory-64(a, registers(), 6L)
      SET-REG-OPCODE-WIDE : ;YYY
        println("C SET-REG-WIDE")
        SET-REG(x, CONST(tmp1(), value))
      SET-REG-OPCODE-CODE : ;YYY
        println("C SET-REG-CODE")
        SET-REG(x, CONST(tmp1(), value))
      SET-REG-OPCODE-GLOBAL : ;YYY
        println("C SET-REG-GLOBAL")
        mov(a, rbx(), MemPtr(global-offsets(), CONST(tmp1(), value), 3, 0, SIZEOF-LONG))
        lea(a, tmp1(), MemPtr(global-mem(), rbx(), 3, 0, SIZEOF-LONG))
        SET-REG(x, tmp1())
      SET-REG-OPCODE-DATA : ;YYY
        println("C SET-REG-DATA x=%_ value=%_" % [x, value])
        ; debug(a, "VMSTATE:\n")
        ; dump-memory-64(a, vmstate(), 17L)
        ; debug(a, "OFFSETS %llx\n", data-offsets())
        ; dump-memory-32(a, data-offsets(), 8L)
        mov(a, tmp2i(), MemPtr(data-offsets(), CONST(tmp1(), value), 2, 0, SIZEOF-INT)) ; data_offsets[value]
        lea(a, tmp1(), MemPtr(data-mem(), tmp2i(), 3, 0, SIZEOF-LONG))
        SET-REG(x, tmp1())
        debug(a, "SET-REG-DATA %x %llx\n" CONST(tmp2(), x) tmp1())
        ; debug(a, "REGISTERS:\n")
        ; dump-memory-64(a, registers(), 5L)
        ; debug(a, "DATA:\n")
        ; dump-memory-8(a, data-mem(), 64L)
      SET-REG-OPCODE-CONST : ;YYY
        println("C SET-REG-CONST X %_ VALUE %_" % [x, value])
        debug(a, "SET-REG-CONST %d\n", CONST(tmp3(), value))
        dump-memory-64(a, const-table(), 16L)
        mov(a, tmp1(), MemPtr(const-table(), CONST(tmp3(), value), 3, 0, SIZEOF-LONG))
        SET-REG(x, tmp1())
      SET-REG-OPCODE-UNSIGNED : ;YYY
        println("C SET-REG-UNSIGNED")
        ;TODO: CHECK
        mov(a, tmp1(), to-long(value))
        SET-REG(x, tmp1())
      SET-REG-OPCODE-SIGNED : ;YYY
        println("C SET-REG-UNSIGNED")
        ;TODO: CHECK
        mov(a, tmp1(), to-long(value))
        SET-REG(x, tmp1())
      SET-OPCODE-LOCAL : ;YYY
        println("C SET-LOCAL X %_ VALUE %_" % [x, value])
        SET-LOCAL(x, LOCAL(value))
      SET-OPCODE-UNSIGNED : ;YYY
        println("C SET-UNSIGNED X %_ VALUE 0x%_" % [x, hex(to-long(value))])
        mov(a, tmp1(), to-long(value))
        SET-LOCAL(x, tmp1())
      SET-OPCODE-WIDE : ;YYY
        println("C SET-WIDE X %_ VALUE %_" % [x, value])
        SET-LOCAL(x, CONST(tmp1(), value))
      SET-OPCODE-CODE : ;YYY
        println("C SET-CODE")
        SET-LOCAL(x, CONST(tmp1(), value))
      SET-OPCODE-GLOBAL : ;YYY
        println("C SET-GLOBAL")
        mov(a, rbx(), MemPtr(global-offsets(), CONST(tmp1(), value), 3, 0, SIZEOF-LONG))
        lea(a, tmp1(), MemPtr(global-mem(), rbx(), 3, 0, SIZEOF-LONG))
        SET-LOCAL(x, tmp1())
      SET-OPCODE-DATA : ;YYY
        println("C SET-DATA")
        mov(a, tmp2i(), MemPtr(data-offsets(), CONST(tmp1(), value), 2, 0, SIZEOF-INT)) ; data_offsets[value]
        lea(a, tmp1(), MemPtr(data-mem(), tmp2i(), 3, 0, SIZEOF-LONG))
        SET-LOCAL(x, tmp1())
      SET-OPCODE-CONST : ;YYY
        println("C SET-CONST")
        debug(a, "SET-CONST %d\n", CONST(tmp1(), value))
        mov(a, tmp2(), MemPtr(const-table(), CONST(tmp1(), value), 3, 0, SIZEOF-LONG))
        SET-LOCAL(x, tmp2())
      else :
        println("MISSING C OPCODE %_" % [opcode])

  defn emit-ins-c (opcode:Int, x:Label, y:Int, value:Int) :
    defn do-reserve (size:Gp, num-locals:Int) :
      debug(a, "RESERVE SIZE %llx LIMIT %llx\n", size, heap-limit())
      mov(a, tmp2(), heap-top())
      add(a, tmp2(), size)
      debug(a, "  CMP DESIRED %llx LIMIT %llx\n", tmp2(), heap-limit())
      cmp(a, tmp2(), heap-limit())
      jle(a, x)
      debug(a, "EXTENDING HEAP\n")
      SET-REG(0, BOOLREF(CONST(tmp1(), 0)))
      SET-REG(1, CONST(tmp1(), 1L))
      SET-REG(2, size)
      mov(a, tmp2(), MemPtr(functions(), SIZEOF-LONG * EXTEND-HEAP-FN, SIZEOF-LONG))
      val end-label = new-label(a)
      PUSH-FRAME(num-locals, end-label)
      jmp(a, tmp2())
      bind(a, end-label)
      debug(a, "RESERVED\n")
    switch(opcode) :
      RESERVE-OPCODE-LOCAL : ;YYY
        println("C RESERVE-LOCAL Y %_ VALUE %_" % [y, value])
        val size = tmp3()
        add(a, LOCAL(size, value), 8 + 7)
        debug(a, "RESERVE-LOCAL %llx\n", size)
        and-op(a, size, CONST(tmp2(), (- 8L)))
        debug(a, "RESERVE-LOCAL %llx\n", size)
        do-reserve(size, y)
      RESERVE-OPCODE-CONST : ;YYY
        println("C RESERVE-CONST Y %_ VALUE %_" % [y, value])
        do-reserve(CONST(rbx(), value), y)

  defn emit-ins-c (opcode:Int, x:Int, y:Int, value:Label) :
    switch(opcode) :
      JUMP-REG-OPCODE : ;YYY
        val reg = x
        val arity = y
        cmp(a, GET-REG(tmp1(), reg), CONST(tmp2(), arity))
        je(a, value as Label)
        println("C JUMP-REG")

  defn cmp-set (a:Assembler, x:Gp, y:Gp, z:Gp, zb:Gp, set:(Assembler, Gp) -> False) -> Gp :
    xor-op(a, z, z)
    cmp(a, x, y)
    set(a, zb)
    z

  defn cmpf-set (a:Assembler, x:Xmm, y:Xmm, z:Gp, zb:Gp, set:(Assembler, Gp) -> False) -> Gp :
    xor-op(a, z, z)
    ucomiss(a, x, y)
    set(a, zb)
    z

  defn cmpd-set (a:Assembler, x:Xmm, y:Xmm, z:Gp, zb:Gp, set:(Assembler, Gp) -> False) -> Gp :
    xor-op(a, z, z)
    ucomisd(a, x, y)
    set(a, zb)
    z

  defn emit-ins-c (opcode:Int, x:Int, y:Int, value:Int) :
    switch(opcode) :
      INT-ADD-OPCODE :
        println("C INT-ADD")
        add(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        debug(a, "INT-ADD %llx\n" tmp1())
        SET-LOCAL(x, tmp1())
      INT-SUB-OPCODE : ;YYY
        println("C INT-SUB")
        sub(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        debug(a, "INT-SUB %llx\n" tmp1())
        SET-LOCAL(x, tmp1())
      INT-MUL-OPCODE : ;YYY
        println("C INT-MUL")
        shr(a, LOCAL(tmp1(), y), 32)
        imul(a, tmp1(), LOCAL(tmp2(), value))
        debug(a, "INT-MUL %llx\n" tmp1())
        SET-LOCAL(x, tmp1())
      INT-DIV-OPCODE : ;YYY
        println("C INT-DIV")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y), 
        div(a, LOCAL(tmp2(), value))
        shl(a, rax(), 32)
        debug(a, "INT-DIV %llx\n" rax())
        SET-LOCAL(x, rax())
      INT-MOD-OPCODE : ;YYY
        println("C INT-MOD")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y), 
        div(a, LOCAL(tmp2(), value))
        shl(a, rdx(), 32)
        debug(a, "INT-MOD %llx\n" rdx())
        SET-LOCAL(x, rdx())
      INT-AND-OPCODE : ;YYY
        println("C INT-AND")
        and-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        debug(a, "INT-AND %llx\n" tmp1())
        SET-LOCAL(x, tmp1())
      INT-OR-OPCODE : ;YYY
        println("C INT-OR")
        or-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        debug(a, "INT-OR %llx\n" tmp1())
        SET-LOCAL(x, tmp1())
      INT-XOR-OPCODE : ;YYY
        println("C INT-XOR")
        xor-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        debug(a, "INT-XOR %llx\n" tmp1())
        SET-LOCAL(x, tmp1())
      INT-SHL-OPCODE : ;YYY
        println("C INT-SHL X %_ Y %_ VALUE %_" % [x, y, value])
        shr(a, LOCAL(rcx(), value), 32)
        shl(a, LOCAL(tmp1(), y), rcx())
        SET-LOCAL(x, tmp1())
        debug(a, "INT-SHL %llx << %d\n" tmp1(), rcx())
      INT-SHR-OPCODE : ;YYY
        println("C INT-SHR")
        shr(a, LOCAL(rcx(), value), 32)
        shr(a, LOCAL(tmp1(), y), rcx())
        debug(a, "INT-SHR %llx >> %d\n" tmp1(), tmp2())
        SET-LOCAL(x, tmp1())
      INT-ASHR-OPCODE : ;YYY
        println("C INT-ASHR")
        shr(a, LOCAL(rcx(), value), 32)
        ashr(a, LOCAL(tmp1(), y), rcx())
        debug(a, "INT-ASHR %llx >>> %d\n" tmp1(), rcx())
        SET-LOCAL(x, tmp1())
      INT-LT-OPCODE : ;YYY
        println("C INT-LT")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-l)
        debug(a, "LT? %d\n" res)
        SET-LOCAL(x, BOOLREF(res))
      INT-GT-OPCODE : ;YYY
        println("C INT-GT X %_ Y %_ VALUE %_" % [x, y, value])
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-g)
        debug(a, "GT? %llx %llx: " tmp1() tmp2())
        debug(a, "%d\n" res)
        SET-LOCAL(x, BOOLREF(res))
      INT-LE-OPCODE : ;YYY
        println("C INT-LE")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-le)
        debug(a, "LE? %d\n" res)
        SET-LOCAL(x, BOOLREF(res))
      INT-GE-OPCODE : ;YYY
        println("C INT-GE")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ge)
        debug(a, "GE? %d\n" res)
        SET-LOCAL(x, BOOLREF(res))
      EQ-OPCODE-REF-REF : ;YYY
        println("C EQ-REF-REF")
        debug(a, "EQ? %llx %llx\n" LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-e)
        debug(a, "> EQ-REF-REF? %d\n" res)
        SET-LOCAL(x, BOOLREF(res))
      EQ-OPCODE-REF : ;YYY
        println("C EQ-REF")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-BYTE : ;YYY
        println("C EQ-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-INT : ;YYY
        println("C EQ-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-LONG : ;YYY
        println("C EQ-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-FLOAT : ;YYY
        println("C EQ-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      EQ-OPCODE-DOUBLE : ;YYY
        println("C EQ-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-e)
        SET-LOCAL(x, res)
      NE-OPCODE-REF-REF : ;YYY
        println("C NE-REF-REF")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
        debug(a, "EQ? %d\n" res)
        SET-LOCAL(x, BOOLREF(res))
      NE-OPCODE-REF : ;YYY
        println("C NE-REF")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
        SET-LOCAL(x, res)
      NE-OPCODE-BYTE : ;YYY
        println("C NE-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-ne)
        debug(a, "NE-BYTE %llx\n", res)
        SET-LOCAL(x, res)
      NE-OPCODE-INT : ;YYY
        println("C NE-INT")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
        SET-LOCAL(x, res)
        debug(a, "NE-INT %llx\n", res)
        debug(a, "NE-INT ARGS %llx %llx\n", LOCAL(tmp1(), y), LOCAL(tmp2(), value))
      NE-OPCODE-LONG : ;YYY
        println("C NE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
        debug(a, "NE-LONG %llx\n", res)
        SET-LOCAL(x, res)
      NE-OPCODE-FLOAT : ;YYY
        println("C NE-FLOAT")
        debug(a, "NE-FLOAT %llx %llx\n", LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-ne)
        SET-LOCAL(x, res)
        debug(a, "NE-FLOAT %llx\n", res)
        ; LOCAL-FLOAT(xmm0(), y)
        ; LOCAL-FLOAT(xmm1(), value)
        ; mov(a, rax(), xmm0())
        ; debug(a, "XMM0 = %llx\n" rax())
        ; mov(a, rax(), xmm1())
        ; debug(a, "XMM1 = %llx\n" rax())
      NE-OPCODE-DOUBLE : ;YYY
        println("C NE-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-ne)
        SET-LOCAL(x, res)
      ADD-OPCODE-BYTE : ;YYY
        println("C ADD-BYTE")
        add(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        debug(a, "ADD-BYTE %llx\n" tmp1b())
        SET-LOCAL(x, tmp1())
      ADD-OPCODE-INT : ;YYY
        println("C ADD-INT")
        add(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        debug(a, "ADD-INT %llx\n" tmp1i())
        SET-LOCAL(x, tmp1())
      ADD-OPCODE-LONG : ;YYY
        println("C ADD-LONG X %_ Y %_ VALUE %_" % [x, y, value])
        add(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      ADD-OPCODE-FLOAT : ;YYY
        println("C ADD-FLOAT")
        debug(a, "ADD FLOAT\n")
        debug(a, "  ARGS %llx %llx\n" LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        addss(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
        mov(a, tmp1(), xmm0())
        mov(a, tmp2(), xmm1())
        debug(a, "  RES %llx %llx\n", tmp1(), tmp2())
        debug(a, "  RES %llx\n", LOCAL(tmp1(), x))
      ADD-OPCODE-DOUBLE : ;YYY
        println("C ADD-DOUBLE")
        addsd(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      SUB-OPCODE-BYTE : ;YYY
        println("C SUB-BYTE")
        sub(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        SET-LOCAL(x, tmp1())
      SUB-OPCODE-INT : ;YYY
        println("C SUB-INT")
        sub(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        debug(a, "SUB-INT %llx\n" tmp1i())
        SET-LOCAL-INT(x, tmp1())
      SUB-OPCODE-LONG : ;YYY
        println("C SUB-LONG")
        sub(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      SUB-OPCODE-FLOAT : ;YYY
        println("C SUB-FLOAT")
        subss(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      SUB-OPCODE-DOUBLE : ;YYY
        println("C SUB-DOUBLE")
        subsd(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      MUL-OPCODE-BYTE : ;YYY
        println("C MUL-BYTE")
        imul(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        SET-LOCAL(x, tmp1b())
      MUL-OPCODE-INT : ;YYY
        println("C MUL-INT")
        imul(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        debug(a, "MUL-INT %llx\n" tmp1i())
        SET-LOCAL-INT(x, tmp1())
      MUL-OPCODE-LONG : ;YYY
        println("C MUL-LONG X %_ Y %_ VALUE %_" % [x, y, value])
        imul(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        debug(a, "MUL-LONG %llx %llx\n", tmp1(), tmp2())
        SET-LOCAL(x, tmp1())
      MUL-OPCODE-FLOAT : ;YYY
        println("C MUL-FLOAT")
        mulss(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      MUL-OPCODE-DOUBLE : ;YYY
        println("C MUL-DOUBLE")
        mulsd(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      DIV-OPCODE-BYTE : ;YYY
        println("C DIV-BYTE")
        xor-op(a, rdx(), rdx())
        LOCAL(al(), y), 
        div(a, LOCAL(tmp2b(), value))
        SET-LOCAL(x, al())
      DIV-OPCODE-INT : ;YYY
        println("C DIV-INT")
        xor-op(a, rdx(), rdx())
        LOCAL(eax(), y), 
        div(a, LOCAL(tmp2i(), value))
        debug(a, "DIV-INT %llx\n" eax())
        SET-LOCAL-INT(x, rax())
      DIV-OPCODE-LONG : ;YYY
        println("C DIV-LONG")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y)
        div(a, LOCAL(tmp2(), value))
        SET-LOCAL(x, rax())
      DIV-OPCODE-FLOAT : ;YYY
        println("C DIV-FLOAT")
        divss(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
        SET-LOCAL-FLOAT(x, xmm0())
      DIV-OPCODE-DOUBLE : ;YYY
        println("C DIV-DOUBLE")
        divsd(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
        SET-LOCAL-DOUBLE(x, xmm0())
      MOD-OPCODE-BYTE : ;YYY
        println("C MOD-BYTE")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y)
        div(a, LOCAL(tmp2b(), value))
        SET-LOCAL(x, rdx())
      MOD-OPCODE-INT : ;YYY
        println("C MOD-INT")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y)
        div(a, LOCAL(tmp2i(), value))
        debug(a, "MOD-INT %llx\n" edx())
        SET-LOCAL-INT(x, rdx())
      MOD-OPCODE-LONG : ;YYY
        println("C MOD-LONG")
        xor-op(a, rdx(), rdx())
        LOCAL(rax(), y)
        div(a, LOCAL(tmp2(), value))
        SET-LOCAL(x, rdx())
      AND-OPCODE-BYTE : ;YYY
        println("C AND-BYTE")
        and-op(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        SET-LOCAL(x, tmp1b())
      AND-OPCODE-INT : ;YYY
        println("C AND-INT")
        and-op(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        debug(a, "AND-INT %llx\n" tmp1i())
        SET-LOCAL(x, tmp1i())
      AND-OPCODE-LONG : ;YYY
        println("C AND-LONG")
        and-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      OR-OPCODE-BYTE : ;YYY
        println("C OR-BYTE")
        or-op(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        SET-LOCAL(x, tmp1b())
      OR-OPCODE-INT : ;YYY
        println("C OR-INT")
        or-op(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        debug(a, "OR-INT %llx\n" tmp1i())
        SET-LOCAL(x, tmp1i())
      OR-OPCODE-LONG : ;YYY
        println("C OR-LONG")
        or-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      XOR-OPCODE-BYTE : ;YYY
        println("C XOR-BYTE")
        xor-op(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value))
        debug(a, "XOR-INT %llx\n" tmp1i())
        SET-LOCAL(x, tmp1b())
      XOR-OPCODE-INT : ;YYY
        println("C XOR-INT")
        xor-op(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value))
        SET-LOCAL(x, tmp1i())
      XOR-OPCODE-LONG : ;YYY
        println("C XOR-LONG")
        xor-op(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value))
        SET-LOCAL(x, tmp1())
      SHL-OPCODE-BYTE : ;YYY
        println("C SHL-BYTE")
        shl(a, LOCAL(tmp1b(), y), LOCAL(rcx(), value))
        SET-LOCAL(x, tmp1b())
      SHL-OPCODE-INT : ;YYY
        println("C SHL-INT")
        shl(a, LOCAL(tmp1i(), y), LOCAL(rcx(), value))
        debug(a, "SHL-INT %llx\n" tmp1())
        SET-LOCAL(x, tmp1())
      SHL-OPCODE-LONG : ;YYY
        println("C SHL-LONG")
        shl(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        SET-LOCAL(x, tmp1())
      SHR-OPCODE-BYTE : ;YYY
        println("C SHR-BYTE")
        shr(a, LOCAL(tmp1b(), y), LOCAL(rcx(), value))
        SET-LOCAL(x, tmp1b())
      SHR-OPCODE-INT : ;YYY
        println("C SHR-INT")
        shr(a, LOCAL(tmp1i(), y), LOCAL(rcx(), value))
        debug(a, "SHR-INT %llx\n" tmp1i())
        SET-LOCAL(x, tmp1i())
      SHR-OPCODE-LONG : ;YYY
        println("C SHR-LONG")
        shr(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        SET-LOCAL(x, tmp1())
      ASHR-OPCODE-INT : ;YYY
        println("C ASHR-INT")
        ashr(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        debug(a, "ASHR-INT %llx\n" tmp1i())
        SET-LOCAL(x, tmp1())
      ASHR-OPCODE-LONG : ;YYY
        println("C ASHR-LONG")
        ashr(a, LOCAL(tmp1(), y), LOCAL(rcx(), value))
        SET-LOCAL(x, tmp1())
      LT-OPCODE-INT : ;YYY
        println("C LT-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-l)
        debug(a, "LT-INT %llx\n" res)
        SET-LOCAL(x, res)
      LT-OPCODE-LONG : ;YYY
        println("C LT-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-l)
        SET-LOCAL(x, res)
      LT-OPCODE-FLOAT : ;YYY
        println("C LT-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-b)
        debug(a, "LT-FLOAT %d\n", res)
        SET-LOCAL(x, res)
      LT-OPCODE-DOUBLE : ;YYY
        println("C LT-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-b)
        debug(a, "LT-DOUBLE %d\n", res)
        SET-LOCAL(x, res)
      GT-OPCODE-INT : ;YYY
        println("C GT-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-g)
        debug(a, "GT-INT %llx\n" res)
        SET-LOCAL(x, res)
      GT-OPCODE-LONG : ;YYY
        println("C GT-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-g)
        SET-LOCAL(x, res)
      GT-OPCODE-FLOAT : ;YYY
        println("C GT-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-a)
        debug(a, "GT-FLOAT %d\n" res)
        SET-LOCAL(x, res)
      GT-OPCODE-DOUBLE : ;YYY
        println("C GT-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-a)
        debug(a, "GT-DOUBLE %d\n", res)
        SET-LOCAL(x, res)
      LE-OPCODE-INT : ;YYY
        println("C LE-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-le)
        debug(a, "LE-INT %llx\n" res)
        SET-LOCAL(x, res)
      LE-OPCODE-LONG : ;YYY
        println("C LE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-le)
        SET-LOCAL(x, res)
      LE-OPCODE-FLOAT : ;YYY
        println("C LE-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-be)
        debug(a, "LE-FLOAT %d\n" res)
        SET-LOCAL(x, res)
      LE-OPCODE-DOUBLE : ;YYY
        println("C LE-DOUBLE")
        val res = cmpd-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-be)
        debug(a, "LE-DOUBLE %d\n", res)
        SET-LOCAL(x, res)
      GE-OPCODE-INT : ;YYY
        println("C GE-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-ge)
        debug(a, "GE-INT %llx\n" res)
        SET-LOCAL(x, res)
      GE-OPCODE-LONG : ;YYY
        println("C GE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ge)
        SET-LOCAL(x, res)
      GE-OPCODE-FLOAT : ;YYY
        println("C GE-FLOAT")
        val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-ae)
        debug(a, "GE-FLOAT %d\n" res)
        SET-LOCAL(x, res)
      GE-OPCODE-DOUBLE : ;YYY
        println("C GE-DOUBLE")
        val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-ae)
        debug(a, "GE-DOUBLE %d\n", res)
        SET-LOCAL(x, res)
      ULT-OPCODE-BYTE : ;YYY
        println("C ULT-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-b)
        SET-LOCAL(x, res)
      ULT-OPCODE-INT : ;YYY
        println("C ULT-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-b)
        SET-LOCAL(x, res)
      ULT-OPCODE-LONG : ;YYY
        println("C ULT-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-b)
        SET-LOCAL(x, res)
      ULE-OPCODE-BYTE : ;YYY
        println("C ULE-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-be)
        SET-LOCAL(x, res)
      ULE-OPCODE-INT : ;YYY
        println("C ULE-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-be)
        SET-LOCAL(x, res)
      ULE-OPCODE-LONG : ;YYY
        println("C ULE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-be)
        SET-LOCAL(x, res)
      UGT-OPCODE-BYTE : ;YYY
        println("C UGT-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-a)
        SET-LOCAL(x, res)
      UGT-OPCODE-INT : ;YYY
        println("C UGT-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-a)
        SET-LOCAL(x, res)
      UGT-OPCODE-LONG : ;YYY
        println("C UGT-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-a)
        SET-LOCAL(x, res)
      UGE-OPCODE-BYTE : ;YYY
        println("C UGE-BYTE")
        val res = cmp-set(a, LOCAL(tmp1b(), y), LOCAL(tmp2b(), value), tmp3(), tmp3b(), set-ae)
        SET-LOCAL(x, res)
      UGE-OPCODE-INT : ;YYY
        println("C UGE-INT")
        val res = cmp-set(a, LOCAL(tmp1i(), y), LOCAL(tmp2i(), value), tmp3(), tmp3b(), set-ae)
        SET-LOCAL(x, res)
      UGE-OPCODE-LONG : ;YYY
        println("C UGE-LONG")
        val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ae)
        SET-LOCAL(x, res)
      ALLOC-OPCODE-LOCAL : ;YYY
        println("C ALLOC-LOCAL X %_ Y %_ VALUE %_" % [x, y, value])
        val top = heap-top() ; TMP1
        mov(a, MemPtr(top, 0, SIZEOF-LONG), CONST(tmp2(), value))
        SET-LOCAL(x, ptr-to-ref(tmp2(), top))
        val num-bytes = tmp2()
        add(a, LOCAL(num-bytes, y), 8 + 7)
        debug(a, "NUM-BYTES %llx\n", num-bytes)
        and-op(a, num-bytes, CONST(rax(), (- 8L)))
        add(a, top, num-bytes)
        ; debug(a, "NUM-BYTES %llx TOP %llx\n" num-bytes top)
        mov(a, MemPtr(vmstate(), VMSTATE-HEAP-TOP-OFFSET, SIZEOF-LONG), top)
      ALLOC-OPCODE-CONST : ;YYY
        println("C ALLOC-CONST X %_ Y %_ VALUE %_" % [x, y, value])
        val top = heap-top() ; TMP1
        mov(a, MemPtr(top, 0, SIZEOF-LONG), CONST(tmp2(), value))
        SET-LOCAL(x, ptr-to-ref(tmp2(), top))
        add(a, top, CONST(tmp2(), 8 + y))
        mov(a, MemPtr(vmstate(), VMSTATE-HEAP-TOP-OFFSET, SIZEOF-LONG), top)
      else :
        println("MISSING C OPCODE %_" % [opcode])

  defn emit-ins-d (opcode:Int, x:Int, value:Long) :
    switch(opcode) :
      CALLC-OPCODE-WIDE :  ;YYY
        println("D CALLC-WIDE")
        debug(a, "CALLC-WIDE\n")
        val end-label = new-label(a)
        val faddr = value
        val num_locals = x
        PUSH-FRAME(num_locals, end-label)
        SAVE-STATE()
        mov(a, tmp1(), faddr)
        c-trampoline(a, tmp1(), registers(), registers())
        RESTORE-STATE()
        ; debug(a, "JMP RETURN\n")
        ; mov(a, tmp1(), MemPtr(stack-pointer(), STACK-FRAME-RETURN-OFFSET, SIZEOF-LONG))
        ; jmp(a, tmp1())
        debug(a, "POP-FRAME\n")
        POP-FRAME(num_locals)
        bind(a, end-label)
      SET-OPCODE-WIDE : ;YYY
        println("D SET-WIDE X %_ VALUE %_" % [x, value])
        SET-LOCAL(x, CONST(tmp1(), value))
      SET-REG-OPCODE-WIDE : ;YYY
        println("D SET-REG-WIDE")
        SET-REG(x, CONST(tmp1(), value))
      else :
        println("MISSING D OPCODE %_" % [opcode])

  defn emit-ins-e (opcode:Int, x:Int, y:Int, z:Int, value:Int) :
    switch(opcode) :
      STORE-OPCODE-1 : ;YYY
        println("E STORE-1 X %_ VALUE %_ Z %_" % [x, value, z])
        LOCAL(tmp1(), x), CONST(tmp2(), value)
        debug(a, "STORE-1 %llx %d: " tmp1() tmp2())
        LOCAL(tmp1(), z)
        debug(a, "%llx\n" tmp1())
        mov(a, MemPtr(LOCAL(tmp1(), x), CONST(tmp2(), value), 0, 0, SIZEOF-BYTE), LOCAL(al(), z))
      STORE-OPCODE-4 : ;YYY
        println("E STORE-4 X %_ VALUE %_ Z %_" % [x, value, z])
        LOCAL(tmp1(), x), CONST(tmp2(), value)
        debug(a, "STORE-4 %llx %d: " tmp1() tmp2())
        LOCAL(tmp1i(), z)
        debug(a, "%llx\n" tmp1())
        mov(a, MemPtr(LOCAL(tmp1(), x), CONST(tmp2(), value), 0, 0, SIZEOF-INT), LOCAL(eax(), z))
      STORE-OPCODE-8 : ;YYY
        println("E STORE-8 X %_ VALUE %_ Z %_" % [x, value, z])
        LOCAL(tmp1(), x), CONST(tmp2(), value)
        debug(a, "STORE-8 %llx %d: " tmp1() tmp2())
        LOCAL(tmp1(), z)
        debug(a, "%llx\n" tmp1())
        mov(a, MemPtr(LOCAL(tmp1(), x), CONST(tmp2(), value), 0, 0, SIZEOF-LONG), LOCAL(rax(), z))
      STORE-OPCODE-1-VAR-OFFSET : ;YYY
        println("E STORE-1-VAR-OFFSET")
        mov(a, MemPtr(LOCAL(tmp1(), x), LOCAL(tmp2(), y), 0, value, SIZEOF-BYTE), LOCAL(al(), z))
      STORE-OPCODE-4-VAR-OFFSET : ;YYY
        println("E STORE-4-VAR-OFFSET")
        mov(a, MemPtr(LOCAL(tmp1(), x), LOCAL(tmp2(), y), 0, value, SIZEOF-INT), LOCAL(eax(), z))
        debug(a, "STORE-4-VAR-OFFSET %llx %llx\n", tmp1(), tmp2())
      STORE-OPCODE-8-VAR-OFFSET : ;YYY
        println("E STORE-8-VAR-OFFSET")
        mov(a, MemPtr(LOCAL(tmp1(), x), LOCAL(tmp2(), y), 0, value, SIZEOF-LONG), LOCAL(rax(), z))
      LOAD-OPCODE-1 :  ;YYY
        println("D LOAD-1 X %_ Y %_ VALUE %_" % [x, y, value])
        mov(a, tmp3(), MemPtr(LOCAL(tmp1(), y), CONST(tmp2(), value), 0, 0, SIZEOF-BYTE))
        debug(a, "LOAD-1 %llx %llx: ", LOCAL(tmp1(), y), CONST(tmp2(), value))
        debug(a, "%llx\n", tmp3())
        SET-LOCAL(x, tmp3())
      LOAD-OPCODE-4 :  ;YYY
        println("D LOAD-4 X %_ Y %_ VALUE %_" % [x, y, value])
        debug(a, "LOAD-4 %llx %llx\n", LOCAL(tmp1(), y), CONST(tmp2(), value))
        mov(a, tmp2(), MemPtr(LOCAL(tmp1(), y), CONST(tmp2(), value), 0, 0, SIZEOF-INT))
        SET-LOCAL(x, tmp2())
      LOAD-OPCODE-8 : ;YYY
        println("D LOAD-8 X %_ Y %_ VALUE %_" % [x, y, value])
        debug(a, "LOAD-8 %llx %llx\n", LOCAL(tmp1(), y), CONST(tmp2(), value))
        mov(a, tmp2(), MemPtr(LOCAL(tmp1(), y), CONST(tmp2(), value), 0, 0, SIZEOF-LONG))
        SET-LOCAL(x, tmp2())
      LOAD-OPCODE-1-VAR-OFFSET : ;YYY
        println("E LOAD-1-VAR-OFFSET")
        mov(a, tmp3(), MemPtr(LOCAL(tmp2(), y), LOCAL(tmp1(), z), 0, value, SIZEOF-BYTE))
        SET-LOCAL(x, tmp3())
      LOAD-OPCODE-4-VAR-OFFSET : ;YYY
        println("E LOAD-4-VAR-OFFSET X %_ Y %_ Z %_ VALUE %_" % [x, y, z, value])
        mov(a, tmp3(), MemPtr(LOCAL(tmp2(), y), LOCAL(tmp1(), z), 0, value, SIZEOF-INT))
        debug(a, "LOAD-4-VAR-OFFSET %llx %llx\n", tmp2(), tmp1())
        SET-LOCAL(x, tmp3())
      LOAD-OPCODE-8-VAR-OFFSET : ;YYY
        println("E LOAD-8-VAR-OFFSET")
        mov(a, tmp3(), MemPtr(LOCAL(tmp2(), y), LOCAL(tmp1(), z), 0, value, SIZEOF-LONG))
        SET-LOCAL(x, tmp3())
      else :
        println("MISSING E OPCODE %_" % [opcode])

  defn jump-op-reg (x:Gp, y:Gp, f:(Assembler, Label) -> False, cmp:(Assembler, Gp, Gp) -> False, n1:Label, n2:Label) :
    cmp(a, x, y)
    f(a,  n1)
    jmp(a, n2)
    
  defn jump-op (x:Int, y:Int, f:(Assembler, Label) -> False, cmp:(Assembler, Gp, Gp) -> False, n1:Label, n2:Label) :
    jump-op-reg(LOCAL(tmp1(), x), LOCAL(tmp2(), y), f, cmp, n1, n2)
    
  defn jump-op-xmm (x:Xmm, y:Xmm, f:(Assembler, Label) -> False, cmp:(Assembler, Xmm, Xmm) -> False, n1:Label, n2:Label) :
    cmp(a, x, y)
    f(a,  n1)
    jmp(a, n2)
    
  defn jump-float-op (x:Int, y:Int, f:(Assembler, Label) -> False, n1:Label, n2:Label) :
    jump-op-xmm(LOCAL-FLOAT(xmm0(), x), LOCAL-FLOAT(xmm1(), y), f, ucomiss, n1, n2)
    
  defn jump-double-op (x:Int, y:Int, f:(Assembler, Label) -> False, n1:Label, n2:Label) :
    jump-op-xmm(LOCAL-DOUBLE(xmm0(), x), LOCAL-DOUBLE(xmm1(), y), f, ucomisd, n1, n2)
    
  defn emit-ins-f (opcode:Int, x:Int, y:Int, n1:Label, n2:Label) :
    switch(opcode) :
      JUMP-TAGBITS-OPCODE :
        println("F JUMP-TAGBITS")
        and-op(a, LOCAL(tmp1(), x), CONST(tmp2(), 0x7))
        cmp(a, tmp1(), CONST(tmp2(), y))
        je(a, n1)
        jmp(a, n2)
      JUMP-TAGWORD-OPCODE : ;YYY
        println("F JUMP-TAGWORD")
        LOCAL(tmp1(), x) ; OBJ
        and-op(a, LOCAL(tmp2(), x), CONST(rbx(), 7)) ; TAGBITS
        LOCAL(rbx(), y) ; TAG
        cmp(a, tmp2(), CONST(rax(), 1)) ; tagbits == 1
        jne(a, n2)
        mov(a, tmp1(), MemPtr(tmp1(), -1, SIZEOF-INT)) ; *p = *((int*)(obj - 1))
        jump-op-reg(tmp1(), rbx(), je, cmp, n1, n2)    ; *p == tag
      JUMP-SET-OPCODE : ;YYY
        println("F JUMP-SET")
        debug(a, "JUMP-SET[%lld] %llx\n" CONST(tmp2(), x), LOCAL(tmp1(), x))
        jump-op-reg(LOCAL(tmp1(), x), CONST(tmp2(), 0), jne, cmp, n1, n2)
      JUMP-INT-LT-OPCODE : ;YYY
        println("F JUMP-LT-REF")
        debug(a, "JUMP-LT-REF %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jl, cmp, n1, n2)
      JUMP-INT-GT-OPCODE : ;YYY
        println("F JUMP-GT-REF")
        debug(a, "JUMP-GT-REF %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jg, cmp, n1, n2)
      JUMP-INT-LE-OPCODE : ;YYY
        println("F JUMP-LE-REF")
        debug(a, "JUMP-LE-REF %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jle, cmp, n1, n2)
      JUMP-INT-GE-OPCODE : ;YYY
        println("F JUMP-GE-REF")
        debug(a, "JUMP-GE-REF %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jge, cmp, n1, n2)
      JUMP-EQ-OPCODE-REF : ;YYY
        println("F JUMP-EQ-REF")
        debug(a, "JUMP-EQ-REF %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, je, cmp, n1, n2)
      JUMP-EQ-OPCODE-BYTE : ;YYY
        println("F JUMP-EQ-BYTE")
        debug(a, "JUMP-EQ-BYTE %llx %llx\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y))
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), je, cmp, n1, n2)
      JUMP-EQ-OPCODE-INT : ;YYY
        println("F JUMP-EQ-INT")
        debug(a, "JUMP-EQ-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), je, cmp, n1, n2)
      JUMP-EQ-OPCODE-LONG : ;YYY
        println("F JUMP-EQ-LONG")
        debug(a, "JUMP-EQ-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, je, cmp, n1, n2)
      JUMP-EQ-OPCODE-FLOAT : ;YYY
        println("F JUMP-EQ-FLOAT")
        jump-float-op(x, y, je, n1, n2)
      JUMP-EQ-OPCODE-DOUBLE : ;YYY
        println("F JUMP-EQ-DOUBLE")
        jump-double-op(x, y, je, n1, n2)
      JUMP-NE-OPCODE-REF : ;YYY
        println("F JUMP-NE-REF")
        debug(a, "JUMP-NE-REF %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jne, cmp, n1, n2)
      JUMP-NE-OPCODE-BYTE : ;YYY
        println("F JUMP-NE-BYTE")
        debug(a, "JUMP-NE-BYTE %llx %llx\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y))
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), jne, cmp, n1, n2)
      JUMP-NE-OPCODE-INT : ;YYY
        println("F JUMP-NE-INT")
        debug(a, "JUMP-NE-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jne, cmp, n1, n2)
      JUMP-NE-OPCODE-LONG : ;YYY
        println("F JUMP-NE-LONG")
        debug(a, "JUMP-NE-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jne, cmp, n1, n2)
      JUMP-NE-OPCODE-FLOAT : ;YYY
        println("F JUMP-NE-FLOAT")
        jump-float-op(x, y, jne, n1, n2)
      JUMP-NE-OPCODE-DOUBLE : ;YYY
        println("F JUMP-NE-DOUBLE")
        jump-double-op(x, y, jne, n1, n2)
      JUMP-LT-OPCODE-INT : ;YYY
        println("F JUMP-LT-INT")
        debug(a, "JUMP-LT-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jl, cmp, n1, n2)
      JUMP-LT-OPCODE-LONG : ;YYY
        println("F JUMP-LT-LONG")
        debug(a, "JUMP-LT-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jl, cmp, n1, n2)
      JUMP-LT-OPCODE-FLOAT : ;YYY
        println("F JUMP-LT-FLOAT")
        jump-float-op(x, y, jl, n1, n2)
      JUMP-LT-OPCODE-DOUBLE : ;YYY
        println("F JUMP-LT-DOUBLE")
        jump-double-op(x, y, jl, n1, n2)
      JUMP-GT-OPCODE-INT : ;YYY
        println("F JUMP-GT-INT")
        debug(a, "JUMP-GT-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jg, cmp, n1, n2)
      JUMP-GT-OPCODE-LONG : ;YYY
        println("F JUMP-GT-LONG")
        debug(a, "JUMP-GT-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jg, cmp, n1, n2)
      JUMP-GT-OPCODE-FLOAT : ;YYY
        println("F JUMP-GT-FLOAT")
        jump-float-op(x, y, jg, n1, n2)
      JUMP-GT-OPCODE-DOUBLE : ;YYY
        println("F JUMP-GT-DOUBLE")
        jump-double-op(x, y, jg, n1, n2)
      JUMP-LE-OPCODE-INT : ;YYY
        println("F JUMP-LE-INT")
        debug(a, "JUMP-LE-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jle, cmp, n1, n2)
      JUMP-LE-OPCODE-LONG : ;YYY
        println("F JUMP-LE-LONG")
        debug(a, "JUMP-LE-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jle, cmp, n1, n2)
      JUMP-LE-OPCODE-FLOAT : ;YYY
        println("F JUMP-LE-FLOAT")
        jump-float-op(x, y, jle, n1, n2)
      JUMP-LE-OPCODE-DOUBLE : ;YYY
        println("F JUMP-LE-DOUBLE")
        jump-double-op(x, y, jle, n1, n2)
      JUMP-GE-OPCODE-INT : ;YYY
        println("F JUMP-GE-INT")
        debug(a, "JUMP-GE-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jge, cmp, n1, n2)
      JUMP-GE-OPCODE-LONG : ;YYY
        println("F JUMP-GE-LONG")
        debug(a, "JUMP-GE-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jge, cmp, n1, n2)
      JUMP-GE-OPCODE-FLOAT : ;YYY
        println("F JUMP-GE-FLOAT")
        jump-float-op(x, y, jge, n1, n2)
      JUMP-GE-OPCODE-DOUBLE : ;YYY
        println("F JUMP-GE-DOUBLE")
        jump-double-op(x, y, jge, n1, n2)
      JUMP-ULT-OPCODE-BYTE : ;YYY
        println("F JUMP-ULT-BYTE")
        debug(a, "JUMP-ULT-INT %llx %llx\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y))
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), jb, cmp, n1, n2)
      JUMP-ULT-OPCODE-INT : ;YYY
        println("F JUMP-ULT-INT")
        debug(a, "JUMP-ULT-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jb, cmp, n1, n2)
      JUMP-ULT-OPCODE-LONG : ;YYY
        println("F JUMP-ULT-LONG")
        debug(a, "JUMP-ULT-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jb, cmp, n1, n2)
      JUMP-ULE-OPCODE-BYTE : ;YYY
        println("F JUMP-ULE-BYTE")
        debug(a, "JUMP-ULE-BYTE %llx %llx\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y))
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), jbe, cmp, n1, n2)
      JUMP-ULE-OPCODE-INT : ;YYY
        println("F JUMP-ULE-INT")
        debug(a, "JUMP-ULE-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jbe, cmp, n1, n2)
      JUMP-ULE-OPCODE-LONG : ;YYY
        println("F JUMP-ULE-LONG")
        debug(a, "JUMP-ULE-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jbe, cmp, n1, n2)
      JUMP-UGT-OPCODE-BYTE : ;YYY
        println("F JUMP-UGT-BYTE")
        debug(a, "JUMP-UGT-INT %llx %llx\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y))
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), ja, cmp, n1, n2)
      JUMP-UGT-OPCODE-INT : ;YYY
        println("F JUMP-UGT-INT")
        debug(a, "JUMP-UGT-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), ja, cmp, n1, n2)
      JUMP-UGT-OPCODE-LONG : ;YYY
        println("F JUMP-UGT-LONG")
        debug(a, "JUMP-UGT-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, ja, cmp, n1, n2)
      JUMP-UGE-OPCODE-BYTE : ;YYY
        println("F JUMP-UGE-BYTE")
        debug(a, "JUMP-UGE-INT %llx %llx\n" LOCAL(tmp1b(), x), LOCAL(tmp2b(), y))
        jump-op-reg(LOCAL(tmp1b(), x), LOCAL(tmp2b(), y), jae, cmp, n1, n2)
      JUMP-UGE-OPCODE-INT : ;YYY
        println("F JUMP-UGE-INT")
        debug(a, "JUMP-UGE-INT %llx %llx\n" LOCAL(tmp1i(), x), LOCAL(tmp2i(), y))
        jump-op-reg(LOCAL(tmp1i(), x), LOCAL(tmp2i(), y), jae, cmp, n1, n2)
      JUMP-UGE-OPCODE-LONG : ;YYY
        println("F JUMP-UGE-LONG")
        debug(a, "JUMP-UGE-LONG %llx %llx\n" LOCAL(tmp1(), x), LOCAL(tmp2(), y))
        jump-op(x, y, jae, cmp, n1, n2)
      else : 
        println("MISSING F OPCODE %_" % [opcode])

  defn emit-ins-targets (dests:Tuple<Label>) :
    for (d in dests, i in 0 to false) do :
      println("TARGET %_" % [i])
      embed(a, d)

  ;Encode multivarity functions
  defn encode (multi:VMMultifn) :
    ;Declare function labels
    val labels = for entry in funcs(multi) map : new-label(a)
    ;Emit branch instructions
    for (entry in funcs(multi), flabel in labels) do :
      val arity = key(entry)
      emit-ins-c(JUMP-REG-OPCODE, arg(multi), arity, flabel)
    ;Emit default branch
    encode(default(multi))
    ;Emit other branches, and compute their positions
    for (entry in funcs(multi), flabel in labels) do :
      bind(a, flabel)
      encode(value(entry))

  defn encode (func:VMFunc) :
    ;==================================================
    ;============== Fundamental State =================
    ;==================================================
    ;Reserve extra 3 locals for temporary moving
    val max-local = maximum(-1, seq(local, defs(func)))
    val num-locals = max-local + 1 + 3

    ;Definitions
    val deftable = to-inttable(id, defs(func))

    ;Labels
    val label-table = IntTable<Label>()
    val used-labels = to-intset(seq(n, filter-by<LabelIns>(ins(func))))
    val label-counter = to-seq(0 to false)

    ;==================================================
    ;============== Overall Algorithm =================
    ;==================================================
    defn driver () :
      emit-prelude()
      do(emit-ins, ins(func))

    ;Enter a function
    defn emit-prelude () :
      ;Enter function
      emit-ins-a(FNENTRY-OPCODE, num-locals)
      ;Retrieve arguments
      get-regs(args(func))

    ;Encode a match statement that can be redefined later.
    defn emit-non-final-match (ys:Tuple<VMImm>, bs:Tuple<VMBranch>, default:Int) :
      ;Retrieve the format index of this match statement.
      val [types, dests] = split-types-and-dests(bs)
      val format = match-format(resolver, types)

      ;Push arguments onto registers
      set-regs(ys)

      ;One target for default and then each branch for dispatch.
      val num-targets = 1 + length(bs)
      val targets = jump-offsets([default], dests)
      emit-ins-a(DISPATCH-OPCODE, format)
      emit-ins-targets(targets)

    ;Encode a match statement that cannot be redefined later.
    defn emit-final-match (ys:Tuple<VMImm>, bs:Tuple<VMBranch>, default-label:Int) :
      defn compute-dag () :
        val branch-table = BranchTable(to-branches(seq(types,bs), {[_]}))
        compute-dispatch-dag(branch-table, false)

      defn emit-dag (dag:Dag) :
        ;Create labels for all entries
        val labels = map(gen-label{}, entries(dag))
        ;Convert a value into a label
        defn to-label (x:Int|Soln) :
          match(x) :
            (x:Int) : labels[x]
            (x:UniqueSoln) : n(bs[index(x)])
            (x:NoSoln) : default-label
        ;Compile a given entry
        defn emit-entry (e:DagEntry) :
          if empty?(entries(e)) :
            emit-ins(GotoIns(to-label(default(e))))
          else :
            within (entry, last?) = expanded-entries(e) :
              val n1 = to-label(value(entry))
              val n2 = to-label(default(e)) when last? else gen-label()
              emit-ins(Branch1Ins(n1, n2, InstanceofOp(SingleType(key(entry))), ys[depth(e)]))
              emit-ins(LabelIns(n2)) when not last?
        ;Compile all entries
        for (e in entries(dag), l in labels) do :
          emit-ins(LabelIns(l))
          emit-entry(e)

      ;Expand the given entries and compute whether it is the last entry
      defn expanded-entries (f:(KeyValue<Int,Int|Soln>, True|False) -> ?, e:DagEntry) :
        val es = for e in entries(e) seq-cat :
          for v in values(key(e)) seq :
            v => value(e)
        let loop () :
          val e = next(es)
          f(e, empty?(es))
          loop() when not empty?(es)

      ;Launch
      emit-dag(compute-dag())

    ;Emit instanceof operation
    defn emit-instanceof (n1:Int, n2:Int, x:VMImm, type:TypeSet) :
      if (type is SingleType) and type-is-final?(type) :
        defn driver () :
          val tag = /type(type as SingleType)
          switch(tag) :
            BYTE-TYPE : compare-tag-bits(BYTE-TYPE)
            CHAR-TYPE : compare-tag-bits(CHAR-TYPE)
            INT-TYPE : compare-tag-bits(INT-TYPE)
            FLOAT-TYPE :  compare-tag-bits(FLOAT-TYPE)
            else :
              if marker?(resolver, tag) : compare-marker(tag)
              else : compare-tag-word(tag)
        defn compare-tag-bits (typeid:Int) :
          val bits = tagbits(resolver,typeid)
          emit-ins-f(JUMP-TAGBITS-OPCODE, to-local(x,0), bits, jump-offset(n1), jump-offset(n2))
        defn compare-marker (typeid:Int) :
          emit-ins(Branch2Ins(n1, n2, EqOp(), x, Marker(typeid)))
        defn compare-tag-word (typeid:Int) :
          val typetag-local = to-local(NumConst(typeid), 0)
          val x-local = to-local(x,1)
          emit-ins-f(JUMP-TAGWORD-OPCODE, x-local, typetag-local, jump-offset(n1), jump-offset(n2))
        driver()
      else :
        ;Retrieve format
        val format = match-format(resolver, [[type]])
        ;Push argument into register
        set-reg(0, x)
        ;Emit dispatch instruction
        ;Two targets, match success and default
        val num-targets = 2
        val targets = jump-offsets([n2, n1])
        emit-ins-a(DISPATCH-OPCODE, format)
        emit-ins-targets(targets)

    defn maybe-add-new-label (n:Int) -> Label :
      if not key?(label-table, n) :
        label-table[n] = new-label(a)
      label-table[n]
      
    ;Encode each instruction
    defn emit-ins (ins:VMIns) :
      match(ins) :
        (ins:LabelIns) :
          val lab = maybe-add-new-label(n(ins))
          println("LABEL %_" % [n(ins)])
          bind(a, lab)
        (ins:UnreachableIns) :
          false
        (ins:TCallIns) :
          set-regs(ys(ins))
          emit-ins-c(tcall-opcode(f(ins)), 0, to-function-local(f(ins)))
        (ins:TCallClosureIns) :
          set-regs(ys(ins))
          emit-ins-a(TCALL-CLOSURE-OPCODE, to-local(f(ins), 0))
        (ins:CallIns) :
          set-regs(ys(ins))
          emit-ins-c(call-opcode(f(ins)), num-locals, to-function-local(f(ins)))
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallClosureIns) :
          set-regs(ys(ins))
          emit-ins-c(CALL-CLOSURE-OPCODE, num-locals, to-local(f(ins), 0))
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallCIns) :
          ;Convert a VMType into an ArgType for call-record analysis
          defn to-arg-type (t:VMType) :
            match(t) :
              (t:VMFloat|VMDouble) : RealArg()
              (t) : IntArg()
          ;Compute C calling convention
          val records = callc-records(ytypes, xtype, backend) where :
            val ytypes = map(to-arg-type, map(imm-type, ys(ins)))
            val xtypes = map(to-arg-type, map(imm-type, xs(ins)))
            val xtype = IntArg() when empty?(xtypes) else xtypes[0]
          ;Compute register locations
          var layout-counter:Int = 0
          defn next-index (n:Int) :
            val c = layout-counter
            layout-counter = layout-counter + n
            c
          val num-stack-args-index = next-index(1)
          val stack-args-index = next-index(num-mem-args(records))
          val num-float-args-index = next-index(1)
          val float-args-index = next-index(num-real-args(records))
          val num-int-args-index = next-index(1)
          val int-args-index = next-index(num-int-args(records))
          val num-floats-in-call-index = next-index(1)
          ;Given the location that the argument should be stored,
          ;return the index in the register buffer that we should
          ;store the argument that is desired by the trampoline code.
          defn register-index (l:CallLoc) -> Int :
            match(l) :
              (l:RegLoc) : num-floats-in-call-index - 1 - index(l)
              (l:FRegLoc) : num-int-args-index - 1 - index(l)
              (l:MemLoc) : num-float-args-index - 1 - index(l)
          ;Assign registers
          for arg in args(records) do :
            val r = register-index(loc(arg))
            val v = value(arg) as StdArg|ShadowArg
            val y = ys(ins)[index(v)]
            set-reg(r, y)
          ;Set number of arguments
          set-reg(num-stack-args-index, NumConst(num-mem-args(records)))
          set-reg(num-float-args-index, NumConst(num-real-args(records)))
          set-reg(num-int-args-index, NumConst(num-int-args(records) + 1))
          set-reg(num-floats-in-call-index, NumConst(num-real-args(records)))
          ;Call function
          match(f(ins)) :
            (f:Local) :
              emit-ins-c(CALLC-OPCODE-LOCAL, num-locals, slot(f))
            (f:ExternId) :
              val address = to-bits(f) as Long
              emit-ins-d(CALLC-OPCODE-WIDE, num-locals, address)
          debug(a, "RECORD-INFO\n")
          record-info(info(ins))
          ;Retrieve return registers
          defn return-register-index (l:CallLoc) :
            match(l) :
              (l:RegLoc) : 0
              (l:FRegLoc) : 1
          if not empty?(xs(ins)) :
            val x = xs(ins)[0]
            debug(a, "GET-REG RET\n")
            get-reg(x, return-register-index(return(records)))
        (ins:YieldIns) :
          set-regs(ys(ins))
          val opcode = ENTER-STACK-OPCODE when enter?(ins) else YIELD-OPCODE
          emit-ins-a(opcode, to-local(f(ins), 0))
          record-info(info(ins))
          get-regs(xs(ins))
        (ins:ReturnIns) :
          set-regs(xs(ins))
          println("RET SET-REGS %_" % [xs(ins)])
          emit-ins-a(RETURN-OPCODE, 0)
        (ins:DumpIns) :
          for x in xs(ins) do :
            emit-ins-a(DUMP-OPCODE, slot(x))
        (ins:RecordLiveIns) :
          val live-map = liveness-map(resolver, map(slot, live(ins)), num-locals)
          emit-ins-a(LIVE-OPCODE, live-map)
        (ins:StoreIns) :
          val code = store-opcode(y(ins), imm-type(z(ins)))
          val offset* = match(imm-type(x(ins))) :
            (xt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
            (xt) : offset(ins)
          val x* = to-local(x(ins),0)
          val z* = to-local(z(ins),1)
          val y* = match(y(ins)) :
            (y:VMImm) : to-local(y,2)
            (y:False) : 0
          emit-ins-e(code, x*, y*, z*, offset*)
        (ins:LoadIns) :
          val code = load-opcode(z(ins), imm-type(x(ins)))
          val offset* = match(imm-type(y(ins))) :
            (yt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
            (yt) : offset(ins)
          val y* = to-local(y(ins),0)
          val z* = match(z(ins)) :
            (z:VMImm) : to-local(z,1)
            (z:False) : 0
          emit-ins-e(code, slot(x(ins)), y*, z*, offset*)
        (ins:Op0Ins) :
          val code = op0-opcode(op(ins))
          emit-ins-a(code, slot(x(ins)))
        (ins:Op1Ins) :
          match(op(ins)) :
            (op:InstanceofOp) :
              ;Push argument into register
              set-reg(0, y(ins))
              val format = match-format(resolver, [[type(op)]])
              ;Emit typeof instruction
              emit-ins-c(TYPEOF-OPCODE, slot(x(ins)), format)
            (op) :
              val opcode = op1-opcode(op, imm-type(x(ins)), imm-type(y(ins)))
              match(opcode:Int) :
                val x* = slot(x(ins))
                val y* = to-local(y(ins), 0)
                emit-ins-b(opcode, x*, y*)
              else :
                set-local(slot(x(ins)), y(ins))
        (ins:Op2Ins) :
          val opcode = op2-opcode(op(ins), imm-type(x(ins)), imm-type(y(ins)))
          val x* = slot(x(ins))
          val y* = to-local(y(ins), 0)
          val z* = to-local(z(ins), 1)
          emit-ins-c(opcode, x*, y*, z*)
        (ins:GotoIns) :
          emit-ins-a(GOTO-OPCODE, jump-offset(n(ins)))
        (ins:Branch1Ins) :
          match(op(ins)) :
            (op:InstanceofOp) :
              emit-instanceof(n1(ins), n2(ins), x(ins), type(op))
            (op:False) :
              emit-ins-f(JUMP-SET-OPCODE, to-local(x(ins), 0), 0, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:Branch2Ins) :
          val code = branch2-opcode(op(ins), imm-type(x(ins)))
          val x* = to-local(x(ins), 0)
          val y* = to-local(y(ins), 1)
          emit-ins-f(code, x*, y*, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:AllocIns) :
          val continue-label = new-label(a)
          if all?({_ is NumConst}, sizes(ins)) :
            val num-obj = length(sizes(ins))
            val obj-sizes = for s in sizes(ins) map :
              object-size-on-heap(resolver, value(s as NumConst) as Int)
            ;Big sizes don't fit in instruction encoding
            val sum-of-sizes = object-size(num-obj, sum(obj-sizes))
            if sum-of-sizes >= 1024 :
              val size-local = to-local(NumConst(sum-of-sizes),0)
              emit-ins-c(RESERVE-OPCODE-LOCAL, continue-label, num-locals, size-local)
            else :
              emit-ins-c(RESERVE-OPCODE-CONST, continue-label, num-locals, sum-of-sizes)
            record-info(info(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            bind(a, continue-label)
            for (x in xs(ins), t in types(ins), sz in obj-sizes) do :
              ;Big object doesn't fit in instruction encoding
              if sz >= 1024 :
                val size-local = to-local(NumConst(sz),0)
                emit-ins-c(ALLOC-OPCODE-LOCAL, slot(x), size-local, t)
              else :
                emit-ins-c(ALLOC-OPCODE-CONST, slot(x), sz, t)
          else:
            fatal("Multiple variable-sized allocations.") when length(sizes(ins)) > 1
            val x = xs(ins)[0]
            val type = types(ins)[0]
            val size = to-local(sizes(ins)[0], 0)
            emit-ins-c(RESERVE-OPCODE-LOCAL, continue-label, num-locals, size)
            record-info(info(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            bind(a, continue-label)
            emit-ins-c(ALLOC-OPCODE-LOCAL, slot(x), size, type)
        (ins:DispatchIns) :
          ;Push arguments onto registers
          set-regs(ys(ins))
          val [types, dests] = split-types-and-dests(branches(ins))
          val format = dispatch-format(resolver, types)
          ;Two targets for default and amb and then each branch for dispatch.
          val num-targets = 2 + length(branches(ins))
          val targets = jump-offsets([default(ins), amb(ins)], dests)
          emit-ins-a(DISPATCH-OPCODE, format)
          emit-ins-targets(targets)
        (ins:MatchIns) :
          if all?(branch-is-final?, branches(ins)) :
            emit-final-match(ys(ins), branches(ins), default(ins))
          else :
            emit-non-final-match(ys(ins), branches(ins), default(ins))
        (ins:MethodDispatchIns) :
          ;Push arguments onto registers
          set-regs(cat(ys(ins), zs(ins)))
          ;Retrieve format
          val format = method-format(resolver, multi(ins), length(ys(ins)), length(zs(ins)))
          ;Only two targets for default and amb
          val num-targets = 2
          val targets = jump-offsets([default(ins), amb(ins)])
          emit-ins-a(DISPATCH-METHOD-OPCODE, format)
          emit-ins-targets(targets)
        (ins:SetIns) :
          set-local(slot(x(ins)), y(ins))

    ;==================================================
    ;============= Immediate Utilities ================
    ;==================================================
    ;Retrieve type of immediate
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:VMType) :
      x

    ;Use deftable to retrieve the slot of a local
    defn slot (x:Local) :
      local(deftable[index(x)])

    ;==================================================
    ;============= Label Utilities ====================
    ;==================================================
    ;Create mapping from label ID to position
    defn jump-offset (n:Int) -> Label :
      maybe-add-new-label(n)
    defn jump-offsets (xs:Seqable<Int>) -> Tuple<Label> :
      to-tuple(seq(jump-offset, xs))
    defn jump-offsets (xs:Seqable<Int>, ys:Seqable<Int>) -> Tuple<Label> :
      jump-offsets(cat(xs,ys))

    ;Generate new unique label
    defn* gen-label () :
      val l = next(label-counter)
      gen-label() when used-labels[l] else l

    ;==================================================
    ;============= Compilation Utilities ==============
    ;==================================================
    ;Retrieve the corresponding bits for the given immediate
    defn to-bits (y:VMImm) -> Int|Long :
      match(y) :
        (y:Local) : slot(y)
        (y:NumConst) :
          match(value(y)) :
            (v:Char) : to-int(v)
            (v:Byte) : to-int(v)
            (v:Int) : v
            (v:Long) : v
            (v:Float) : bits(v)
            (v:Double) : bits(v)
        (y:Marker) : marker(resolver, typeid(y))
        (y:Tag) : typeid(y)
        (y:VoidMarker) : void-marker(resolver)
        (y:CodeId) : id(y)
        (y:ExternId) : extern-address(id(y))
        (y:GlobalId) : id(y)
        (y:DataId) : id(y)
        (y:ConstId) : (println("CONST ID %_" % [id(y)]), id(y))

    ;Set register
    defn set-reg (i:Int, y:VMImm) :
      match(to-bits(y)) :
        (v:Int) : emit-ins-c(set-reg-opcode(y), i, v)
        (v:Long) : emit-ins-d(set-reg-opcode(y), i, v)
    defn set-regs (ys:Seqable<VMImm>) :
      do(set-reg, 0 to false, ys)
    defn get-reg (x:Local|VMType, i:Int) :
      match(x:Local) :
        emit-ins-b(GET-REG-OPCODE, slot(x), i)
    defn get-regs (xs:Seqable<Local|VMType>) :
      do(get-reg, xs, 0 to false)

    ;Set local
    defn set-local (x:Int, y:VMImm) :
      match(to-bits(y)) :
        (v:Int) : emit-ins-c(set-opcode(y), x, v)
        (v:Long) : emit-ins-d(set-opcode(y), x, v)

    ;Put immediate in temporary local if not a local
    defn to-local (x:VMImm, num:Int) :
      match(x:Local) :
        slot(x)
      else :
        val index = max-local + num + 1
        set-local(index, x)
        index

    ;Number of words needed to hold immediate in local
    defn words-for-to-local (x:VMImm) :
      match(x:Local) :
        0
      else :
        match(to-bits(x)) :
          (v:Int) : 2
          (v:Long) : 3

    ;Put immediate in register if not a function immediate
    defn to-function-local (f:VMImm) :
      match(f) :
        (f:CodeId) : id(f)
        (f) : to-local(f, 0)

    ;==================================================
    ;===================== Launch =====================
    ;==================================================
    driver()
  
  encode(func as VMMultifn|VMFunc)
  val f = add(rt, code)
  println("FUNC %_" % [hex(value(f))])
  EncodedFunction(f, fileinfo-table)

;============================================================
;======================= Opcodes ============================
;============================================================

val SET-OPCODE-LOCAL = 0
val SET-OPCODE-UNSIGNED = 1
val SET-OPCODE-SIGNED = 2
val SET-OPCODE-CODE = 3
val SET-OPCODE-GLOBAL = 5
val SET-OPCODE-DATA = 6
val SET-OPCODE-CONST = 7
val SET-OPCODE-WIDE = 8
val SET-REG-OPCODE-LOCAL = 9
val SET-REG-OPCODE-UNSIGNED = 10
val SET-REG-OPCODE-SIGNED = 11
val SET-REG-OPCODE-CODE = 12
val SET-REG-OPCODE-GLOBAL = 14
val SET-REG-OPCODE-DATA = 15
val SET-REG-OPCODE-CONST = 16
val SET-REG-OPCODE-WIDE = 17
val GET-REG-OPCODE = 18
val CALL-OPCODE-LOCAL = 19
val CALL-OPCODE-CODE = 20
val CALL-CLOSURE-OPCODE = 22
val TCALL-OPCODE-LOCAL = 23
val TCALL-OPCODE-CODE = 24
val TCALL-CLOSURE-OPCODE = 26
val CALLC-OPCODE-LOCAL = 27
val CALLC-OPCODE-WIDE = 28
val POP-FRAME-OPCODE = 30
val LIVE-OPCODE = 31
val YIELD-OPCODE = 32
val RETURN-OPCODE = 33
val DUMP-OPCODE = 34
;2-arity operations
val INT-ADD-OPCODE = 35
val INT-SUB-OPCODE = 36
val INT-MUL-OPCODE = 37
val INT-DIV-OPCODE = 38
val INT-MOD-OPCODE = 39
val INT-AND-OPCODE = 40
val INT-OR-OPCODE = 41
val INT-XOR-OPCODE = 42
val INT-SHL-OPCODE = 43
val INT-SHR-OPCODE = 44
val INT-ASHR-OPCODE = 45
val INT-LT-OPCODE = 46
val INT-GT-OPCODE = 47
val INT-LE-OPCODE = 48
val INT-GE-OPCODE = 49
val EQ-OPCODE-REF-REF = 50
val EQ-OPCODE-REF = 51
val EQ-OPCODE-BYTE = 52
val EQ-OPCODE-INT = 53
val EQ-OPCODE-LONG = 54
val EQ-OPCODE-FLOAT = 55
val EQ-OPCODE-DOUBLE = 56
val NE-OPCODE-REF-REF = 57
val NE-OPCODE-REF = 58
val NE-OPCODE-BYTE = 59
val NE-OPCODE-INT = 60
val NE-OPCODE-LONG = 61
val NE-OPCODE-FLOAT = 62
val NE-OPCODE-DOUBLE = 63
val ADD-OPCODE-BYTE = 64
val ADD-OPCODE-INT = 65
val ADD-OPCODE-LONG = 66
val ADD-OPCODE-FLOAT = 67
val ADD-OPCODE-DOUBLE = 68
val SUB-OPCODE-BYTE = 69
val SUB-OPCODE-INT = 70
val SUB-OPCODE-LONG = 71
val SUB-OPCODE-FLOAT = 72
val SUB-OPCODE-DOUBLE = 73
val MUL-OPCODE-BYTE = 74
val MUL-OPCODE-INT = 75
val MUL-OPCODE-LONG = 76
val MUL-OPCODE-FLOAT = 77
val MUL-OPCODE-DOUBLE = 78
val DIV-OPCODE-BYTE = 79
val DIV-OPCODE-INT = 80
val DIV-OPCODE-LONG = 81
val DIV-OPCODE-FLOAT = 82
val DIV-OPCODE-DOUBLE = 83
val MOD-OPCODE-BYTE = 84
val MOD-OPCODE-INT = 85
val MOD-OPCODE-LONG = 86
val AND-OPCODE-BYTE = 87
val AND-OPCODE-INT = 88
val AND-OPCODE-LONG = 89
val OR-OPCODE-BYTE = 90
val OR-OPCODE-INT = 91
val OR-OPCODE-LONG = 92
val XOR-OPCODE-BYTE = 93
val XOR-OPCODE-INT = 94
val XOR-OPCODE-LONG = 95
val SHL-OPCODE-BYTE = 96
val SHL-OPCODE-INT = 97
val SHL-OPCODE-LONG = 98
val SHR-OPCODE-BYTE = 99
val SHR-OPCODE-INT = 100
val SHR-OPCODE-LONG = 101
val ASHR-OPCODE-INT = 103
val ASHR-OPCODE-LONG = 104
val LT-OPCODE-INT = 105
val LT-OPCODE-LONG = 106
val LT-OPCODE-FLOAT = 107
val LT-OPCODE-DOUBLE = 108
val GT-OPCODE-INT = 109
val GT-OPCODE-LONG = 110
val GT-OPCODE-FLOAT = 111
val GT-OPCODE-DOUBLE = 112
val LE-OPCODE-INT = 113
val LE-OPCODE-LONG = 114
val LE-OPCODE-FLOAT = 115
val LE-OPCODE-DOUBLE = 116
val GE-OPCODE-INT = 117
val GE-OPCODE-LONG = 118
val GE-OPCODE-FLOAT = 119
val GE-OPCODE-DOUBLE = 120
val ULE-OPCODE-BYTE = 121
val ULE-OPCODE-INT = 122
val ULE-OPCODE-LONG = 123
val ULT-OPCODE-BYTE = 124
val ULT-OPCODE-INT = 125
val ULT-OPCODE-LONG = 126
val UGT-OPCODE-BYTE = 127
val UGT-OPCODE-INT = 128
val UGT-OPCODE-LONG = 129
val UGE-OPCODE-BYTE = 130
val UGE-OPCODE-INT = 131
val UGE-OPCODE-LONG = 132
;1-arity operations
val INT-NOT-OPCODE = 133
val INT-NEG-OPCODE = 134
val NOT-OPCODE-BYTE = 135
val NOT-OPCODE-INT = 136
val NOT-OPCODE-LONG = 137
val NEG-OPCODE-INT = 138
val NEG-OPCODE-LONG = 139
val NEG-OPCODE-FLOAT = 140
val NEG-OPCODE-DOUBLE = 141
val DEREF-OPCODE = 142
val TYPEOF-OPCODE = 143
;branch operation
val JUMP-SET-OPCODE = 144
val JUMP-TAGBITS-OPCODE = 240
val JUMP-TAGWORD-OPCODE = 242
val GOTO-OPCODE = 145
;conversion operations
val CONV-OPCODE-BYTE-FLOAT = 146
val CONV-OPCODE-BYTE-DOUBLE = 147
val CONV-OPCODE-INT-BYTE = 148
val CONV-OPCODE-INT-FLOAT = 149
val CONV-OPCODE-INT-DOUBLE = 150
val CONV-OPCODE-LONG-BYTE = 151
val CONV-OPCODE-LONG-INT = 152
val CONV-OPCODE-LONG-FLOAT = 153
val CONV-OPCODE-LONG-DOUBLE = 154
val CONV-OPCODE-FLOAT-BYTE = 155
val CONV-OPCODE-FLOAT-INT = 156
val CONV-OPCODE-FLOAT-LONG = 157
val CONV-OPCODE-FLOAT-DOUBLE = 158
val CONV-OPCODE-DOUBLE-BYTE = 159
val CONV-OPCODE-DOUBLE-INT = 160
val CONV-OPCODE-DOUBLE-LONG = 161
val CONV-OPCODE-DOUBLE-FLOAT = 162
;tagging operations
val DETAG-OPCODE = 163
val TAG-OPCODE-BYTE = 164
val TAG-OPCODE-CHAR = 165
val TAG-OPCODE-INT = 166
val TAG-OPCODE-FLOAT = 167
;storing operations
val STORE-OPCODE-1 = 168
val STORE-OPCODE-4 = 169
val STORE-OPCODE-8 = 170
val STORE-OPCODE-1-VAR-OFFSET = 171
val STORE-OPCODE-4-VAR-OFFSET = 172
val STORE-OPCODE-8-VAR-OFFSET = 173
;loading operations
val LOAD-OPCODE-1 = 174
val LOAD-OPCODE-4 = 175
val LOAD-OPCODE-8 = 176
val LOAD-OPCODE-1-VAR-OFFSET = 177
val LOAD-OPCODE-4-VAR-OFFSET = 178
val LOAD-OPCODE-8-VAR-OFFSET = 179
;Allocation
val RESERVE-OPCODE-LOCAL = 180
val RESERVE-OPCODE-CONST = 181
val ENTER-STACK-OPCODE = 182
val ALLOC-OPCODE-CONST = 183
val ALLOC-OPCODE-LOCAL = 184
;system operations
val GC-OPCODE = 185
val CLASS-NAME-OPCODE = 241
val C-RSP-OPCODE = 243
val PRINT-STACK-TRACE-OPCODE = 186
val FLUSH-VM-OPCODE = 188
;2-arity branch operations
val JUMP-INT-LT-OPCODE = 192
val JUMP-INT-GT-OPCODE = 193
val JUMP-INT-LE-OPCODE = 194
val JUMP-INT-GE-OPCODE = 195
val JUMP-EQ-OPCODE-REF = 196
val JUMP-EQ-OPCODE-BYTE = 197
val JUMP-EQ-OPCODE-INT = 198
val JUMP-EQ-OPCODE-LONG = 199
val JUMP-EQ-OPCODE-FLOAT = 200
val JUMP-EQ-OPCODE-DOUBLE = 201
val JUMP-NE-OPCODE-REF = 202
val JUMP-NE-OPCODE-BYTE = 203
val JUMP-NE-OPCODE-INT = 204
val JUMP-NE-OPCODE-LONG = 205
val JUMP-NE-OPCODE-FLOAT = 206
val JUMP-NE-OPCODE-DOUBLE = 207
val JUMP-LT-OPCODE-INT = 208
val JUMP-LT-OPCODE-LONG = 209
val JUMP-LT-OPCODE-FLOAT = 210
val JUMP-LT-OPCODE-DOUBLE = 211
val JUMP-GT-OPCODE-INT = 212
val JUMP-GT-OPCODE-LONG = 213
val JUMP-GT-OPCODE-FLOAT = 214
val JUMP-GT-OPCODE-DOUBLE = 215
val JUMP-LE-OPCODE-INT = 216
val JUMP-LE-OPCODE-LONG = 217
val JUMP-LE-OPCODE-FLOAT = 218
val JUMP-LE-OPCODE-DOUBLE = 219
val JUMP-GE-OPCODE-INT = 220
val JUMP-GE-OPCODE-LONG = 221
val JUMP-GE-OPCODE-FLOAT = 222
val JUMP-GE-OPCODE-DOUBLE = 223
val JUMP-ULE-OPCODE-BYTE = 224
val JUMP-ULE-OPCODE-INT = 225
val JUMP-ULE-OPCODE-LONG = 226
val JUMP-ULT-OPCODE-BYTE = 227
val JUMP-ULT-OPCODE-INT = 228
val JUMP-ULT-OPCODE-LONG = 229
val JUMP-UGT-OPCODE-BYTE = 230
val JUMP-UGT-OPCODE-INT = 231
val JUMP-UGT-OPCODE-LONG = 232
val JUMP-UGE-OPCODE-BYTE = 233
val JUMP-UGE-OPCODE-INT = 234
val JUMP-UGE-OPCODE-LONG = 235
;dispatch operation
val DISPATCH-OPCODE = 236
val DISPATCH-METHOD-OPCODE = 237
;jump on register
val JUMP-REG-OPCODE = 238
;function entry
val FNENTRY-OPCODE = 239

defn set-reg-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-REG-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-REG-OPCODE-UNSIGNED
        (v:Byte) : SET-REG-OPCODE-UNSIGNED
        (v:Int) : SET-REG-OPCODE-UNSIGNED
        (v:Long) : SET-REG-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-REG-OPCODE-UNSIGNED
        (v:Double) : SET-REG-OPCODE-WIDE
    (y:Marker) : SET-REG-OPCODE-UNSIGNED
    (y:Tag) : SET-REG-OPCODE-UNSIGNED
    (y:CodeId) : SET-REG-OPCODE-CODE
    (y:ExternId) : SET-REG-OPCODE-WIDE
    (y:GlobalId) : SET-REG-OPCODE-GLOBAL
    (y:DataId) : SET-REG-OPCODE-DATA
    (y:ConstId) : SET-REG-OPCODE-CONST
    (y:VoidMarker) : SET-REG-OPCODE-UNSIGNED

defn set-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-OPCODE-UNSIGNED
        (v:Byte) : SET-OPCODE-UNSIGNED
        (v:Int) : SET-OPCODE-UNSIGNED
        (v:Long) : SET-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-OPCODE-UNSIGNED
        (v:Double) : SET-OPCODE-WIDE
    (y:Marker) : SET-OPCODE-UNSIGNED
    (y:Tag) : SET-OPCODE-UNSIGNED
    (y:CodeId) : SET-OPCODE-CODE
    (y:ExternId) : SET-OPCODE-WIDE
    (y:GlobalId) : SET-OPCODE-GLOBAL
    (y:DataId) : SET-OPCODE-DATA
    (y:ConstId) : SET-OPCODE-CONST
    (y:VoidMarker) : SET-OPCODE-UNSIGNED

defn call-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALL-OPCODE-LOCAL
    (f:CodeId) : CALL-OPCODE-CODE

defn callc-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALLC-OPCODE-LOCAL
    (f:ExternId) :  CALLC-OPCODE-WIDE

defn tcall-opcode (f:VMImm) :
  match(f) :
    (f:Local) : TCALL-OPCODE-LOCAL
    (f:CodeId) : TCALL-OPCODE-CODE

defn store-opcode (offset:VMImm|False, val-type:VMType) :
  match(offset, val-type) :
    (o:False, vt:VMByte) : STORE-OPCODE-1
    (o:False, vt:VMInt) : STORE-OPCODE-4
    (o:False, vt:VMLong) : STORE-OPCODE-8
    (o:False, vt:VMFloat) : STORE-OPCODE-4
    (o:False, vt:VMDouble) : STORE-OPCODE-8
    (o:False, vt:VMRef) : STORE-OPCODE-8
    (o:VMImm, vt:VMByte) : STORE-OPCODE-1-VAR-OFFSET
    (o:VMImm, vt:VMInt) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMLong) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMFloat) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMDouble) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMRef) : STORE-OPCODE-8-VAR-OFFSET

defn load-opcode (offset:VMImm|False, xtype:VMType) :
  match(offset, xtype) :
    (o:False, xt:VMByte) : LOAD-OPCODE-1
    (o:False, xt:VMInt) : LOAD-OPCODE-4
    (o:False, xt:VMLong) : LOAD-OPCODE-8
    (o:False, xt:VMFloat) : LOAD-OPCODE-4
    (o:False, xt:VMDouble) : LOAD-OPCODE-8
    (o:False, xt:VMRef) : LOAD-OPCODE-8
    (o:VMImm, xt:VMByte) : LOAD-OPCODE-1-VAR-OFFSET
    (o:VMImm, xt:VMInt) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMLong) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMFloat) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMDouble) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMRef) : LOAD-OPCODE-8-VAR-OFFSET

defn op0-opcode (op:VMOp) :
  match(op) :
    (op:FlushVMOp) : FLUSH-VM-OPCODE
    (op:CRSPOp) : C-RSP-OPCODE

;Returns false if operation becomes a set operation.
defn op1-opcode (op:VMOp, xt:VMType, yt:VMType) -> Int|False :
  match(op, xt, yt) :
    (op:IntNotOp, xt:VMRef, yt:VMRef) : INT-NOT-OPCODE
    (op:IntNegOp, xt:VMRef, yt:VMRef) : INT-NEG-OPCODE
    (op:NotOp, xt:VMByte, yt:VMByte) : NOT-OPCODE-BYTE
    (op:NotOp, xt:VMInt, yt:VMInt) : NOT-OPCODE-INT
    (op:NotOp, xt:VMLong, yt:VMLong) : NOT-OPCODE-LONG
    (op:NegOp, xt:VMInt, yt:VMInt) : NEG-OPCODE-INT
    (op:NegOp, xt:VMLong, yt:VMLong) : NEG-OPCODE-LONG
    (op:NegOp, xt:VMFloat, yt:VMFloat) : NEG-OPCODE-FLOAT
    (op:NegOp, xt:VMDouble, yt:VMDouble) : NEG-OPCODE-DOUBLE
    (op:InterpretOp, xt, yt) : false
    (op:ConvOp, xt:VMByte, yt:VMByte) : false
    (op:ConvOp, xt:VMByte, yt:VMInt) : false
    (op:ConvOp, xt:VMByte, yt:VMLong) : false
    (op:ConvOp, xt:VMByte, yt:VMFloat) : CONV-OPCODE-BYTE-FLOAT
    (op:ConvOp, xt:VMByte, yt:VMDouble) : CONV-OPCODE-BYTE-DOUBLE
    (op:ConvOp, xt:VMInt, yt:VMByte) : CONV-OPCODE-INT-BYTE
    (op:ConvOp, xt:VMInt, yt:VMInt) : false
    (op:ConvOp, xt:VMInt, yt:VMLong) : false
    (op:ConvOp, xt:VMInt, yt:VMFloat) : CONV-OPCODE-INT-FLOAT
    (op:ConvOp, xt:VMInt, yt:VMDouble) : CONV-OPCODE-INT-DOUBLE
    (op:ConvOp, xt:VMLong, yt:VMByte) : CONV-OPCODE-LONG-BYTE
    (op:ConvOp, xt:VMLong, yt:VMInt) : CONV-OPCODE-LONG-INT
    (op:ConvOp, xt:VMLong, yt:VMLong) : false
    (op:ConvOp, xt:VMLong, yt:VMFloat) : CONV-OPCODE-LONG-FLOAT
    (op:ConvOp, xt:VMLong, yt:VMDouble) : CONV-OPCODE-LONG-DOUBLE
    (op:ConvOp, xt:VMFloat, yt:VMByte) : CONV-OPCODE-FLOAT-BYTE
    (op:ConvOp, xt:VMFloat, yt:VMInt) : CONV-OPCODE-FLOAT-INT
    (op:ConvOp, xt:VMFloat, yt:VMLong) : CONV-OPCODE-FLOAT-LONG
    (op:ConvOp, xt:VMFloat, yt:VMFloat) : false
    (op:ConvOp, xt:VMFloat, yt:VMDouble) : CONV-OPCODE-FLOAT-DOUBLE
    (op:ConvOp, xt:VMDouble, yt:VMByte) : CONV-OPCODE-DOUBLE-BYTE
    (op:ConvOp, xt:VMDouble, yt:VMInt) : CONV-OPCODE-DOUBLE-INT
    (op:ConvOp, xt:VMDouble, yt:VMLong) : CONV-OPCODE-DOUBLE-LONG
    (op:ConvOp, xt:VMDouble, yt:VMFloat) : CONV-OPCODE-DOUBLE-FLOAT
    (op:ConvOp, xt:VMDouble, yt:VMDouble) : false
    (op:TagOp, xt, yt) :
      switch(type(op)) :
        BYTE-TYPE : TAG-OPCODE-BYTE
        CHAR-TYPE : TAG-OPCODE-CHAR
        INT-TYPE : TAG-OPCODE-INT
        FLOAT-TYPE : TAG-OPCODE-FLOAT
    (op:DetagOp, xt, yt) : DETAG-OPCODE
    (op:DerefOp, xt, yt) : DEREF-OPCODE
    (op:GCOp, xt, yt) : GC-OPCODE
    (op:ClassNameOp, xt, yt) : CLASS-NAME-OPCODE
    (op:PrintStackTraceOp, xt, yt) : PRINT-STACK-TRACE-OPCODE

defn op2-opcode (op:VMOp, xt:VMType, yt:VMType) :
  match(op, xt, yt) :
    (op:IntAddOp, xt:VMRef, yt:VMRef) : INT-ADD-OPCODE
    (op:IntSubOp, xt:VMRef, yt:VMRef) : INT-SUB-OPCODE
    (op:IntMulOp, xt:VMRef, yt:VMRef) : INT-MUL-OPCODE
    (op:IntDivOp, xt:VMRef, yt:VMRef) : INT-DIV-OPCODE
    (op:IntModOp, xt:VMRef, yt:VMRef) : INT-MOD-OPCODE
    (op:IntAndOp, xt:VMRef, yt:VMRef) : INT-AND-OPCODE
    (op:IntOrOp, xt:VMRef, yt:VMRef) : INT-OR-OPCODE
    (op:IntXorOp, xt:VMRef, yt:VMRef) : INT-XOR-OPCODE
    (op:IntShlOp, xt:VMRef, yt:VMRef) : INT-SHL-OPCODE
    (op:IntShrOp, xt:VMRef, yt:VMRef) : INT-SHR-OPCODE
    (op:IntAshrOp, xt:VMRef, yt:VMRef) : INT-ASHR-OPCODE
    (op:IntLtOp, xt:VMRef, yt:VMRef) : INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef, yt:VMRef) : INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef, yt:VMRef) : INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef, yt:VMRef) : INT-GE-OPCODE
    (op:EqOp, xt:VMRef, yt:VMRef) : EQ-OPCODE-REF-REF
    (op:EqOp, xt:VMLong, yt:VMRef) : EQ-OPCODE-REF
    (op:EqOp, xt:VMLong, yt:VMByte) : EQ-OPCODE-BYTE
    (op:EqOp, xt:VMLong, yt:VMInt) : EQ-OPCODE-INT
    (op:EqOp, xt:VMLong, yt:VMLong) : EQ-OPCODE-LONG
    (op:EqOp, xt:VMLong, yt:VMFloat) : EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMLong, yt:VMDouble) : EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef, yt:VMRef) : NE-OPCODE-REF-REF
    (op:NeOp, xt:VMLong, yt:VMRef) : NE-OPCODE-REF
    (op:NeOp, xt:VMLong, yt:VMByte) : NE-OPCODE-BYTE
    (op:NeOp, xt:VMLong, yt:VMInt) : NE-OPCODE-INT
    (op:NeOp, xt:VMLong, yt:VMLong) : NE-OPCODE-LONG
    (op:NeOp, xt:VMLong, yt:VMFloat) : NE-OPCODE-FLOAT
    (op:NeOp, xt:VMLong, yt:VMDouble) : NE-OPCODE-DOUBLE
    (op:AddOp, xt:VMByte, yt:VMByte) : ADD-OPCODE-BYTE
    (op:AddOp, xt:VMInt, yt:VMInt) : ADD-OPCODE-INT
    (op:AddOp, xt:VMLong, yt:VMLong) : ADD-OPCODE-LONG
    (op:AddOp, xt:VMFloat, yt:VMFloat) : ADD-OPCODE-FLOAT
    (op:AddOp, xt:VMDouble, yt:VMDouble) : ADD-OPCODE-DOUBLE
    (op:SubOp, xt:VMByte, yt:VMByte) : SUB-OPCODE-BYTE
    (op:SubOp, xt:VMInt, yt:VMInt) : SUB-OPCODE-INT
    (op:SubOp, xt:VMLong, yt:VMLong) : SUB-OPCODE-LONG
    (op:SubOp, xt:VMFloat, yt:VMFloat) : SUB-OPCODE-FLOAT
    (op:SubOp, xt:VMDouble, yt:VMDouble) : SUB-OPCODE-DOUBLE
    (op:MulOp, xt:VMByte, yt:VMByte) : MUL-OPCODE-BYTE
    (op:MulOp, xt:VMInt, yt:VMInt) : MUL-OPCODE-INT
    (op:MulOp, xt:VMLong, yt:VMLong) : MUL-OPCODE-LONG
    (op:MulOp, xt:VMFloat, yt:VMFloat) : MUL-OPCODE-FLOAT
    (op:MulOp, xt:VMDouble, yt:VMDouble) : MUL-OPCODE-DOUBLE
    (op:DivOp, xt:VMByte, yt:VMByte) : DIV-OPCODE-BYTE
    (op:DivOp, xt:VMInt, yt:VMInt) : DIV-OPCODE-INT
    (op:DivOp, xt:VMLong, yt:VMLong) : DIV-OPCODE-LONG
    (op:DivOp, xt:VMFloat, yt:VMFloat) : DIV-OPCODE-FLOAT
    (op:DivOp, xt:VMDouble, yt:VMDouble) : DIV-OPCODE-DOUBLE
    (op:ModOp, xt:VMByte, yt:VMByte) : MOD-OPCODE-BYTE
    (op:ModOp, xt:VMInt, yt:VMInt) : MOD-OPCODE-INT
    (op:ModOp, xt:VMLong, yt:VMLong) : MOD-OPCODE-LONG
    (op:AndOp, xt:VMByte, yt:VMByte) : AND-OPCODE-BYTE
    (op:AndOp, xt:VMInt, yt:VMInt) : AND-OPCODE-INT
    (op:AndOp, xt:VMLong, yt:VMLong) : AND-OPCODE-LONG
    (op:OrOp, xt:VMByte, yt:VMByte) : OR-OPCODE-BYTE
    (op:OrOp, xt:VMInt, yt:VMInt) : OR-OPCODE-INT
    (op:OrOp, xt:VMLong, yt:VMLong) : OR-OPCODE-LONG
    (op:XorOp, xt:VMByte, yt:VMByte) : XOR-OPCODE-BYTE
    (op:XorOp, xt:VMInt, yt:VMInt) : XOR-OPCODE-INT
    (op:XorOp, xt:VMLong, yt:VMLong) : XOR-OPCODE-LONG
    (op:ShlOp, xt:VMByte, yt:VMByte) : SHL-OPCODE-BYTE
    (op:ShlOp, xt:VMInt, yt:VMInt) : SHL-OPCODE-INT
    (op:ShlOp, xt:VMLong, yt:VMLong) : SHL-OPCODE-LONG
    (op:ShrOp, xt:VMByte, yt:VMByte) : SHR-OPCODE-BYTE
    (op:ShrOp, xt:VMInt, yt:VMInt) : SHR-OPCODE-INT
    (op:ShrOp, xt:VMLong, yt:VMLong) : SHR-OPCODE-LONG
    (op:AshrOp, xt:VMInt, yt:VMInt) : ASHR-OPCODE-INT
    (op:AshrOp, xt:VMLong, yt:VMLong) : ASHR-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMInt) : LT-OPCODE-INT
    (op:LtOp, xt:VMLong, yt:VMLong) : LT-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMFloat) : LT-OPCODE-FLOAT
    (op:LtOp, xt:VMLong, yt:VMDouble) : LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMLong, yt:VMInt) : GT-OPCODE-INT
    (op:GtOp, xt:VMLong, yt:VMLong) : GT-OPCODE-LONG
    (op:GtOp, xt:VMLong, yt:VMFloat) : GT-OPCODE-FLOAT
    (op:GtOp, xt:VMLong, yt:VMDouble) : GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMLong, yt:VMInt) : LE-OPCODE-INT
    (op:LeOp, xt:VMLong, yt:VMLong) : LE-OPCODE-LONG
    (op:LeOp, xt:VMLong, yt:VMFloat) : LE-OPCODE-FLOAT
    (op:LeOp, xt:VMLong, yt:VMDouble) : LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMLong, yt:VMInt) : GE-OPCODE-INT
    (op:GeOp, xt:VMLong, yt:VMLong) : GE-OPCODE-LONG
    (op:GeOp, xt:VMLong, yt:VMFloat) : GE-OPCODE-FLOAT
    (op:GeOp, xt:VMLong, yt:VMDouble) : GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMLong, yt:VMByte) : ULT-OPCODE-BYTE
    (op:UltOp, xt:VMLong, yt:VMInt) : ULT-OPCODE-INT
    (op:UltOp, xt:VMLong, yt:VMLong) : ULT-OPCODE-LONG
    (op:UleOp, xt:VMLong, yt:VMByte) : ULE-OPCODE-BYTE
    (op:UleOp, xt:VMLong, yt:VMInt) : ULE-OPCODE-INT
    (op:UleOp, xt:VMLong, yt:VMLong) : ULE-OPCODE-LONG
    (op:UgtOp, xt:VMLong, yt:VMByte) : UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMLong, yt:VMInt) : UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong, yt:VMLong) : UGT-OPCODE-LONG
    (op:UgeOp, xt:VMLong, yt:VMByte) : UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMLong, yt:VMInt) : UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong, yt:VMLong) : UGE-OPCODE-LONG

defn branch2-opcode (op:VMOp, xt:VMType) :
  match(op, xt) :
    (op:IntLtOp, xt:VMRef) : JUMP-INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef) : JUMP-INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef) : JUMP-INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef) : JUMP-INT-GE-OPCODE
    (op:EqOp, xt:VMRef) : JUMP-EQ-OPCODE-REF
    (op:EqOp, xt:VMByte) : JUMP-EQ-OPCODE-BYTE
    (op:EqOp, xt:VMInt) : JUMP-EQ-OPCODE-INT
    (op:EqOp, xt:VMLong) : JUMP-EQ-OPCODE-LONG
    (op:EqOp, xt:VMFloat) : JUMP-EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMDouble) : JUMP-EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef) : JUMP-NE-OPCODE-REF
    (op:NeOp, xt:VMByte) : JUMP-NE-OPCODE-BYTE
    (op:NeOp, xt:VMInt) : JUMP-NE-OPCODE-INT
    (op:NeOp, xt:VMLong) : JUMP-NE-OPCODE-LONG
    (op:NeOp, xt:VMFloat) : JUMP-NE-OPCODE-FLOAT
    (op:NeOp, xt:VMDouble) : JUMP-NE-OPCODE-DOUBLE
    (op:LtOp, xt:VMInt) : JUMP-LT-OPCODE-INT
    (op:LtOp, xt:VMLong) : JUMP-LT-OPCODE-LONG
    (op:LtOp, xt:VMFloat) : JUMP-LT-OPCODE-FLOAT
    (op:LtOp, xt:VMDouble) : JUMP-LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMInt) : JUMP-GT-OPCODE-INT
    (op:GtOp, xt:VMLong) : JUMP-GT-OPCODE-LONG
    (op:GtOp, xt:VMFloat) : JUMP-GT-OPCODE-FLOAT
    (op:GtOp, xt:VMDouble) : JUMP-GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMInt) : JUMP-LE-OPCODE-INT
    (op:LeOp, xt:VMLong) : JUMP-LE-OPCODE-LONG
    (op:LeOp, xt:VMFloat) : JUMP-LE-OPCODE-FLOAT
    (op:LeOp, xt:VMDouble) : JUMP-LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMInt) : JUMP-GE-OPCODE-INT
    (op:GeOp, xt:VMLong) : JUMP-GE-OPCODE-LONG
    (op:GeOp, xt:VMFloat) : JUMP-GE-OPCODE-FLOAT
    (op:GeOp, xt:VMDouble) : JUMP-GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMByte) : JUMP-ULT-OPCODE-BYTE
    (op:UltOp, xt:VMInt) : JUMP-ULT-OPCODE-INT
    (op:UltOp, xt:VMLong) : JUMP-ULT-OPCODE-LONG
    (op:UleOp, xt:VMByte) : JUMP-ULE-OPCODE-BYTE
    (op:UleOp, xt:VMInt) : JUMP-ULE-OPCODE-INT
    (op:UleOp, xt:VMLong) : JUMP-ULE-OPCODE-LONG
    (op:UgtOp, xt:VMByte) : JUMP-UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMInt) : JUMP-UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong) : JUMP-UGT-OPCODE-LONG
    (op:UgeOp, xt:VMByte) : JUMP-UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMInt) : JUMP-UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong) : JUMP-UGE-OPCODE-LONG
