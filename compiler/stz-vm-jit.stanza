defpackage stz/vm-jit :
  import core
  import collections
  import stz/vm-ir
  import stz/typeset
  import stz/vm-ids
  import stz/basic-ops
  import stz/call-records
  import stz/backend
  import stz/utils
  import stz/set-utils
  import stz/conversion-utils
  import stz/dispatch-dag
  import stz/asmjit
  import core/stack-trace

;VM-JIT
;
;This is a version of stz-vm-encoder.stanza that replaces only the last step of
;encoding instructions for the VM with AsmJITing those instructions into the x86
;assembly code that implements the CVM instruction defined in cvm.c
;In particular it uses exactly the same vmstate structures with
;the following minor differences:
;o caches fewer fields in registers to conserve x86 registers
;o caches first few VM registers and locals in x86 registers
;o uses ASMJit labels instead of buffer positions
;o uses ASMJit Funcs for functions instead of buffer positions

;Configuration

val local-regs? = false  ;Use x86 registers for first few vm locals?
val reg-regs? = false    ;Use x86 registers for first few vm registers?
val debugging? = false   ;General debugging output?
val tracing? = false     ;Tracing execution of vm instructions and writes?

;Resolver api and structures

extern c_trampoline: (ptr<?>, ptr<?>, ptr<?>) -> int

public deftype EncodingResolver
public defmulti liveness-map (r:EncodingResolver, live:Tuple<Int>, num-locals:Int) -> Int
public defmulti object-header-size (r:EncodingResolver) -> Int
public defmulti object-size-on-heap (r:EncodingResolver, sz:Int) -> Int
public defmulti stack-size (r:EncodingResolver) -> Int
public defmulti dispatch-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti match-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti method-format (r:EncodingResolver, multi:Int, num-header-args:Int, num-args:Int) -> Int
public defmulti marker (r:EncodingResolver, type:Int) -> Int
public defmulti void-marker (r:EncodingResolver) -> Int
public defmulti ref-offset (r:EncodingResolver) -> Int
public defmulti type-is-final? (r:EncodingResolver, n:Int) -> True|False
public defmulti marker? (r:EncodingResolver, n:Int) -> True|False
public defmulti tagbits (r:EncodingResolver, typeid:Int) -> Int

public defstruct EncodedFunction :
  func: Func ;JITd function
  trace-entries: Vector<TraceTableEntry>

public defstruct TraceTableEntry :
  pc: Int
  entry: StackTraceEntry

public defn value (ef:EncodedFunction) -> Long :
  value(func(ef))
  
;Low level calling mechanisms

;C calling convention registers for passing arguments
defn c-params () : [rdi(), rsi(), rdx(), rcx(), r8(), r9()]

;Bind args in registers onto c calling convention arg registers
defn bind-parameters (a:Assembler, sargs:Seqable<Gp>) :
  val params = c-params()
  val args   = to-tuple $ sargs
  if length(args) > length(params) :
    fatal("Too many arguments for C calling convention registers")
  for (param in params, arg in args) do :
    mov(a, param, arg)

;Call C function faddr with args saving specd registers
lostanza defn do-c-call (a:ref<Assembler>, saved-registers:Tuple<Gp>, faddr:ref<Long>, args:ref<Tuple<Gp>>) -> ref<Gp> :
  save-registers(a, saved-registers)
  bind-parameters(a, args)
  mov(a, tmp1(), faddr)
  call(a, tmp1())
  restore-registers(a, saved-registers)
  return rax()

lostanza defn stanza-call (a:ref<Assembler>, faddr:ref<Long>, args:ref<Tuple<Gp>>) -> ref<Gp> :
  return do-c-call(a, stanza-caller-saved-registers, faddr, args)

lostanza defn c-call (a:ref<Assembler>, faddr:ref<Long>, args:ref<Tuple<Gp>>) -> ref<Gp> :
  return do-c-call(a, c-caller-saved-registers, faddr, args)

lostanza defn c-trampoline-addr () -> ref<Long> :
  return new Long{addr!(c_trampoline) as long}

defn c-trampoline (a:Assembler, faddr:Gp, registers:Gp, returns:Gp) :
  stanza-call(a, c-trampoline-addr(), [faddr, registers, returns])

extern read_dispatch_table: (ptr<?>, int) -> int
extern print_dispatch_time: () -> int

lostanza defn read-dispatch-table-addr () -> ref<Long> :
  return new Long{addr!(read_dispatch_table) as long}

defn read-dispatch-table (a:Assembler, dst:Gp, vmstate:Gp, format:Gp) -> Gp :
  c-call(a, read-dispatch-table-addr(), [vmstate, format])
  mov(a, dst, rax())
  dst

extern call_garbage_collector: (ptr<?>, long) -> int

lostanza defn call-garbage-collector-addr () -> ref<Long> :
  return new Long{addr!(call_garbage_collector) as long}

defn call-garbage-collector (a:Assembler, vmstate:Gp, size:Gp) -> Gp :
  stanza-call(a, call-garbage-collector-addr(), [vmstate, size])

extern call_print_stack_trace: (ptr<?>, long) -> int

lostanza defn call-print-stack-trace-addr () -> ref<Long> :
  return new Long{addr!(call_print_stack_trace) as long}

defn call-print-stack-trace (a:Assembler, vmstate:Gp, stack:Gp) -> Gp :
  stanza-call(a, call-print-stack-trace-addr(), [vmstate, stack])

extern call_collect_stack_trace: (ptr<?>, long) -> int

lostanza defn call-collect-stack-trace-addr () -> ref<Long> :
  return new Long{addr!(call_collect_stack_trace) as long}

defn call-collect-stack-trace (a:Assembler, vmstate:Gp, stack:Gp) -> Gp :
  stanza-call(a, call-collect-stack-trace-addr(), [vmstate, stack])

extern retrieve_class_name: (ptr<?>, long) -> int

lostanza defn retrieve-class-name-addr () -> ref<Long> :
  return new Long{addr!(retrieve_class_name) as long}

defn retrieve-class-name (a:Assembler, vmstate:Gp, stack:Gp) -> Gp :
  stanza-call(a, retrieve-class-name-addr(), [vmstate, stack])

;Primitive byte sizes

val SIZEOF-BYTE = 1
val SIZEOF-INT  = 4
val SIZEOF-LONG = 8

;VMState generic accessors

defn vmstate-get (a:Assembler, offset:Int, dst:Gp) -> Gp :
  mov(a, dst, MemPtr(vmstate(), offset))
defn vmstate-get (a:Assembler, offset:Int) -> Gp :
  vmstate-get(a, offset, rcx())

defn vmstate-set (a:Assembler, offset:Int, value:Gp) :
  mov(a, MemPtr(vmstate(), offset), value)

;VMState field offsets
val vmstate-offsets = Counter(0)
val VMSTATE-INSTRUCTIONS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-REGISTERS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-GLOBAL-OFFSETS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-GLOBAL-MEM-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-CONST-TABLE-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-CONST-MEM-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-DATA-OFFSETS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-DATA-MEM-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-FUNCTIONS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-HEAP-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-HEAP-TOP-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-HEAP-LIMIT-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-FREE-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-FREE-LIMIT-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-CURRENT-STACK-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-SYSTEM-STACK-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-SYSTEM-REGISTERS-OFFSET = next(vmstate-offsets, SIZEOF-LONG)
val VMSTATE-TRIE-TABLE-OFFSET = next(vmstate-offsets, SIZEOF-LONG)

;VMState accessors
defn get-instructions (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-INSTRUCTIONS-OFFSET, dst)
defn set-instructions (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-INSTRUCTIONS-OFFSET, value)
defn get-registers (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-REGISTERS-OFFSET, dst)
defn set-registers (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-REGISTERS-OFFSET, value)
defn get-global-offsets (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-GLOBAL-OFFSETS-OFFSET, dst)
defn set-global-offsets (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-GLOBAL-OFFSETS-OFFSET, value)
defn get-global-mem (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-GLOBAL-MEM-OFFSET, dst)
defn set-global-mem (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-GLOBAL-MEM-OFFSET, value)
defn get-const-table (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-CONST-TABLE-OFFSET, dst)
defn set-const-table (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-CONST-TABLE-OFFSET, value)
defn get-const-mem (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-CONST-MEM-OFFSET, dst)
defn set-const-mem (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-CONST-MEM-OFFSET, value)
defn get-data-offsets (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-DATA-OFFSETS-OFFSET, dst)
defn set-data-offsets (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-DATA-OFFSETS-OFFSET, value)
defn get-data-mem (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-DATA-MEM-OFFSET, dst)
defn set-data-mem (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-DATA-MEM-OFFSET, value)
defn get-functions (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-FUNCTIONS-OFFSET, dst)
defn set-functions (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-FUNCTIONS-OFFSET, value)
defn get-heap (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-HEAP-OFFSET, dst)
defn set-heap (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-HEAP-OFFSET, value)
defn get-heap-top (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-HEAP-TOP-OFFSET, dst)
defn set-heap-top (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-HEAP-TOP-OFFSET, value)
defn get-heap-limit (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-HEAP-LIMIT-OFFSET, dst)
defn set-heap-limit (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-HEAP-LIMIT-OFFSET, value)
defn get-free (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-FREE-OFFSET, dst)
defn set-free (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-FREE-OFFSET, value)
defn get-free-limit (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-FREE-LIMIT-OFFSET, dst)
defn set-free-limit (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-FREE-LIMIT-OFFSET, value)
defn get-current-stack (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-CURRENT-STACK-OFFSET, dst)
defn set-current-stack (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-CURRENT-STACK-OFFSET, value)
defn get-system-stack (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-SYSTEM-STACK-OFFSET, dst)
defn set-system-stack (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-SYSTEM-STACK-OFFSET, value)
defn get-system-registers (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-SYSTEM-REGISTERS-OFFSET, dst)
defn set-system-registers (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-SYSTEM-REGISTERS-OFFSET, value)
defn get-trie-table (a:Assembler, dst:Gp) : vmstate-get(a, VMSTATE-TRIE-TABLE-OFFSET, dst)
defn set-trie-table (a:Assembler, value:Gp) : vmstate-set(a, VMSTATE-TRIE-TABLE-OFFSET, value)

;Stack Frame accessors

defn stack-frame-get (a:Assembler, offset:Int, dst:Gp) -> Gp :
  mov(a, dst, MemPtr(stack-pointer(), offset))
  dst
defn stack-frame-get (a:Assembler, offset:Int) -> Gp :
  stack-frame-get(a, offset, rcx())

defn stack-frame-set (a:Assembler, offset:Int, value:Gp) :
  mov(a, MemPtr(stack-pointer(), offset), value)

val stack-frame-offsets = Counter(0)
val STACK-FRAME-RETURN-OFFSET = next(stack-frame-offsets, SIZEOF-LONG)
val STACK-FRAME-LIVENESS-MAP-OFFSET = next(stack-frame-offsets, SIZEOF-LONG)
val SIZEOF-STACK-FRAME = value(stack-frame-offsets)
val STACK-FRAME-SLOTS-OFFSET = next(stack-frame-offsets, SIZEOF-LONG)

defn get-return (a:Assembler, dst:Gp) : stack-frame-get(a, STACK-FRAME-RETURN-OFFSET, dst)
defn set-return (a:Assembler, value:Gp) : stack-frame-set(a, STACK-FRAME-RETURN-OFFSET, value)
defn get-liveness-map (a:Assembler, dst:Gp) : stack-frame-get(a, STACK-FRAME-LIVENESS-MAP-OFFSET, dst)
defn set-liveness-map (a:Assembler, value:Gp) : stack-frame-set(a, STACK-FRAME-LIVENESS-MAP-OFFSET, value)
; defn get-slots (a:Assembler, dst:Gp) : stack-frame-get(a, STACK-FRAME-SLOTS-OFFSET, dst)
; defn set-slots (a:Assembler, value:Gp) : stack-frame-set(a, STACK-FRAME-SLOTS-OFFSET, value)

;Stack accessors

defn stack-get (a:Assembler, offset:Int, dst:Gp) -> Gp :
  mov(a, dst, MemPtr(stk(), offset))
  dst
defn stack-get (a:Assembler, offset:Int) -> Gp :
  stack-get(a, offset, rcx())

defn stack-set (a:Assembler, offset:Int, value:Gp) :
  mov(a, MemPtr(stk(), offset), value)

val stack-offsets = Counter(0)
val STACK-SIZE-OFFSET = next(stack-offsets, SIZEOF-LONG)
val STACK-FRAMES-OFFSET = next(stack-offsets, SIZEOF-LONG)
val STACK-STACK-POINTER-OFFSET = next(stack-offsets, SIZEOF-LONG)
val STACK-PC-OFFSET = next(stack-offsets, SIZEOF-LONG)

defn get-size (a:Assembler, dst:Gp) : stack-get(a, STACK-SIZE-OFFSET, dst)
defn set-size (a:Assembler, value:Gp) : stack-set(a, STACK-SIZE-OFFSET, value)
defn get-frames (a:Assembler, dst:Gp) : stack-get(a, STACK-FRAMES-OFFSET, dst)
defn set-frames (a:Assembler, value:Gp) : stack-set(a, STACK-FRAMES-OFFSET, value)
defn get-stack-pointer (a:Assembler, dst:Gp) : stack-get(a, STACK-STACK-POINTER-OFFSET, dst)
defn set-stack-pointer (a:Assembler, value:Gp) : stack-set(a, STACK-STACK-POINTER-OFFSET, value)
defn get-pc (a:Assembler, dst:Gp) : stack-get(a, STACK-PC-OFFSET, dst)
defn set-pc (a:Assembler, value:Gp) : stack-set(a, STACK-PC-OFFSET, value)

defn untag-stack (a:Assembler, dst:Gp, stk:Gp) -> Gp :
  lea(a, dst, MemPtr(stk, 8 - 1))
defn untag-stack (a:Assembler, stk:Gp) -> Gp :
  untag-stack(a, tmp1(), stk)

;Function accessors

val function-offsets = Counter(0)
val FUNCTION-NUM-SLOTS-OFFSET = next(function-offsets, SIZEOF-LONG)
val FUNCTION-CODE-OFFSET = next(function-offsets, SIZEOF-LONG)
val FUNCTION-SLOTS-OFFSET = next(function-offsets, SIZEOF-LONG)

;Register map

;Registers to cache VMState and crucial fields
defn vmstate () :        r8()
defn registers () :      r9()
defn stack-pointer () :  r10()
defn stk () :            r11()
defn functions () :      r12()

;Temporary registers for implementing and local to VM instructions
defn tmp1 () :           rbx()
defn tmp1i () :          ebx()
defn tmp1b () :          bl()
defn tmp2 () :           rsi()
defn tmp2i () :          esi()
defn tmp2b () :          sil()
defn tmp3 () :           rdi()
defn tmp3i () :          edi()
defn tmp3b () :          dil()

defn tmp-regs () : [tmp1(), tmp2(), tmp3()]

;x86 register caching of VM locals

defn loc1 () :           r13()
defn loc2 () :           r14()
defn loc3 () :           r15()

defn local-regs () : [loc1(), loc2(), loc3()] when local-regs? else []
defn num-local-regs () : length(local-regs())

;x86 register caching of VM registers

;dynamic variable that determines whether reg is accessed through memory
var MEM-REG-ONLY?:True|False = false 

defn reg1 () :           rcx()
defn reg2 () :           rdx()
; defn reg3 () :           rax() ;doesn't work because corrupted

defn reg-regs () : [reg1(), reg2()] when reg-regs? else []
defn num-reg-regs () : length(reg-regs())

;calling convention registers to save/restore

defn c-caller-saved-registers () : [r8(), r9(), r10(), r11()]
defn stanza-caller-saved-registers () : cat([vmstate(), registers(), functions(), stack-pointer(), stk()], local-regs())
defn etc-saved-registers () : stanza-caller-saved-registers()
defn low-saved-registers () : [rbx(), rcx(), rsi(), rdi() rdx()]
defn all-saved-registers () : cat(low-saved-registers(), stanza-caller-saved-registers())

defn save-registers (a:Assembler, regs:Seqable<Gp>) :
  for reg in regs do : push(a, reg)

defn restore-registers (a:Assembler, regs:Seqable<Gp>) :
  for reg in reverse $ to-list $ regs do : pop(a, reg)

defn etc-save-registers (a:Assembler) : save-registers(a, etc-saved-registers())
defn etc-restore-registers (a:Assembler) : restore-registers(a, etc-saved-registers())

defn stanza-caller-save-registers (a:Assembler) : save-registers(a, stanza-caller-saved-registers())
defn stanza-caller-restore-registers (a:Assembler) : restore-registers(a, stanza-caller-saved-registers())

defn c-caller-save-registers (a:Assembler) : save-registers(a, c-caller-saved-registers())
defn c-caller-restore-registers (a:Assembler) : restore-registers(a, c-caller-saved-registers())

defn all-save-registers (a:Assembler) : save-registers(a, all-saved-registers())
defn all-restore-registers (a:Assembler) : restore-registers(a, all-saved-registers())

defn local-save-registers (a:Assembler) : save-registers(a, local-regs())
defn local-restore-registers (a:Assembler) : restore-registers(a, local-regs())

;Tagging

val INT-TAG-BITS = 0
val REF-TAG-BITS = 1
val MARKER-TAG-BITS = 2
val BYTE-TAG-BITS = 3
val CHAR-TAG-BITS = 4
val FLOAT-TAG-BITS = 5

defn do-BOOLREF (a:Assembler, x:Gp) -> Gp :
  shl(a, x, 3)
  add(a, x, MARKER-TAG-BITS)
  x

;Debugging mechanism

;TODO: should be moved to core.stanza
defn hex (n:Long) -> String :
  var chars:List<Char> = List()
  let loop (n:Long = n) :
    if n != 0L :
      val temp = to-int(n % 16L)
      val c = to-char(temp + 48) when (temp < 10) else to-char(temp + 55)
      chars = cons(c, chars)
      loop(n / 16L)
  val buf = StringBuffer()
  add-all(buf, chars)
  to-string(buf)

defn hex (n:Int) -> String : hex(to-long(n))

defn plop (x) : println(x) when debugging?

extern malloc: (long) -> ptr<?>
extern strcpy: (ptr<byte>, ptr<byte>) -> ptr<?>
extern printf: (ptr<byte>, ? ...) -> int

lostanza defn printf-format (s:ref<String>) -> ref<Long> :
  val n = length(s)
  val d = call-c malloc(n.value + 1)
  call-c strcpy(d, addr!(s.chars))
  return new Long{d as long}

lostanza defn printf-addr () -> ref<Long> :
  return new Long{addr!(printf) as long}

defn dump (a:Assembler, format:String, a0:Gp, a1:Gp, a2:Gp, a3:Gp) :
  all-save-registers(a)
  mov(a, r8(),  printf-format(format))
  mov(a, r9(),  a0)
  mov(a, r10(), a1)
  mov(a, r11(), a2)
  mov(a, r12(), a3)
  mov(a, rdi(), r8())
  mov(a, rsi(), r9())
  mov(a, rdx(), r10())
  mov(a, rcx(), r11())
  mov(a, r8(),  r12())
  mov(a, rax(), 0L)
  mov(a, tmp1(), printf-addr())
  call(a, tmp1())
  all-restore-registers(a)

defn dump (a:Assembler, format:String) : dump(a, format, rax(), rax(), rax(), rax())
defn dump (a:Assembler, format:String, a0:Gp) : dump(a, format, a0, rax(), rax(), rax())
defn dump (a:Assembler, format:String, a0:Gp, a1:Gp) : dump(a, format, a0, a1, rax(), rax())
defn dump (a:Assembler, format:String, a0:Gp, a1:Gp, a2:Gp) : dump(a, format, a0, a1, a2, rax())

extern dump_registers: () -> int

lostanza defn dump-registers (a:ref<Assembler>) -> ref<False> :
  stanza-caller-save-registers(a)
  mov(a, tmp1(), new Long{addr!(dump_registers) as long})
  call(a, tmp1())
  stanza-caller-restore-registers(a)
  return false

extern dump_memory_8: (ptr<long>, int) -> int

lostanza defn dump-memory-8-addr () -> ref<Long> :
  return new Long{addr!(dump_memory_8) as long}

extern dump_memory_32: (ptr<int>, int) -> int

lostanza defn dump-memory-32-addr () -> ref<Long> :
  return new Long{addr!(dump_memory_32) as long}

extern dump_memory_64: (ptr<long>, int) -> int

lostanza defn dump-memory-64-addr () -> ref<Long> :
  return new Long{addr!(dump_memory_64) as long}

lostanza defn dump-memory-x (a:ref<Assembler>, faddr:ref<Long>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  stanza-caller-save-registers(a)
  mov(a, rdi(), start)
  mov(a, rsi(), n)
  mov(a, rax(), new Long{0L})
  mov(a, tmp1(), faddr)
  call(a, tmp1())
  stanza-caller-restore-registers(a)
  return false

lostanza defn dump-memory-8 (a:ref<Assembler>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  return dump-memory-x(a, dump-memory-8-addr(), start, n)

lostanza defn dump-memory-32 (a:ref<Assembler>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  return dump-memory-x(a, dump-memory-32-addr(), start, n)

lostanza defn dump-memory-64 (a:ref<Assembler>, start:ref<Gp>, n:ref<Long>) -> ref<False> :
  return dump-memory-x(a, dump-memory-64-addr(), start, n)

defn dump-stack-frame (a:Assembler, sp:Gp) :
  dump(a, "STACK-FRAME:\n") when debugging?
  dump-memory-64(a, sp, 3L) when debugging?

defn dump-state (a:Assembler, msg:String) :
  dump(a, msg)
  dump-memory-64(a, vmstate(), 16L)
  dump(a, "REGISTERS:     %p\n", registers())
  dump(a, "STK:           %p\n", stk())
  dump(a, "STACK-POINTER: %p\n", stack-pointer())
  ; dump-memory-64(a, stack-pointer(), 6L)

defn dump-stack-state (a:Assembler, msg:String) :
  dump(a, msg)
  dump(a, "CURRENT-STACK: %p\n", get-current-stack(a, rax()))
  dump(a, "SYSTEM-STACK:  %p\n", get-system-stack(a, rax()))
  dump(a, "STK:           %p\n", stk())
  dump(a, "STACK-POINTER: %p\n", stack-pointer())
  dump(a, "STACK-LIMIT:   %p\n", compute-stack-limit(a, rax()))
  ; dump-memory-64(a, stack-pointer(), 6L)

;Entry point for launching JIT session from stz-vm.stanza
;Used for initiated REPL call or stz-extern callback

public defn make-jit-launch (rt:JitRuntime, vms:Long) -> Func :
  within (code, a) = gen-code(rt) :
    ; Setup JIT registers
    val out? = debugging? ; or tracing?
    mov(a, tmp1(), c-params()[0])  ;CRSP is first C argument
    push(a, tmp1())                ;Pushing CRSP for access from crsp instruction 
    val init-id = mov(a, tmp3(), c-params()[1]) ;Init ID is second C argument
    mov(a, tmp1(), MemPtr(rsp(), 0))
    mov(a, vmstate(), vms)                              ;Cache VMState
    get-registers(a, registers())                       ;Cache registers
    get-functions(a, functions())                       ;Cache functions
    untag-stack(a, stk(), get-current-stack(a, tmp1())) ;Cache stk
    get-stack-pointer(a, stack-pointer())               ;Cache stack pointer
    val ret-label = new-label(a)
    lea(a, tmp2(), MemPtr(ret-label))
    set-return(a, tmp2())         ;Set return address in current frame
    mov(a, tmp1(), MemPtr(functions(), init-id, 3, 0)) ;Load initial function
    jmp(a, tmp1())                ;Launch!
    bind(a, ret-label)            ;Return address     
    SAVE-STATE-ONLY(a)            ;save from cache
    pop(a, tmp1())                ;POPPING CRSP
    ret(a)

;Accesses and state saving/restoring

defn CONST (a:Assembler, x:Gp, id:Int|Long) -> Gp :
  mov(a, x, id)

;Addressing for register from registers vector
defn reg-mem-access (r:Int) -> MemPtr :
  MemPtr(registers(), r * SIZEOF-LONG)    
;Access register from registers vector or x86 register if possible with mem-only? override
defn reg-access (r:Int, mem-only?:True|False) -> Gp|MemPtr :
  reg-mem-access(r) when (mem-only? or r >= num-reg-regs()) else reg-regs()[r]
;Set register into registers vector or x86 register if possible with mem-only? override
defn do-SET-REG (a:Assembler, r:Int, v:Gp, mem-only?:True|False) -> False :
  mov(a, reg-access(r, mem-only?), v)
  dump(a, "  SET-REG[%d,%d] = %p\n", CONST(a, tmp2(), r), CONST(a, tmp3(), 1 when mem-only? else 0), v) when tracing?
  false

;Save/Restore to VMState
defn SAVE-STATE-ONLY (a:Assembler) :
  set-stack-pointer(a, stack-pointer())

defn SAVE-STATE (a:Assembler) :
  SAVE-STATE-ONLY(a)
  etc-save-registers(a)

defn RESTORE-STATE (a:Assembler) :
  etc-restore-registers(a)
  untag-stack(a, stk(), get-current-stack(a, tmp1()))
  get-stack-pointer(a, stack-pointer())

;Addressing for local from locals in stack frame
defn local-mem-access (l:Int) -> MemPtr :
  MemPtr(stack-pointer(), l * SIZEOF-LONG + STACK-FRAME-SLOTS-OFFSET)    

;Save x86 register cache to memory vector for VM locals
defn save-local-registers (a:Assembler) :
  for i in 0 to num-local-regs() do :
    ; dump(a, "SAVING LREG[%d] %p\n", CONST(rax(), i), local-regs()[i])
    mov(a, local-mem-access(i), local-regs()[i])

;Restore x86 register cache from memory vector for VM locals
defn restore-local-registers (a:Assembler) :
  for i in 0 to num-local-regs() do :
    mov(a, local-regs()[i], local-mem-access(i))
    ; dump(a, "RESTORING LREG[%d] %p\n", CONST(rax(), i), local-regs()[i])

;Stack extension support

;Swap current and system state to allow for execution on system stack etc
defn swap-current-and-system-state (a:Assembler) :
  get-current-stack(a, tmp1())
  set-current-stack(a, get-system-stack(a, rax()))
  set-system-stack(a, tmp1())
  set-registers(a, get-system-registers(a, rax()))
  set-system-registers(a, registers())
  ;Restore stack state
  untag-stack(a, stk(), get-current-stack(a, tmp1()))
  get-stack-pointer(a, stack-pointer())
  get-registers(a, registers())

;JIT Trampoline for extending stack called from function when stack overflow is detected
;in FNENTRY instruction.  Must switch to system state, save state, and then call extend-stack
public defn make-extend-stack-launch (rt:JitRuntime, stack-overflow-return:Func) -> Func : 
  within (code, a) = gen-code(rt) :
    val end-label     = tmp2()
    val size-required = tmp3()
    ;Save current stack
    set-stack-pointer(a, stack-pointer())
    set-pc(a, end-label)
    ;Swap stack and registers
    save-local-registers(a)
    swap-current-and-system-state(a)
    ;Set arguments
    get-frames(a, stack-pointer())
    set-return(a, CONST(a, tmp1(), value(stack-overflow-return)))
    do-SET-REG(a, 0, do-BOOLREF(a, CONST(a, tmp1(), 0)), false)
    do-SET-REG(a, 1, CONST(a, tmp1(), 1), false)
    do-SET-REG(a, 2, size-required, false)
    mov(a, tmp2(), MemPtr(functions(), SIZEOF-LONG * EXTEND-STACK-FN))
    jmp(a, tmp2())

;JIT Function for returning from stack extension and returning to FNENTRY VM instruction
;by switch back to user stack and restoring state
public defn make-extend-stack-return (rt:JitRuntime) -> Func :
  within (code, a) = gen-code(rt) :
    ;System stack no longer needed
    set-stack-pointer(a, CONST(a, tmp1(), 0))
    ;Swap stack and registers
    swap-current-and-system-state(a)
    restore-local-registers(a)
    ;Continue where we were
    get-pc(a, tmp2())
    jmp(a, tmp2())

defn compute-stack-limit (a:Assembler, dst:Gp) -> Gp :
  get-frames(a, dst)
  get-size(a, tmp1())
  add(a, dst, tmp1())
  dst

;VM Instruction coverage for testing

val covered = IntSet()
public defn opcode-coverage () -> IntSet : covered

;Encode function aka JITting
;Encoding is as similar as possible to encode in stz-vm-encoding.stanza
;  except for the use of labels instead of buffer offsets

public defn encode (fid:Int, func:VMFunction,
                    rt:JitRuntime,
                    resolver:EncodingResolver,
                    extend-stack-launch:Func,
                    extend-stack-return:Func,
                    backend:Backend) -> EncodedFunction :
  val extend-stack-launch-value = value(extend-stack-launch)
  val trace-entry-table = Vector<TraceTableEntry>()
  val f = within (code, a) = gen-code(rt) :
    plop("--- ENCODING %_" % [fid])

    defn CONST (x:Gp, id:Int|Long) -> Gp : (mov(a, x, to-long(id)), x)
    defn CONST (id:Int|Long) -> Gp : CONST(tmp1(), id)
    defn BOOLREF (x:Gp) -> Gp : do-BOOLREF(a, x)

    defn stack-limit (dst:Gp) :    compute-stack-limit(a, dst)
    defn heap-top (dst:Gp) :       get-heap-top(a, dst)
    defn heap-limit (dst:Gp) :     get-heap-limit(a, dst)
    defn global-offsets (dst:Gp) : get-global-offsets(a, dst)
    defn global-mem (dst:Gp) :     get-global-mem(a, dst)
    defn data-offsets (dst:Gp) :   get-data-offsets(a, dst)
    defn data-mem (dst:Gp) :       get-data-mem(a, dst)
    defn const-table (dst:Gp) :    get-const-table(a, dst)
    defn const-mem (dst:Gp) :      get-const-mem(a, dst)

    ;Encode instructions into this byte buffer
    defn buffer-pos () : 0 ;TODO: REMOVE

    ;Accumulate file information entries for implementing
    ;stack traces.
    defn record-trace-entry (entry:StackTraceEntry|False) :
      match(entry:StackTraceEntry) :
        dump(a, "+++ %s\n", CONST(tmp1(), printf-format(to-string(entry)))) when debugging?
        add(trace-entry-table, TraceTableEntry(buffer-pos(), entry))

    ;Calculation of sizes
    defn object-size (num-obj:Int, size-on-heap:Int) :
      num-obj * object-header-size(resolver) + size-on-heap
    defn stack-size () :
      object-size(1, /stack-size(resolver))

    ;Split a tuple of VMBranch into typesets and destinations
    defn split-types-and-dests (bs:Tuple<VMBranch>) -> [Tuple<Tuple<TypeSet>>, Tuple<Int>] :
      val types = map(types, bs)
      val targets = map(n, bs)
      [types, targets]

    ;Check whether type is final.
    ;If the function returns true, it means that the type cannot be redefined.
    defn type-is-final? (t:TypeSet) :
      match(t) :
        (t:SingleType) : /type-is-final?(resolver, type(t))
        (t:OrType) : all?(type-is-final?, types(t))
        (t:AndType) : any?(type-is-final?, types(t))
        (t:TopType) : true

    ;Check whether all types in branch are final.
    defn branch-is-final? (b:VMBranch) :
      all?(type-is-final?, types(b))

    defn GET-CRSP (dst:Gp) -> Gp :
      mov(a, dst, MemPtr(rsp(), 0))

    ;VM register accesses

    defn GET-REG (dst:Gp, r:Int, mem-only?:True|False) -> Gp :
      mov(a, dst, reg-access(r, mem-only?))
      dump(a, "  GET-REG[%d,%d] = %p\n", CONST(tmp2(), r), CONST(tmp3(), 1 when mem-only? else 0), dst) when tracing?
      dst
    defn GET-REG (dst:Gp, r:Int) -> Gp :
      GET-REG(dst, r, MEM-REG-ONLY?)

    defn SET-REG (r:Int, v:Gp, mem-only?:True|False) -> False :
      do-SET-REG(a, r, v, mem-only?)
    defn SET-REG (r:Int, v:Gp) -> False :
      SET-REG(r, v, MEM-REG-ONLY?)
    defn SET-REG-INT (r:Int, v:Gp, mem-only?:True|False) -> False :
      movsxd(a, v, v)
      SET-REG(r, v, mem-only?)
    defn SET-REG-INT (r:Int, v:Gp) -> False :
      SET-REG-INT(r, v, MEM-REG-ONLY?)

    ;VM local accesses
    
    defn gp (reg:Gp, size:Int) -> Gp :
      switch(size) :
        SIZEOF-BYTE : gp8(reg)
        SIZEOF-INT  : gp32(reg)
        SIZEOF-LONG : gp64(reg)

    defn local-access (l:Int) -> Gp|MemPtr :
      local-regs()[l] when (l < num-local-regs()) else local-mem-access(l)

    ;Local setters
    
    defn SET-LOCAL (l:Int, v:Gp) :
      mov(a, local-access(l), v)
      dump(a, "  SET-LOCAL[%d] = %p\n", CONST(rax(), l), v) when (debugging? or tracing?)
    defn SET-LOCAL-BYTE (l:Int, v:Gp) :
      and-op(a, v, 0xff)
      SET-LOCAL(l, v)
    defn SET-LOCAL-INT (l:Int, v:Gp) :
      movsxd(a, v, v)
      SET-LOCAL(l, v)
    defn SET-LOCAL-FLOAT (l:Int,v:Xmm) :
      movsd(a, local-access(l), v)
      dump(a, "SET-LOCAL-FLOAT[%d] %p\n", CONST(rax(), l), LOCAL(tmp1(), l)) when (debugging? or tracing?)
    defn SET-LOCAL-DOUBLE (l:Int, v:Xmm) :
      movsd(a, local-access(l), v)
      dump(a, "SET-LOCAL-DOUBLE[%d] %p\n", CONST(rax(), l), LOCAL(tmp1(), l)) when (debugging? or tracing?)

    ;Local getters

    ;Ensure dst register is used (because don't want to corrupt local register)
    defn LOCAL-DST! (dst:Gp, l:Int) -> Gp :
      mov(a, dst, local-access(l))
    ;Access local from either register or locals storage
    defn LOCAL (dst:Gp, l:Int) -> Gp :
      match(local-access(l)) :
        (acc:Gp) : acc
        (acc:MemPtr) : mov(a, dst, acc)
    ;Access local from either register or locals storage with given size in bytes
    defn LOCAL (dst:Gp, l:Int, size:Int) -> Gp :
      match(local-access(l)) :
        (acc:Gp) : gp(acc, size)
        (acc:MemPtr) : mov(a, gp(dst, size), acc)
    ;Access local byte from either register or locals storage and use dst if requested
    defn LOCAL-BYTE (dst:Gp, l:Int, dst?:True|False) -> Gp :
      match(local-access(l)) :
        (acc:Gp) : mov(a, gp8(dst), gp8(acc)) when dst? else gp8(acc)
        (acc:MemPtr) : mov(a, gp8(dst), acc)
    defn LOCAL-BYTE (dst:Gp, l:Int) : LOCAL-BYTE(dst, l, false)
    defn LOCAL-BYTE-DST! (dst:Gp, l:Int) : LOCAL-BYTE(dst, l, true)
    ;Access local int from either register or locals storage and use dst if requested
    defn LOCAL-INT (dst:Gp, l:Int, dst?:True|False) -> Gp :
      match(local-access(l)) :
        (acc:Gp) : mov(a, gp32(dst), gp32(acc)) when dst? else gp32(acc)
        (acc:MemPtr) : mov(a, gp32(dst), acc)
    defn LOCAL-INT (dst:Gp, l:Int) : LOCAL-INT(dst, l, false)
    defn LOCAL-INT-DST! (dst:Gp, l:Int) : LOCAL-INT(dst, l, true)
    defn LOCAL-FLOAT! (dst:Xmm, l:Int) -> Xmm : movss(a, dst, local-access(l))
    defn LOCAL-FLOAT (dst:Xmm, l:Int) -> Xmm : LOCAL-FLOAT!(dst, l)
    defn LOCAL-DOUBLE! (dst:Xmm, l:Int) -> Xmm : movsd(a, dst, local-access(l))
    defn LOCAL-DOUBLE (dst:Xmm, l:Int) -> Xmm : LOCAL-DOUBLE!(dst, l)

    ;Stack frame ops

    defn PUSH-FRAME-ONLY (num-locals:Int) :
      save-local-registers(a)
      add(a, stack-pointer(), SIZEOF-STACK-FRAME + num-locals * SIZEOF-LONG)

    defn PUSH-FRAME (num-locals:Int, ret-addr:Label) :
      PUSH-FRAME-ONLY(num-locals)
      lea(a, tmp1(), MemPtr(ret-addr, 0))
      set-return(a, tmp1())

    defn POP-FRAME (num-locals:Int) :
      add(a, stack-pointer(), -1 * (SIZEOF-STACK-FRAME + num-locals * SIZEOF-LONG))
      restore-local-registers(a)

    ;Call support

    defn c-call (fptr:Long) :
      push(a, r10())
      push(a, r11())
      mov(a, rax(), fptr)
      call(a, rax())
      pop(a, r11())
      pop(a, r10())

    defn do-tcall (f:Gp) :
      mov(a, tmp1(), MemPtr(functions(), f, 3, 0, SIZEOF-LONG))
      jmp(a, tmp1())

    defn do-call (f:Gp, num-locals:Int) :
      val end-label = new-label(a)
      PUSH-FRAME(num-locals, end-label)
      do-tcall(f)
      bind(a, end-label)

    ;Opcode tracing support -- meant to compare against golden models like CVM
    
    defn do-trace-opcode (opcode:Int, name:String) :
      if tracing? :
        val format = string-join $ [ "%d: " opcode-names[opcode] name "\n" ]
        val counter = rdi()
        get-instructions(a, counter)
        dump(a, format, counter) when tracing?
        add(a, counter, 1)
        set-instructions(a, counter)
      add(covered, opcode)

    defn trace-opcode (opcode:Int) :
      do-trace-opcode(opcode, "") when tracing?

    defn trace-opcode (opcode:Int, x:Int|Label) :
      do-trace-opcode(opcode, string-join $ [" " x]) when tracing?

    defn trace-opcode (opcode:Int, x:Int, y:Int|Long) :
      do-trace-opcode(opcode, string-join $ [" " x " " y]) when tracing?

    defn trace-opcode (opcode:Int, x:Int|Label, y:Int, z:Int|Label) :
      do-trace-opcode(opcode, string-join $ [" " x " " y " " z]) when tracing?

    defn trace-opcode (opcode:Int, w:Int, x:Int, y:Int|Label, z:Int|Label) :
      do-trace-opcode(opcode, string-join $ [" " w " " x " " y " " z]) when tracing?

    ;Instruction emission
    
    defn emit-ins-a (opcode:Int, value:Label) :
      trace-opcode(opcode, value)
      switch(opcode) :
        GOTO-OPCODE : 
          jmp(a, value as Label)

    defn emit-ins-a (opcode:Int, value:Int) :
      trace-opcode(opcode, value)
      switch(opcode) :
        FNENTRY-OPCODE :
          val start-label = new-label(a)
          bind(a, start-label)
          lea(a, tmp1(), MemPtr(start-label, 0))
          val all-good-label = new-label(a)
          val extend-return-label = new-label(a)
          val frame-size = value * SIZEOF-LONG + SIZEOF-STACK-FRAME
          val size-required = frame-size + SIZEOF-STACK-FRAME
          ;Size-required must be in tmp3 to line up for extend-stack-launch
          add(a, CONST(tmp3(), size-required), stack-pointer())
          val limit = stack-limit(tmp2())
          cmp(a, tmp3(), limit)
          jle(a, all-good-label)
          CONST(tmp3(), size-required)
          lea(a, tmp2(), MemPtr(extend-return-label, 0))
          jmp(a, CONST(tmp1(), extend-stack-launch-value))
          bind(a, extend-return-label)
          bind(a, all-good-label)
        DISPATCH-OPCODE :
          val tgts = new-label(a)
          val idx = read-dispatch-table(a, tmp1(), vmstate(), CONST(tmp1(), value))
          lea(a, tmp2(), MemPtr(tgts, 0))
          mov(a, tmp2(), MemPtr(tmp2(), idx, 3, 0))
          jmp(a, tmp2())
          bind(a, tgts)
        TCALL-CLOSURE-OPCODE :
          mov(a, tmp2(), MemPtr(LOCAL(tmp1(), value), FUNCTION-CODE-OFFSET + SIZEOF-LONG - REF-TAG-BITS))
          do-tcall(tmp2())
        POP-FRAME-OPCODE :
          val num-locals = value
          POP-FRAME(num-locals)
        ENTER-STACK-OPCODE :
          val saved-label = new-label(a)
          ;Save current stack
          save-local-registers(a)
          set-stack-pointer(a, stack-pointer())
          lea(a, tmp1(), MemPtr(saved-label, 0))
          set-pc(a, tmp1())
          ;Load next stack
          val next-stack = LOCAL(tmp1(), value)
          set-current-stack(a, next-stack)
          untag-stack(a, stk(), next-stack)
          get-frames(a, stack-pointer())
          restore-local-registers(a)
          ;Load starting address
          get-pc(a, tmp1())
          mov(a, tmp2(), MemPtr(functions(), tmp1(), 3, 0))
          jmp(a, tmp2())
          bind(a, saved-label)
        YIELD-OPCODE :
          val continue-label = new-label(a)
          ;Save current stack
          save-local-registers(a)
          set-stack-pointer(a, stack-pointer())
          lea(a, tmp2(), MemPtr(continue-label, 0))
          set-pc(a, tmp2())
          ;Load next stack
          val next-stack = LOCAL(tmp1(), value)
          set-current-stack(a, next-stack)
          untag-stack(a, stk(), next-stack)
          get-stack-pointer(a, stack-pointer())
          restore-local-registers(a)
          ;Load starting address
          get-pc(a, tmp1())
          jmp(a, tmp1())
          bind(a, continue-label)
        RETURN-OPCODE : 
          get-return(a, tmp1())
          jmp(a, tmp1())
        DUMP-OPCODE :
          false
        LIVE-OPCODE :
          mov(a, tmp2(), value)
          set-liveness-map(a, tmp2())
        DISPATCH-METHOD-OPCODE :
          val code-label = new-label(a)
          val tgts = new-label(a)
          read-dispatch-table(a, tmp3(), vmstate(), CONST(tmp1(), value))
          cmp(a, tmp3(), 2) ; < 2 are targets and >= 2 are methods to goto
          jge(a, code-label)
          lea(a, tmp2(), MemPtr(tgts, 0))
          mov(a, tmp2(), MemPtr(tmp2(), tmp3(), 3, 0))
          jmp(a, tmp2())
          bind(a, code-label)
          mov(a, tmp2(), MemPtr(functions(), tmp3(), 3, -2 * SIZEOF-LONG))
          jmp(a, tmp2())
          bind(a, tgts)
        FLUSH-VM-OPCODE :
          SAVE-STATE-ONLY(a)
          SET-LOCAL(value, vmstate())
        C-RSP-OPCODE :
          SET-LOCAL(value, GET-CRSP(tmp1()))
        else :
          fatal("MISSING A OPCODE %_" % [opcode])

    defn TAG (dst:Gp, x:Gp, tag:Int) -> Gp:
      mov(a, dst, x)
      shl(a, dst, 32)
      add(a, dst, tag)
      dst

    defn DETAG (dst:Gp, x:Gp) -> Gp:
      mov(a, dst, x)
      shr(a, dst, 32)
      dst

    defn ptr-to-ref (dst:Gp, p:Gp) -> Gp :
      lea(a, dst, MemPtr(p, REF-TAG-BITS))
      dst

    defn emit-ins-b (opcode:Int, x:Int, value:Int) :
      trace-opcode(opcode, x, value)
      switch(opcode) :
        INT-NOT-OPCODE :
          not-op(a, LOCAL-DST!(tmp1(), value))
          shr(a, tmp1(), 32)
          shl(a, tmp1(), 32)
          SET-LOCAL(x, tmp1())
        INT-NEG-OPCODE :
          val dst = neg(a, LOCAL-DST!(tmp1(), value))
          SET-LOCAL(x, dst)
        NOT-OPCODE-BYTE :
          xor-op(a, tmp1(), tmp1())
          not-op(a, LOCAL-BYTE-DST!(tmp1b(), value))
          SET-LOCAL-BYTE(x, tmp1())
        NOT-OPCODE-INT :
          xor-op(a, tmp1(), tmp1()) ; TODO: REMOVE?
          not-op(a, LOCAL-INT-DST!(tmp1i(), value))
          SET-LOCAL-INT(x, tmp1())
        NOT-OPCODE-LONG :
          val dst = not-op(a, LOCAL-DST!(tmp2(), value))
          SET-LOCAL(x, dst)
        NEG-OPCODE-INT :
          val dst = neg(a, LOCAL-DST!(tmp1(), value))
          SET-LOCAL-INT(x, dst)
        NEG-OPCODE-LONG :
          val dst = neg(a, LOCAL-DST!(tmp2(), value))
          SET-LOCAL(x, dst)
        NEG-OPCODE-FLOAT :
          xor-op(a, tmp1(), tmp1()) ; FASTER METHOD?
          cvtsi2ss(a, xmm0(), tmp1())
          subss(a, xmm0(), LOCAL-FLOAT(xmm1(), value))
          SET-LOCAL-FLOAT(x, xmm0())
        NEG-OPCODE-DOUBLE :
          xor-op(a, tmp1(), tmp1()) ; FASTER METHOD?
          cvtsi2sd(a, xmm0(), tmp1())
          subsd(a, xmm0(), LOCAL-DOUBLE(xmm1(), value))
          SET-LOCAL-DOUBLE(x, xmm0())
        CONV-OPCODE-BYTE-FLOAT :
          cvtss2si(a, tmp1b(), LOCAL-FLOAT(xmm0(), value))
          SET-LOCAL-BYTE(x, tmp1())
        CONV-OPCODE-BYTE-DOUBLE :
          cvtsd2si(a, tmp1(), LOCAL-DOUBLE(xmm0(), value))
          SET-LOCAL-BYTE(x, tmp1())
        CONV-OPCODE-INT-BYTE :
          xor-op(a, tmp1(), tmp1()) ; TODO: REMOVE?
          mov(a, tmp1b(), LOCAL-BYTE(tmp1b(), value))
          SET-LOCAL-INT(x, tmp1())
        CONV-OPCODE-INT-FLOAT :
          cvtss2si(a, tmp1i(), LOCAL-FLOAT(xmm0(), value))
          SET-LOCAL-INT(x, tmp1())
        CONV-OPCODE-INT-DOUBLE :
          cvtsd2si(a, tmp1i(), LOCAL-DOUBLE(xmm0(), value))
          SET-LOCAL-INT(x, tmp1())
        CONV-OPCODE-LONG-BYTE :
          xor-op(a, tmp1(), tmp1()) ; TODO: REMOVE?
          mov(a, tmp1b(), LOCAL-BYTE(tmp1b(), value))
          SET-LOCAL(x, tmp1())
        CONV-OPCODE-LONG-INT :
          movsxd(a, tmp2(), LOCAL-INT(tmp1i(), value))
          SET-LOCAL(x, tmp2())
        CONV-OPCODE-LONG-FLOAT :
          cvtss2si(a, tmp2(), LOCAL-FLOAT(xmm0(), value))
          SET-LOCAL(x, tmp2())
        CONV-OPCODE-LONG-DOUBLE :
          cvtsd2si(a, tmp2(), LOCAL-DOUBLE(xmm0(), value))
          SET-LOCAL(x, tmp2())
        CONV-OPCODE-FLOAT-BYTE :
          cvtsi2ss(a, xmm0(), LOCAL-BYTE(tmp1b(), value))
          SET-LOCAL-FLOAT(x, xmm0())
        CONV-OPCODE-FLOAT-INT :
          cvtsi2ss(a, xmm0(), LOCAL-INT(tmp1i(), value))
          SET-LOCAL-FLOAT(x, xmm0())
        CONV-OPCODE-FLOAT-LONG :
          cvtsi2ss(a, xmm0(), LOCAL(tmp2(), value))
          SET-LOCAL-FLOAT(x, xmm0())
        CONV-OPCODE-FLOAT-DOUBLE :
          cvtsd2ss(a, xmm1(), LOCAL-DOUBLE(xmm0(), value))
          SET-LOCAL-FLOAT(x, xmm1())
        CONV-OPCODE-DOUBLE-BYTE :
          cvtsi2sd(a, xmm0(), LOCAL(tmp1(), value))
          SET-LOCAL-DOUBLE(x, xmm0())
        CONV-OPCODE-DOUBLE-INT :
          cvtsi2sd(a, xmm0(), LOCAL(tmp1(), value))
          SET-LOCAL-DOUBLE(x, xmm0())
        CONV-OPCODE-DOUBLE-LONG :
          cvtsi2sd(a, xmm0(), LOCAL(tmp2(), value))
          SET-LOCAL-DOUBLE(x, xmm0())
        CONV-OPCODE-DOUBLE-FLOAT :
          cvtss2sd(a, xmm1(), LOCAL-FLOAT(xmm0(), value))
          SET-LOCAL-DOUBLE(x, xmm1())
        TAG-OPCODE-BYTE :
          TAG(tmp2(), LOCAL(tmp1(), value), BYTE-TAG-BITS)
          SET-LOCAL(x, tmp2())
        TAG-OPCODE-CHAR :
          TAG(tmp2(), LOCAL(tmp1(), value), CHAR-TAG-BITS)
          SET-LOCAL(x, tmp2())
        TAG-OPCODE-INT :
          TAG(tmp2(), LOCAL(tmp1(), value), INT-TAG-BITS)
          SET-LOCAL(x, tmp2())
        TAG-OPCODE-FLOAT :
          TAG(tmp2(), LOCAL(tmp1(), value), FLOAT-TAG-BITS)
          SET-LOCAL(x, tmp2())
        DETAG-OPCODE :
          DETAG(tmp2(), LOCAL(tmp1(), value))
          SET-LOCAL(x, tmp2())
        DEREF-OPCODE :
          val ref = LOCAL-DST!(tmp2(), value)
          add(a, ref, 8 - REF-TAG-BITS)
          SET-LOCAL(x, ref)
        GC-OPCODE :
          val size = LOCAL(tmp1(), value)
          save-local-registers(a)
          SAVE-STATE(a)
          call-garbage-collector(a, vmstate(), size)
          RESTORE-STATE(a)
          restore-local-registers(a)
          SET-LOCAL(x, rax())
        CLASS-NAME-OPCODE :
          SET-LOCAL(x, retrieve-class-name(a, vmstate(), LOCAL(tmp1(), value)))
        PRINT-STACK-TRACE-OPCODE :
          SET-LOCAL(x, call-print-stack-trace(a, vmstate(), LOCAL(tmp1(), value)))
        COLLECT-STACK-TRACE-OPCODE :
          SET-LOCAL(x, call-collect-stack-trace(a, vmstate(), LOCAL(tmp1(), value)))
        GET-REG-OPCODE :
          SET-LOCAL(x, GET-REG(tmp1(), value))
        else :
          fatal("MISSING B OPCODE %_" % [opcode])

    defn do-callc (num-locals:Int, faddr:Gp) :
      PUSH-FRAME-ONLY(num-locals)
      SAVE-STATE(a)
      c-trampoline(a, faddr, registers(), registers())
      RESTORE-STATE(a)
      POP-FRAME(num-locals)

    defn emit-ins-c (opcode:Int, x:Int, value:Int) :
      trace-opcode(opcode, x, value)
      switch(opcode) :
        TCALL-OPCODE-LOCAL :
          do-tcall(LOCAL(tmp2(), value))
        TCALL-OPCODE-CODE :
          do-tcall(CONST(tmp2(), value))
        CALL-OPCODE-LOCAL :
          do-call(LOCAL(tmp2(), value), x)
        CALL-OPCODE-CODE :
          do-call(CONST(tmp2(), value), x)
        CALL-CLOSURE-OPCODE :
          mov(a, tmp2(), MemPtr(LOCAL(tmp1(), value), FUNCTION-CODE-OFFSET + SIZEOF-LONG - REF-TAG-BITS))
          do-call(tmp2(), x)
        CALLC-OPCODE-LOCAL :
          do-callc(x, LOCAL(tmp2(), value))
        TYPEOF-OPCODE :
          read-dispatch-table(a, tmp3(), vmstate(), CONST(tmp2(), value))
          SET-LOCAL(x, tmp3())
        SET-REG-OPCODE-LOCAL :
          SET-REG(x, LOCAL(tmp2(), value), MEM-REG-ONLY?)
        SET-REG-OPCODE-UNSIGNED :
          mov(a, tmp1(), to-long(value) & 0xffffffffL)
          SET-REG(x, tmp1())
        SET-REG-OPCODE-WIDE :
          SET-REG(x, CONST(tmp1(), value))
        SET-REG-OPCODE-CODE :
          SET-REG(x, CONST(tmp1(), value))
        SET-REG-OPCODE-GLOBAL :
          mov(a, tmp2(), MemPtr(global-offsets(rax()), CONST(tmp1(), value), 3, 0))
          lea(a, tmp1(), MemPtr(global-mem(rax()), tmp2(), 0, 0))
          SET-REG(x, tmp1())
        SET-REG-OPCODE-DATA :
          mov(a, tmp2i(), MemPtr(data-offsets(rax()), CONST(tmp1(), value), 2, 0, SIZEOF-INT))
          lea(a, tmp1(), MemPtr(data-mem(rax()), tmp2i(), 3, 0))
          SET-REG(x, tmp1())
        SET-REG-OPCODE-CONST :
          mov(a, tmp1(), MemPtr(const-table(rax()), CONST(tmp3(), value), 3, 0))
          SET-REG(x, tmp1())
        SET-REG-OPCODE-UNSIGNED :
          SET-REG(x, CONST(tmp1(), value))
        SET-REG-OPCODE-SIGNED :
          SET-REG-INT(x, CONST(tmp1(), value))
        SET-OPCODE-LOCAL :
          SET-LOCAL(x, LOCAL(tmp2(), value)) when x != value
        SET-OPCODE-UNSIGNED :
          SET-LOCAL(x, CONST(tmp1(), value))
        SET-OPCODE-WIDE :
          SET-LOCAL(x, CONST(tmp1(), value))
        SET-OPCODE-CODE :
          SET-LOCAL(x, CONST(tmp1(), value))
        SET-OPCODE-GLOBAL :
          mov(a, tmp2(), MemPtr(global-offsets(rax()), CONST(tmp1(), value), 3, 0))
          lea(a, tmp1(), MemPtr(global-mem(rax()), tmp2(), 0, 0))
          SET-LOCAL(x, tmp1())
        SET-OPCODE-DATA :
          mov(a, tmp2i(), MemPtr(data-offsets(rax()), CONST(tmp1(), value), 2, 0, SIZEOF-INT))
          lea(a, tmp1(), MemPtr(data-mem(rax()), tmp2i(), 3, 0))
          SET-LOCAL(x, tmp1())
        SET-OPCODE-CONST :
          mov(a, tmp2(), MemPtr(const-table(rax()), CONST(tmp1(), value), 3, 0))
          SET-LOCAL(x, tmp2())
        else :
          fatal("MISSING C OPCODE %_" % [opcode])

    defn emit-ins-c (opcode:Int, x:Label, y:Int, value:Int) :
      trace-opcode(opcode, x, y, value)
      defn do-reserve (size:Gp, num-locals:Int) :
        add(a, heap-top(tmp2()), size)
        cmp(a, tmp2(), heap-limit(rax()))
        jle(a, x)
        SET-REG(0, BOOLREF(CONST(tmp1(), 0)))
        SET-REG(1, CONST(tmp1(), 1L))
        SET-REG(2, size)
        mov(a, tmp2(), MemPtr(functions(), SIZEOF-LONG * EXTEND-HEAP-FN))
        val end-label = new-label(a)
        PUSH-FRAME(num-locals, end-label)
        jmp(a, tmp2())
        bind(a, end-label)
      switch(opcode) :
        RESERVE-OPCODE-LOCAL :
          val size = tmp3()
          add(a, LOCAL-DST!(size, value), 8 + 7)
          and-op(a, size, CONST(tmp2(), (- 8L)))
          do-reserve(size, y)
        RESERVE-OPCODE-CONST :
          do-reserve(CONST(tmp3(), value), y)

    defn emit-ins-c (opcode:Int, x:Int, y:Int, value:Label) :
      trace-opcode(opcode, x, y, value)
      switch(opcode) :
        JUMP-REG-OPCODE :
          val reg = x
          val arity = y
          cmp(a, GET-REG(tmp1(), reg, false), arity)
          je(a, value as Label)

    defn cmp-set (a:Assembler, x:Gp, y:Gp, z:Gp, zb:Gp, set:(Assembler, Gp) -> False) -> Gp :
      xor-op(a, z, z)
      cmp(a, x, y)
      set(a, zb)
      z

    defn cmpf-set (a:Assembler, x:Xmm, y:Xmm, z:Gp, zb:Gp, set:(Assembler, Gp) -> False) -> Gp :
      xor-op(a, z, z)
      ucomiss(a, x, y)
      set(a, zb)
      z

    defn cmpd-set (a:Assembler, x:Xmm, y:Xmm, z:Gp, zb:Gp, set:(Assembler, Gp) -> False) -> Gp :
      xor-op(a, z, z)
      ucomisd(a, x, y)
      set(a, zb)
      z

    defn emit-ins-c (opcode:Int, x:Int, y:Int, value:Int) :
      trace-opcode(opcode, x, y, value)
      defn do-alloc (type:Int, num-bytes:Gp) :
        val top = tmp2()
        heap-top(top)
        mov(a, MemPtr(top, 0), CONST(tmp1(), value))
        SET-LOCAL(x, ptr-to-ref(tmp1(), top))
        add(a, top, num-bytes)
        set-heap-top(a, top)
      switch(opcode) :
        INT-ADD-OPCODE :
          val dst = add(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        INT-SUB-OPCODE :
          val dst = sub(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        INT-MUL-OPCODE :
          shr(a, LOCAL-DST!(tmp1(), y), 32)
          imul(a, tmp1(), LOCAL(tmp2(), value))
          SET-LOCAL(x, tmp1())
        INT-DIV-OPCODE :
          xor-op(a, rdx(), rdx())
          LOCAL-DST!(rax(), y), 
          div(a, LOCAL(tmp2(), value))
          shl(a, rax(), 32)
          SET-LOCAL(x, rax())
        INT-MOD-OPCODE :
          xor-op(a, rdx(), rdx())
          LOCAL-DST!(rax(), y), 
          div(a, LOCAL(tmp2(), value))
          SET-LOCAL(x, rdx())
        INT-AND-OPCODE :
          val dst = and-op(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        INT-OR-OPCODE :
          val dst = or-op(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        INT-XOR-OPCODE :
          val dst = xor-op(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        INT-SHL-OPCODE :
          shr(a, LOCAL-DST!(rcx(), value), 32) 
          shl(a, LOCAL-DST!(tmp1(), y), rcx())
          SET-LOCAL(x, tmp1())
        INT-SHR-OPCODE :
          shr(a, LOCAL-DST!(rcx(), value), 32)
          shr(a, LOCAL-DST!(tmp1(), y), rcx())
          shr(a, tmp1(), 32)
          shl(a, tmp1(), 32)
          SET-LOCAL(x, tmp1())
        INT-ASHR-OPCODE :
          shr(a, LOCAL-DST!(rcx(), value), 32)
          ashr(a, LOCAL-DST!(tmp1(), y), rcx())
          shr(a, tmp1(), 32)
          shl(a, tmp1(), 32)
          SET-LOCAL(x, tmp1())
        INT-LT-OPCODE :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-l)
          SET-LOCAL(x, BOOLREF(res))
        INT-GT-OPCODE :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-g)
          SET-LOCAL(x, BOOLREF(res))
        INT-LE-OPCODE :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-le)
          SET-LOCAL(x, BOOLREF(res))
        INT-GE-OPCODE :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ge)
          SET-LOCAL(x, BOOLREF(res))
        REF-EQ-OPCODE :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-e)
          SET-LOCAL(x, BOOLREF(res))
        EQ-OPCODE-REF :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-e)
          SET-LOCAL(x, res)
        EQ-OPCODE-BYTE :
          val res = cmp-set(a, LOCAL-BYTE(tmp1b(), y), LOCAL-BYTE(tmp2b(), value), tmp3(), tmp3b(), set-e)
          SET-LOCAL(x, res)
        EQ-OPCODE-INT :
          val res = cmp-set(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value), tmp3(), tmp3b(), set-e)
          SET-LOCAL(x, res)
        EQ-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-e)
          SET-LOCAL(x, res)
        EQ-OPCODE-FLOAT :
          val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-e)
          SET-LOCAL(x, res)
        EQ-OPCODE-DOUBLE :
          val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-e)
          SET-LOCAL(x, res)
        REF-NE-OPCODE :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
          SET-LOCAL(x, BOOLREF(res))
        NE-OPCODE-REF :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
          SET-LOCAL(x, res)
        NE-OPCODE-BYTE :
          val res = cmp-set(a, LOCAL-BYTE(tmp1b(), y), LOCAL-BYTE(tmp2b(), value), tmp3(), tmp3b(), set-ne)
          SET-LOCAL(x, res)
        NE-OPCODE-INT :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
          SET-LOCAL(x, res)
        NE-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ne)
          SET-LOCAL(x, res)
        NE-OPCODE-FLOAT :
          val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-ne)
          SET-LOCAL(x, res)
        NE-OPCODE-DOUBLE :
          val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-ne)
          SET-LOCAL(x, res)
        ADD-OPCODE-BYTE :
          val dst = add(a, LOCAL-BYTE-DST!(tmp1b(), y), LOCAL-BYTE(tmp2b(), value))
          SET-LOCAL-BYTE(x, gp64(dst))
        ADD-OPCODE-INT :
          val dst = add(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value))
          SET-LOCAL-INT(x, gp64(dst))
        ADD-OPCODE-LONG :
          val dst = add(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        ADD-OPCODE-FLOAT :
          val dst = addss(a, LOCAL-FLOAT!(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
          SET-LOCAL-FLOAT(x, dst)
        ADD-OPCODE-DOUBLE :
          val dst = addsd(a, LOCAL-DOUBLE!(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
          SET-LOCAL-DOUBLE(x, dst)
        SUB-OPCODE-BYTE :
          val dst = sub(a, LOCAL-BYTE-DST!(tmp1b(), y), LOCAL-BYTE(tmp2b(), value))
          SET-LOCAL-BYTE(x, gp64(dst))
        SUB-OPCODE-INT :
          val dst = sub(a, LOCAL-INT-DST!(tmp1i(), y), LOCAL-INT(tmp2i(), value))
          SET-LOCAL-INT(x, gp64(dst))
        SUB-OPCODE-LONG :
          val dst = sub(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        SUB-OPCODE-FLOAT :
          val dst = subss(a, LOCAL-FLOAT!(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
          SET-LOCAL-FLOAT(x, dst)
        SUB-OPCODE-DOUBLE :
          val dst = subsd(a, LOCAL-DOUBLE!(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
          SET-LOCAL-DOUBLE(x, dst)
        MUL-OPCODE-BYTE :
          val dst = imul(a, LOCAL-INT-DST!(tmp1i(), y), LOCAL-INT(tmp2i(), value))
          SET-LOCAL-BYTE(x, gp64(dst))
        MUL-OPCODE-INT :
          val dst = imul(a, LOCAL-INT-DST!(tmp1i(), y), LOCAL-INT(tmp2i(), value))
          SET-LOCAL-INT(x, gp64(dst))
        MUL-OPCODE-LONG :
          val dst = imul(a, LOCAL-DST!(tmp3(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        MUL-OPCODE-FLOAT :
          val dst = mulss(a, LOCAL-FLOAT!(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
          SET-LOCAL-FLOAT(x, dst)
        MUL-OPCODE-DOUBLE :
          val dst = mulsd(a, LOCAL-DOUBLE!(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
          SET-LOCAL-DOUBLE(x, dst)
        DIV-OPCODE-BYTE :
          xor-op(a, rdx(), rdx())
          LOCAL-DST!(rax(), y), 
          div(a, LOCAL(tmp2(), value))
          SET-LOCAL-BYTE(x, rax())
        DIV-OPCODE-INT :
          xor-op(a, rdx(), rdx())
          LOCAL-DST!(rax(), y), 
          div(a, LOCAL(tmp2(), value))
          SET-LOCAL-INT(x, rax())
        DIV-OPCODE-LONG :
          xor-op(a, rdx(), rdx())
          LOCAL-DST!(rax(), y)
          div(a, LOCAL(tmp2(), value))
          SET-LOCAL(x, rax())
        DIV-OPCODE-FLOAT :
          val dst = divss(a, LOCAL-FLOAT!(xmm0(), y), LOCAL-FLOAT(xmm1(), value))
          SET-LOCAL-FLOAT(x, dst)
        DIV-OPCODE-DOUBLE :
          val dst = divsd(a, LOCAL-DOUBLE!(xmm0(), y), LOCAL-DOUBLE(xmm1(), value))
          SET-LOCAL-DOUBLE(x, dst)
        MOD-OPCODE-BYTE :
          xor-op(a, rdx(), rdx())
          LOCAL-DST!(rax(), y)
          div(a, LOCAL(tmp2(), value))
          SET-LOCAL-BYTE(x, rdx())
        MOD-OPCODE-INT :
          xor-op(a, rdx(), rdx())
          LOCAL-DST!(rax(), y)
          div(a, LOCAL(tmp2(), value))
          SET-LOCAL-INT(x, rdx())
        MOD-OPCODE-LONG :
          xor-op(a, rdx(), rdx())
          LOCAL-DST!(rax(), y)
          div(a, LOCAL(tmp2(), value))
          SET-LOCAL(x, rdx())
        AND-OPCODE-BYTE :
          val dst = and-op(a, LOCAL-BYTE-DST!(tmp1b(), y), LOCAL-BYTE(tmp2b(), value))
          SET-LOCAL-BYTE(x, gp64(dst))
        AND-OPCODE-INT :
          val dst = and-op(a, LOCAL-INT-DST!(tmp1i(), y), LOCAL-INT(tmp2i(), value))
          SET-LOCAL-INT(x, gp64(dst))
        AND-OPCODE-LONG :
          val dst = and-op(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        OR-OPCODE-BYTE :
          val dst = or-op(a, LOCAL-BYTE-DST!(tmp1b(), y), LOCAL-BYTE(tmp2b(), value))
          SET-LOCAL-BYTE(x, gp64(dst))
        OR-OPCODE-INT :
          val dst = or-op(a, LOCAL-INT-DST!(tmp1i(), y), LOCAL-INT(tmp2i(), value))
          SET-LOCAL-INT(x, gp64(dst))
        OR-OPCODE-LONG :
          val dst = or-op(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        XOR-OPCODE-BYTE :
          val dst = xor-op(a, LOCAL-BYTE-DST!(tmp1b(), y), LOCAL-BYTE(tmp2b(), value))
          SET-LOCAL-BYTE(x, gp64(dst))
        XOR-OPCODE-INT :
          val dst = xor-op(a, LOCAL-INT-DST!(tmp1i(), y), LOCAL-INT(tmp2i(), value))
          SET-LOCAL-INT(x, gp64(dst))
        XOR-OPCODE-LONG :
          val dst = xor-op(a, LOCAL-DST!(tmp1(), y), LOCAL(tmp2(), value))
          SET-LOCAL(x, dst)
        SHL-OPCODE-BYTE :
          val dst = shl(a, LOCAL-DST!(tmp1(), y), LOCAL-DST!(rcx(), value))
          SET-LOCAL-BYTE(x, dst)
        SHL-OPCODE-INT :
          val dst = shl(a, LOCAL-DST!(tmp1(), y), LOCAL-DST!(rcx(), value))
          SET-LOCAL-INT(x, dst)
        SHL-OPCODE-LONG :
          val dst = shl(a, LOCAL-DST!(tmp1(), y), LOCAL-DST!(rcx(), value))
          SET-LOCAL(x, dst)
        SHR-OPCODE-BYTE :
          val dst = shr(a, LOCAL-BYTE-DST!(tmp1b(), y), LOCAL-DST!(rcx(), value))
          SET-LOCAL-BYTE(x, gp64(dst))
        SHR-OPCODE-INT :
          val dst = shr(a, LOCAL-INT-DST!(tmp1i(), y), LOCAL-DST!(rcx(), value))
          SET-LOCAL-INT(x, gp64(dst))
        SHR-OPCODE-LONG :
          val dst = shr(a, LOCAL-DST!(tmp1(), y), LOCAL-DST!(rcx(), value))
          SET-LOCAL(x, dst)
        ASHR-OPCODE-INT :
          val dst = ashr(a, LOCAL-DST!(tmp1(), y), LOCAL-DST!(rcx(), value))
          SET-LOCAL-INT(x, dst)
        ASHR-OPCODE-LONG :
          val dst = ashr(a, LOCAL-DST!(tmp1(), y), LOCAL-DST!(rcx(), value))
          SET-LOCAL(x, dst)
        LT-OPCODE-INT :
          val res = cmp-set(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value), tmp3(), tmp3b(), set-l)
          SET-LOCAL(x, res)
        LT-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-l)
          SET-LOCAL(x, res)
        LT-OPCODE-FLOAT :
          val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-b)
          SET-LOCAL(x, res)
        LT-OPCODE-DOUBLE :
          val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-b)
          SET-LOCAL(x, res)
        GT-OPCODE-INT :
          val res = cmp-set(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value), tmp3(), tmp3b(), set-g)
          SET-LOCAL(x, res)
        GT-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-g)
          SET-LOCAL(x, res)
        GT-OPCODE-FLOAT :
          val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-a)
          SET-LOCAL(x, res)
        GT-OPCODE-DOUBLE :
          val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-a)
          SET-LOCAL(x, res)
        LE-OPCODE-INT :
          val res = cmp-set(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value), tmp3(), tmp3b(), set-le)
          SET-LOCAL(x, res)
        LE-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-le)
          SET-LOCAL(x, res)
        LE-OPCODE-FLOAT :
          val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-be)
          SET-LOCAL(x, res)
        LE-OPCODE-DOUBLE :
          val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-be)
          SET-LOCAL(x, res)
        GE-OPCODE-INT :
          val res = cmp-set(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value), tmp3(), tmp3b(), set-ge)
          SET-LOCAL(x, res)
        GE-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ge)
          SET-LOCAL(x, res)
        GE-OPCODE-FLOAT :
          val res = cmpf-set(a, LOCAL-FLOAT(xmm0(), y), LOCAL-FLOAT(xmm1(), value), tmp3(), tmp3b(), set-ae)
          SET-LOCAL(x, res)
        GE-OPCODE-DOUBLE :
          val res = cmpd-set(a, LOCAL-DOUBLE(xmm0(), y), LOCAL-DOUBLE(xmm1(), value), tmp3(), tmp3b(), set-ae)
          SET-LOCAL(x, res)
        ULT-OPCODE-BYTE :
          val res = cmp-set(a, LOCAL-BYTE(tmp1b(), y), LOCAL-BYTE(tmp2b(), value), tmp3(), tmp3b(), set-b)
          SET-LOCAL(x, res)
        ULT-OPCODE-INT :
          val res = cmp-set(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value), tmp3(), tmp3b(), set-b)
          SET-LOCAL(x, res)
        ULT-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-b)
          SET-LOCAL(x, res)
        ULE-OPCODE-BYTE :
          val res = cmp-set(a, LOCAL-BYTE(tmp1b(), y), LOCAL-BYTE(tmp2b(), value), tmp3(), tmp3b(), set-be)
          SET-LOCAL(x, res)
        ULE-OPCODE-INT :
          val res = cmp-set(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value), tmp3(), tmp3b(), set-be)
          SET-LOCAL(x, res)
        ULE-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-be)
          SET-LOCAL(x, res)
        UGT-OPCODE-BYTE :
          val res = cmp-set(a, LOCAL-BYTE(tmp1b(), y), LOCAL-BYTE(tmp2b(), value), tmp3(), tmp3b(), set-a)
          SET-LOCAL(x, res)
        UGT-OPCODE-INT :
          val res = cmp-set(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value), tmp3(), tmp3b(), set-a)
          SET-LOCAL(x, res)
        UGT-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-a)
          SET-LOCAL(x, res)
        UGE-OPCODE-BYTE :
          val res = cmp-set(a, LOCAL-BYTE(tmp1b(), y), LOCAL-BYTE(tmp2b(), value), tmp3(), tmp3b(), set-ae)
          SET-LOCAL(x, res)
        UGE-OPCODE-INT :
          val res = cmp-set(a, LOCAL-INT(tmp1i(), y), LOCAL-INT(tmp2i(), value), tmp3(), tmp3b(), set-ae)
          SET-LOCAL(x, res)
        UGE-OPCODE-LONG :
          val res = cmp-set(a, LOCAL(tmp1(), y), LOCAL(tmp2(), value), tmp3(), tmp3b(), set-ae)
          SET-LOCAL(x, res)
        ALLOC-OPCODE-LOCAL :
          val num-bytes = tmp3()
          LOCAL-DST!(num-bytes, y)
          add(a, num-bytes, 8 + 7)
          and-op(a, num-bytes, CONST(tmp1(), (- 8L)))
          do-alloc(value, num-bytes)
        ALLOC-OPCODE-CONST :
          do-alloc(value, CONST(tmp3(), 8 + y))
        else :
          fatal("MISSING C OPCODE %_" % [opcode])

    defn emit-ins-d (opcode:Int, x:Int, value:Long) :
      trace-opcode(opcode, x, value)
      switch(opcode) :
        CALLC-OPCODE-WIDE : 
          do-callc(x, CONST(tmp1(), value))
        SET-OPCODE-WIDE :
          SET-LOCAL(x, CONST(tmp1(), value))
        SET-REG-OPCODE-WIDE :
          SET-REG(x, CONST(tmp1(), value))
        else :
          fatal("MISSING D OPCODE %_" % [opcode])

    defn emit-ins-e (opcode:Int, x:Int, y:Int, z:Int, value:Int) :
      trace-opcode(opcode, x, y, z, value)

      defn store (pi:Int, ov:Int, vi:Int, size:Int) :
        val p = LOCAL(tmp1(), pi)
        val o = CONST(tmp2(), ov)
        val v = LOCAL(tmp3(), vi, size)
        mov(a, MemPtr(p, o, 0, 0, size), v)
        dump(a, "  STORE-%d %p[%d] = %p\n" CONST(rax(), size) p o v) when (debugging? or tracing?)

      defn store-var (pi:Int, ii:Int, ov:Int, vi:Int, size:Int) :
        val p = LOCAL(tmp1(), pi)
        val i = LOCAL(tmp2(), ii)
        val v = LOCAL(tmp3(), vi, size)
        mov(a, MemPtr(p, i, 0, ov, size), v)
        dump(a, "  STORE-%d* %p[%d] = %p\n" CONST(rcx(), size) p i v) when (debugging? or tracing?)

      switch(opcode) :
        STORE-OPCODE-1 : store(x, value, z, SIZEOF-BYTE)
        STORE-OPCODE-4 : store(x, value, z, SIZEOF-INT)
        STORE-OPCODE-8 : store(x, value, z, SIZEOF-LONG)
        STORE-OPCODE-1-VAR-OFFSET : store-var(x, y, value, z, SIZEOF-BYTE)
        STORE-OPCODE-4-VAR-OFFSET : store-var(x, y, value, z, SIZEOF-INT)
        STORE-OPCODE-8-VAR-OFFSET : store-var(x, y, value, z, SIZEOF-LONG)

        LOAD-OPCODE-1 : 
          mov(a, tmp3(), MemPtr(LOCAL(tmp1(), y), CONST(tmp2(), value), 0, 0, SIZEOF-BYTE))
          SET-LOCAL-BYTE(x, tmp3())
        LOAD-OPCODE-4 : 
          mov(a, tmp3(), MemPtr(LOCAL(tmp1(), y), CONST(tmp2(), value), 0, 0, SIZEOF-INT))
          SET-LOCAL-INT(x, tmp3())
        LOAD-OPCODE-8 :
          mov(a, tmp3(), MemPtr(LOCAL(tmp1(), y), CONST(tmp2(), value), 0, 0, SIZEOF-LONG))
          SET-LOCAL(x, tmp3())
        LOAD-OPCODE-1-VAR-OFFSET :
          xor-op(a, tmp3(), tmp3())
          mov(a, tmp3(), MemPtr(LOCAL(tmp2(), y), LOCAL(tmp1(), z), 0, value, SIZEOF-BYTE))
          SET-LOCAL-BYTE(x, tmp3())
        LOAD-OPCODE-4-VAR-OFFSET :
          xor-op(a, tmp3(), tmp3())
          mov(a, tmp3(), MemPtr(LOCAL(tmp2(), y), LOCAL(tmp1(), z), 0, value, SIZEOF-INT))
          SET-LOCAL-INT(x, tmp3())
        LOAD-OPCODE-8-VAR-OFFSET :
          mov(a, tmp3(), MemPtr(LOCAL(tmp2(), y), LOCAL(tmp1(), z), 0, value, SIZEOF-LONG))
          SET-LOCAL(x, tmp3())
        else :
          fatal("MISSING E OPCODE %_" % [opcode])


    defn jump-op-reg (x:Gp, y:Gp, f:(Assembler, Label) -> False, cmp:(Assembler, Gp, Gp) -> False, n1:Label, n2:Label) :
      cmp(a, x, y)
      f(a,  n1)
      jmp(a, n2)

    defn jump-op (x:Int, y:Int, f:(Assembler, Label) -> False, cmp:(Assembler, Gp, Gp) -> False, n1:Label, n2:Label) :
      jump-op-reg(LOCAL(tmp1(), x), LOCAL(tmp2(), y), f, cmp, n1, n2)

    defn jump-op-xmm (x:Xmm, y:Xmm, f:(Assembler, Label) -> ?, cmp:(Assembler, Xmm, Xmm) -> False, n1:Label, n2:Label) :
      cmp(a, x, y)
      f(a,  n1)
      jmp(a, n2)

    defn jump-float-op (x:Int, y:Int, f:(Assembler, Label) -> False, n1:Label, n2:Label) :
      jump-op-xmm(LOCAL-FLOAT(xmm0(), x), LOCAL-FLOAT(xmm1(), y), f, ucomiss, n1, n2)

    defn jump-double-op (x:Int, y:Int, f:(Assembler, Label) -> False, n1:Label, n2:Label) :
      jump-op-xmm(LOCAL-DOUBLE(xmm0(), x), LOCAL-DOUBLE(xmm1(), y), f, ucomisd, n1, n2)

    defn emit-ins-f (opcode:Int, x:Int, y:Int, n1:Label, n2:Label) :
      trace-opcode(opcode, x, y, n1, n2)
      switch(opcode) :
        JUMP-TAGBITS-OPCODE :
          val bits = and-op(a, LOCAL-DST!(tmp1(), x), CONST(tmp2(), 0x7))
          cmp(a, bits, y)
          je(a, n1)
          jmp(a, n2)
        JUMP-TAGWORD-OPCODE :
          val obj = LOCAL(tmp1(), x) ; OBJ
          and-op(a, LOCAL-DST!(tmp2(), x), CONST(tmp3(), 7)) ; TAGBITS
          val tag = LOCAL(tmp3(), y) ; TAG
          cmp(a, tmp2(), 1) ; tagbits == 1
          jne(a, n2)
          mov(a, tmp1(), MemPtr(obj, -1, SIZEOF-INT)) ; *p = *((int*)(obj - 1))
          jump-op-reg(tmp1(), tag, je, cmp, n1, n2)   ; *p == tag
        JUMP-SET-OPCODE :
          jump-op-reg(LOCAL(tmp1(), x), CONST(tmp2(), 0), jne, cmp, n1, n2)
        JUMP-INT-LT-OPCODE :
          jump-op(x, y, jl, cmp, n1, n2)
        JUMP-INT-GT-OPCODE :
          jump-op(x, y, jg, cmp, n1, n2)
        JUMP-INT-LE-OPCODE :
          jump-op(x, y, jle, cmp, n1, n2)
        JUMP-INT-GE-OPCODE :
          jump-op(x, y, jge, cmp, n1, n2)
        JUMP-EQ-OPCODE-REF :
          jump-op(x, y, je, cmp, n1, n2)
        JUMP-EQ-OPCODE-BYTE :
          jump-op-reg(LOCAL-BYTE(tmp1b(), x), LOCAL-BYTE(tmp2b(), y), je, cmp, n1, n2)
        JUMP-EQ-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), je, cmp, n1, n2)
        JUMP-EQ-OPCODE-LONG :
          jump-op(x, y, je, cmp, n1, n2)
        JUMP-EQ-OPCODE-FLOAT :
          jump-float-op(x, y, je, n1, n2)
        JUMP-EQ-OPCODE-DOUBLE :
          jump-double-op(x, y, je, n1, n2)
        JUMP-NE-OPCODE-REF :
          jump-op(x, y, jne, cmp, n1, n2)
        JUMP-NE-OPCODE-BYTE :
          jump-op-reg(LOCAL-BYTE(tmp1b(), x), LOCAL-BYTE(tmp2b(), y), jne, cmp, n1, n2)
        JUMP-NE-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), jne, cmp, n1, n2)
        JUMP-NE-OPCODE-LONG :
          jump-op(x, y, jne, cmp, n1, n2)
        JUMP-NE-OPCODE-FLOAT :
          jump-float-op(x, y, jne, n1, n2)
        JUMP-NE-OPCODE-DOUBLE :
          jump-double-op(x, y, jne, n1, n2)
        JUMP-LT-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), jl, cmp, n1, n2)
        JUMP-LT-OPCODE-LONG :
          jump-op(x, y, jl, cmp, n1, n2)
        JUMP-LT-OPCODE-FLOAT :
          jump-float-op(x, y, jb, n1, n2)
        JUMP-LT-OPCODE-DOUBLE :
          jump-double-op(x, y, jb, n1, n2)
        JUMP-GT-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), jg, cmp, n1, n2)
        JUMP-GT-OPCODE-LONG :
          jump-op(x, y, jg, cmp, n1, n2)
        JUMP-GT-OPCODE-FLOAT :
          jump-float-op(x, y, ja, n1, n2)
        JUMP-GT-OPCODE-DOUBLE :
          jump-double-op(x, y, ja, n1, n2)
        JUMP-LE-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), jle, cmp, n1, n2)
        JUMP-LE-OPCODE-LONG :
          jump-op(x, y, jle, cmp, n1, n2)
        JUMP-LE-OPCODE-FLOAT :
          jump-float-op(x, y, jbe, n1, n2)
        JUMP-LE-OPCODE-DOUBLE :
          jump-double-op(x, y, jbe, n1, n2)
        JUMP-GE-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), jge, cmp, n1, n2)
        JUMP-GE-OPCODE-LONG :
          jump-op(x, y, jge, cmp, n1, n2)
        JUMP-GE-OPCODE-FLOAT :
          jump-float-op(x, y, jae, n1, n2)
        JUMP-GE-OPCODE-DOUBLE :
          jump-double-op(x, y, jae, n1, n2)
        JUMP-ULT-OPCODE-BYTE :
          jump-op-reg(LOCAL-BYTE(tmp1b(), x), LOCAL-BYTE(tmp2b(), y), jb, cmp, n1, n2)
        JUMP-ULT-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), jb, cmp, n1, n2)
        JUMP-ULT-OPCODE-LONG :
          jump-op(x, y, jb, cmp, n1, n2)
        JUMP-ULE-OPCODE-BYTE :
          jump-op-reg(LOCAL-BYTE(tmp1b(), x), LOCAL-BYTE(tmp2b(), y), jbe, cmp, n1, n2)
        JUMP-ULE-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), jbe, cmp, n1, n2)
        JUMP-ULE-OPCODE-LONG :
          jump-op(x, y, jbe, cmp, n1, n2)
        JUMP-UGT-OPCODE-BYTE :
          jump-op-reg(LOCAL-BYTE(tmp1b(), x), LOCAL-BYTE(tmp2b(), y), ja, cmp, n1, n2)
        JUMP-UGT-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), ja, cmp, n1, n2)
        JUMP-UGT-OPCODE-LONG :
          jump-op(x, y, ja, cmp, n1, n2)
        JUMP-UGE-OPCODE-BYTE :
          jump-op-reg(LOCAL-BYTE(tmp1b(), x), LOCAL-BYTE(tmp2b(), y), jae, cmp, n1, n2)
        JUMP-UGE-OPCODE-INT :
          jump-op-reg(LOCAL-INT(tmp1i(), x), LOCAL-INT(tmp2i(), y), jae, cmp, n1, n2)
        JUMP-UGE-OPCODE-LONG :
          jump-op(x, y, jae, cmp, n1, n2)
        else : 
          fatal("MISSING F OPCODE %_" % [opcode])

    ;Higher level encoding support almost exactly as in VM instruction encoding

    defn emit-ins-targets (dests:Tuple<Label>) :
      for (d in dests, i in 0 to false) do :
        embed(a, d)

    ;Encode multivarity functions
    defn encode (multi:VMMultifn) :
      ;Declare function labels
      val labels = for entry in funcs(multi) map : new-label(a)
      ;Emit branch instructions
      for (entry in funcs(multi), flabel in labels) do :
        val arity = key(entry)
        emit-ins-c(JUMP-REG-OPCODE, arg(multi), arity, flabel)
      ;Emit default branch
      encode(default(multi))
      ;Emit other branches, and compute their positions
      for (entry in funcs(multi), flabel in labels) do :
        bind(a, flabel)
        encode(value(entry))

    defn encode (func:VMFunc) :
      ;==================================================
      ;============== Fundamental State =================
      ;==================================================
      ; extra 3 locals for temporary moving
      val max-local = maximum(-1, seq(local, defs(func)))
      val num-locals = max-local + 1 + 3

      ;Definitions
      val deftable = to-inttable(id, defs(func))

      ;Labels
      val label-table = IntTable<Label>()
      val used-labels = to-intset(seq(n, filter-by<LabelIns>(ins(func))))
      val label-counter = to-seq(0 to false)

      ;==================================================
      ;============== Overall Algorithm =================
      ;==================================================
      defn driver () :
        emit-prelude()
        do(emit-ins, ins(func))

      ;Enter a function
      defn emit-prelude () :
        ;Enter function
        emit-ins-a(FNENTRY-OPCODE, num-locals)
        ;Retrieve arguments
        get-regs(args(func))

      ;Encode a match statement that can be redefined later.
      defn emit-non-final-match (ys:Tuple<VMImm>, bs:Tuple<VMBranch>, default:Int) :
        ;Retrieve the format index of this match statement.
        val [types, dests] = split-types-and-dests(bs)
        val format = match-format(resolver, types)

        ;Push arguments onto registers
        set-mem-regs(ys)

        ;One target for default and then each branch for dispatch.
        val num-targets = 1 + length(bs)
        val targets = jump-offsets([default], dests)
        emit-ins-a(DISPATCH-OPCODE, format)
        emit-ins-targets(targets)

      ;Encode a match statement that cannot be redefined later.
      defn emit-final-match (ys:Tuple<VMImm>, bs:Tuple<VMBranch>, default-label:Int) :
        defn compute-dag () :
          val branch-table = BranchTable(to-branches(seq(types,bs), {[_]}))
          compute-dispatch-dag(branch-table, false)

        defn emit-dag (dag:Dag) :
          ;Create labels for all entries
          val labels = map(gen-label{}, entries(dag))
          ;Convert a value into a label
          defn to-label (x:Int|Soln) :
            match(x) :
              (x:Int) : labels[x]
              (x:UniqueSoln) : n(bs[index(x)])
              (x:NoSoln) : default-label
          ;Compile a given entry
          defn emit-entry (e:DagEntry) :
            if empty?(entries(e)) :
              emit-ins(GotoIns(to-label(default(e))))
            else :
              within (entry, last?) = expanded-entries(e) :
                val n1 = to-label(value(entry))
                val n2 = to-label(default(e)) when last? else gen-label()
                emit-ins(Branch1Ins(n1, n2, InstanceofOp(SingleType(key(entry))), ys[depth(e)]))
                emit-ins(LabelIns(n2)) when not last?
          ;Compile all entries
          for (e in entries(dag), l in labels) do :
            emit-ins(LabelIns(l))
            emit-entry(e)

        ;Expand the given entries and compute whether it is the last entry
        defn expanded-entries (f:(KeyValue<Int,Int|Soln>, True|False) -> ?, e:DagEntry) :
          val es = for e in entries(e) seq-cat :
            for v in values(key(e)) seq :
              v => value(e)
          let loop () :
            val e = next(es)
            f(e, empty?(es))
            loop() when not empty?(es)

        ;Launch
        emit-dag(compute-dag())

      ;Emit instanceof operation
      defn emit-instanceof (n1:Int, n2:Int, x:VMImm, type:TypeSet) :
        if (type is SingleType) and type-is-final?(type) :
          defn driver () :
            val tag = /type(type as SingleType)
            switch(tag) :
              BYTE-TYPE : compare-tag-bits(BYTE-TYPE)
              CHAR-TYPE : compare-tag-bits(CHAR-TYPE)
              INT-TYPE : compare-tag-bits(INT-TYPE)
              FLOAT-TYPE :  compare-tag-bits(FLOAT-TYPE)
              else :
                if marker?(resolver, tag) : compare-marker(tag)
                else : compare-tag-word(tag)
          defn compare-tag-bits (typeid:Int) :
            val bits = tagbits(resolver,typeid)
            emit-ins-f(JUMP-TAGBITS-OPCODE, to-local(x,0), bits, jump-offset(n1), jump-offset(n2))
          defn compare-marker (typeid:Int) :
            emit-ins(Branch2Ins(n1, n2, EqOp(), x, Marker(typeid)))
          defn compare-tag-word (typeid:Int) :
            val typetag-local = to-local(NumConst(typeid), 0)
            val x-local = to-local(x,1)
            emit-ins-f(JUMP-TAGWORD-OPCODE, x-local, typetag-local, jump-offset(n1), jump-offset(n2))
          driver()
        else :
          ;Retrieve format
          val format = match-format(resolver, [[type]])
          ;Push argument into register
          set-mem-reg(0, x)
          ;Emit dispatch instruction
          ;Two targets, match success and default
          val num-targets = 2
          val targets = jump-offsets([n2, n1])
          emit-ins-a(DISPATCH-OPCODE, format)
          emit-ins-targets(targets)

      defn maybe-add-new-label (n:Int) -> Label :
        if not key?(label-table, n) :
          label-table[n] = new-label(a)
        label-table[n]

      defn before-call-dump (entry:False|StackTraceEntry) :
        match(entry:StackTraceEntry) :
          dump(a, ">>> %s\n", CONST(rax(), printf-format(to-string(entry)))) when (debugging? or tracing?)

      ;Encode each instruction
      defn emit-ins (ins:VMIns) :
        match(ins) :
          (ins:LabelIns) :
            val lab = maybe-add-new-label(n(ins))
            dump(a, string-join $ [lab, ":\n"]) when tracing?
            bind(a, lab)
          (ins:UnreachableIns) :
            false
          (ins:TCallIns) :
            set-regs(ys(ins))
            emit-ins-c(tcall-opcode(f(ins)), 0, to-function-local(f(ins)))
          (ins:TCallClosureIns) :
            set-regs(ys(ins))
            emit-ins-a(TCALL-CLOSURE-OPCODE, to-local(f(ins), 0))
          (ins:CallIns) :
            set-regs(ys(ins))
            before-call-dump(trace-entry(ins))
            emit-ins-c(call-opcode(f(ins)), num-locals, to-function-local(f(ins)))
            record-trace-entry(trace-entry(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            get-regs(xs(ins))
          (ins:CallClosureIns) :
            set-regs(ys(ins))
            before-call-dump(trace-entry(ins))
            emit-ins-c(CALL-CLOSURE-OPCODE, num-locals, to-local(f(ins), 0))
            record-trace-entry(trace-entry(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            get-regs(xs(ins))
          (ins:CallCIns) :
            ;Convert a VMType into an ArgType for call-record analysis
            defn to-arg-type (t:VMType) :
              match(t) :
                (t:VMFloat|VMDouble) : RealArg()
                (t) : IntArg()
            ;Compute C calling convention
            val records = callc-records(ytypes, xtype, backend) where :
              val ytypes = map(to-arg-type, map(imm-type, ys(ins)))
              val xtypes = map(to-arg-type, map(imm-type, xs(ins)))
              val xtype = IntArg() when empty?(xtypes) else xtypes[0]
            ;Compute register locations
            var layout-counter:Int = 0
            defn next-index (n:Int) :
              val c = layout-counter
              layout-counter = layout-counter + n
              c
            val num-stack-args-index = next-index(1)
            val stack-args-index = next-index(num-mem-args(records))
            val num-float-args-index = next-index(1)
            val float-args-index = next-index(num-real-args(records))
            val num-int-args-index = next-index(1)
            val int-args-index = next-index(num-int-args(records))
            val num-floats-in-call-index = next-index(1)
            ;Given the location that the argument should be stored,
            ;return the index in the register buffer that we should
            ;store the argument that is desired by the trampoline code.
            defn register-index (l:CallLoc) -> Int :
              match(l) :
                (l:RegLoc) : num-floats-in-call-index - 1 - index(l)
                (l:FRegLoc) : num-int-args-index - 1 - index(l)
                (l:MemLoc) : num-float-args-index - 1 - index(l)
            ;Assign registers
            for arg in args(records) do :
              val r = register-index(loc(arg))
              val v = value(arg) as StdArg|ShadowArg
              val y = ys(ins)[index(v)]
              set-mem-reg(r, y)
            ;Set number of arguments
            set-mem-reg(num-stack-args-index, NumConst(num-mem-args(records)))
            set-mem-reg(num-float-args-index, NumConst(num-real-args(records)))
            set-mem-reg(num-int-args-index, NumConst(num-int-args(records) + 1))
            set-mem-reg(num-floats-in-call-index, NumConst(num-real-args(records)))
            ;Call function
            before-call-dump(trace-entry(ins))
            match(f(ins)) :
              (f:Local) :
                emit-ins-c(CALLC-OPCODE-LOCAL, num-locals, slot(f))
              (f:ExternId) :
                val address = to-bits(f) as Long
                emit-ins-d(CALLC-OPCODE-WIDE, num-locals, address)
            record-trace-entry(trace-entry(ins))
            ;Retrieve return registers
            defn return-register-index (l:CallLoc) :
              match(l) :
                (l:RegLoc) : 0
                (l:FRegLoc) : 1
            if not empty?(xs(ins)) :
              val x = xs(ins)[0]
              get-mem-reg(x, return-register-index(return(records)))
          (ins:YieldIns) :
            set-regs(ys(ins))
            val opcode = ENTER-STACK-OPCODE when enter?(ins) else YIELD-OPCODE
            emit-ins-a(opcode, to-local(f(ins), 0))
            record-trace-entry(trace-entry(ins))
            get-regs(xs(ins))
          (ins:ReturnIns) :
            set-regs(xs(ins))
            emit-ins-a(RETURN-OPCODE, 0)
          (ins:DumpIns) :
            for x in xs(ins) do :
              emit-ins-a(DUMP-OPCODE, slot(x))
          (ins:RecordLiveIns) :
            val live-map = liveness-map(resolver, map(slot, live(ins)), num-locals)
            emit-ins-a(LIVE-OPCODE, live-map)
          (ins:StoreIns) :
            val code = store-opcode(y(ins), imm-type(z(ins)))
            val offset* = match(imm-type(x(ins))) :
              (xt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
              (xt) : offset(ins)
            val x* = to-local(x(ins),0)
            val z* = to-local(z(ins),1)
            val y* = match(y(ins)) :
              (y:VMImm) : to-local(y,2)
              (y:False) : 0
            emit-ins-e(code, x*, y*, z*, offset*)
          (ins:LoadIns) :
            val code = load-opcode(z(ins), imm-type(x(ins)))
            val offset* = match(imm-type(y(ins))) :
              (yt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
              (yt) : offset(ins)
            val y* = to-local(y(ins),0)
            val z* = match(z(ins)) :
              (z:VMImm) : to-local(z,1)
              (z:False) : 0
            emit-ins-e(code, slot(x(ins)), y*, z*, offset*)
          (ins:Op0Ins) :
            val code = op0-opcode(op(ins))
            emit-ins-a(code, slot(x(ins)))
          (ins:Op1Ins) :
            match(op(ins)) :
              (op:InstanceofOp) :
                ;Push argument into register
                set-mem-reg(0, y(ins))
                val format = match-format(resolver, [[type(op)]])
                ;Emit typeof instruction
                emit-ins-c(TYPEOF-OPCODE, slot(x(ins)), format)
              (op) :
                val opcode = op1-opcode(op, imm-type(x(ins)), imm-type(y(ins)))
                match(opcode:Int) :
                  val x* = slot(x(ins))
                  val y* = to-local(y(ins), 0)
                  emit-ins-b(opcode, x*, y*)
                else :
                  set-local(slot(x(ins)), y(ins))
          (ins:Op2Ins) :
            val opcode = op2-opcode(op(ins), imm-type(x(ins)), imm-type(y(ins)))
            val x* = slot(x(ins))
            val y* = to-local(y(ins), 0)
            val z* = to-local(z(ins), 1)
            emit-ins-c(opcode, x*, y*, z*)
          (ins:GotoIns) :
            emit-ins-a(GOTO-OPCODE, jump-offset(n(ins)))
          (ins:Branch1Ins) :
            match(op(ins)) :
              (op:InstanceofOp) :
                emit-instanceof(n1(ins), n2(ins), x(ins), type(op))
              (op:False) :
                emit-ins-f(JUMP-SET-OPCODE, to-local(x(ins), 0), 0, jump-offset(n1(ins)), jump-offset(n2(ins)))
          (ins:Branch2Ins) :
            val code = branch2-opcode(op(ins), imm-type(x(ins)))
            val x* = to-local(x(ins), 0)
            val y* = to-local(y(ins), 1)
            emit-ins-f(code, x*, y*, jump-offset(n1(ins)), jump-offset(n2(ins)))
          (ins:AllocIns) :
            val continue-label = new-label(a)
            if all?({_ is NumConst}, sizes(ins)) :
              val num-obj = length(sizes(ins))
              val obj-sizes = for s in sizes(ins) map :
                object-size-on-heap(resolver, value(s as NumConst) as Int)
              ;Big sizes don't fit in instruction encoding
              val sum-of-sizes = object-size(num-obj, sum(obj-sizes))
              if sum-of-sizes >= 1024 :
                val size-local = to-local(NumConst(sum-of-sizes),0)
                emit-ins-c(RESERVE-OPCODE-LOCAL, continue-label, num-locals, size-local)
              else :
                emit-ins-c(RESERVE-OPCODE-CONST, continue-label, num-locals, sum-of-sizes)
              record-trace-entry(trace-entry(ins))
              emit-ins-a(POP-FRAME-OPCODE, num-locals)
              bind(a, continue-label)
              for (x in xs(ins), t in types(ins), sz in obj-sizes) do :
                ;Big object doesn't fit in instruction encoding
                if sz >= 1024 :
                  val size-local = to-local(NumConst(sz),0)
                  emit-ins-c(ALLOC-OPCODE-LOCAL, slot(x), size-local, t)
                else :
                  emit-ins-c(ALLOC-OPCODE-CONST, slot(x), sz, t)
            else:
              fatal("Multiple variable-sized allocations.") when length(sizes(ins)) > 1
              val x = xs(ins)[0]
              val type = types(ins)[0]
              val size = to-local(sizes(ins)[0], 0)
              emit-ins-c(RESERVE-OPCODE-LOCAL, continue-label, num-locals, size)
              record-trace-entry(trace-entry(ins))
              emit-ins-a(POP-FRAME-OPCODE, num-locals)
              bind(a, continue-label)
              emit-ins-c(ALLOC-OPCODE-LOCAL, slot(x), size, type)
          (ins:DispatchIns) :
            ;Push arguments onto registers
            set-mem-regs(ys(ins))
            val [types, dests] = split-types-and-dests(branches(ins))
            val format = dispatch-format(resolver, types)
            ;Two targets for default and amb and then each branch for dispatch.
            val num-targets = 2 + length(branches(ins))
            val targets = jump-offsets([default(ins), amb(ins)], dests)
            emit-ins-a(DISPATCH-OPCODE, format)
            emit-ins-targets(targets)
          (ins:MatchIns) :
            if all?(branch-is-final?, branches(ins)) :
              emit-final-match(ys(ins), branches(ins), default(ins))
            else :
              emit-non-final-match(ys(ins), branches(ins), default(ins))
          (ins:MethodDispatchIns) :
            ;Push arguments onto registers
            set-mem-regs(cat(ys(ins), zs(ins)))
            ;Retrieve format
            val format = method-format(resolver, multi(ins), length(ys(ins)), length(zs(ins)))
            ;Only two targets for default and amb
            val num-targets = 2
            val targets = jump-offsets([default(ins), amb(ins)])
            emit-ins-a(DISPATCH-METHOD-OPCODE, format)
            emit-ins-targets(targets)
          (ins:SetIns) :
            set-local(slot(x(ins)), y(ins))

      ;==================================================
      ;============= Immediate Utilities ================
      ;==================================================
      ;Retrieve type of immediate
      defn imm-type (x:VMImm) :
        match(x:Local) : type(deftable[index(x)])
        else : type(x)
      defn imm-type (x:VMType) :
        x

      ;Use deftable to retrieve the slot of a local
      defn slot (x:Local) :
        local(deftable[index(x)])

      ;==================================================
      ;============= Label Utilities ====================
      ;==================================================
      ;Create mapping from label ID to position
      defn jump-offset (n:Int) -> Label :
        maybe-add-new-label(n)
      defn jump-offsets (xs:Seqable<Int>) -> Tuple<Label> :
        to-tuple(seq(jump-offset, xs))
      defn jump-offsets (xs:Seqable<Int>, ys:Seqable<Int>) -> Tuple<Label> :
        jump-offsets(cat(xs,ys))

      ;Generate new unique label
      defn* gen-label () :
        val l = next(label-counter)
        gen-label() when used-labels[l] else l

      ;==================================================
      ;============= Compilation Utilities ==============
      ;==================================================
      ;Retrieve the corresponding bits for the given immediate
      defn to-bits (y:VMImm) -> Int|Long :
        match(y) :
          (y:Local) : slot(y)
          (y:NumConst) :
            match(value(y)) :
              (v:Char) : to-int(v)
              (v:Byte) : to-int(v)
              (v:Int) : v
              (v:Long) : v
              (v:Float) : bits(v)
              (v:Double) : bits(v)
          (y:Marker) : marker(resolver, typeid(y))
          (y:Tag) : typeid(y)
          (y:VoidMarker) : void-marker(resolver)
          (y:CodeId) : id(y)
          (y:ExternId) : extern-address(id(y))
          (y:GlobalId) : id(y)
          (y:DataId) : id(y)
          (y:ConstId) : id(y)

      ;Set register
      defn set-reg (i:Int, y:VMImm) :
        match(to-bits(y)) :
          (v:Int) : emit-ins-c(set-reg-opcode(y), i, v)
          (v:Long) : emit-ins-d(set-reg-opcode(y), i, v)
      defn set-regs (ys:Seqable<VMImm>) :
        do(set-reg, 0 to false, ys)
      defn set-mem-reg (i:Int, y:VMImm) :
        let-var MEM-REG-ONLY? = true :
          set-reg(i, y)
      defn set-mem-regs (ys:Seqable<VMImm>) :
        do(set-mem-reg, 0 to false, ys)

      defn get-reg (x:Local|VMType, i:Int) :
        match(x:Local) :
          emit-ins-b(GET-REG-OPCODE, slot(x), i)
      defn get-mem-reg (x:Local|VMType, i:Int) :
        let-var MEM-REG-ONLY? = true :
          get-reg(x, i)
      defn get-regs (xs:Seqable<Local|VMType>) :
        do(get-reg, xs, 0 to false)

      ;Set local
      defn set-local (x:Int, y:VMImm) :
        match(to-bits(y)) :
          (v:Int) : emit-ins-c(set-opcode(y), x, v)
          (v:Long) : emit-ins-d(set-opcode(y), x, v)

      ;Put immediate in temporary local if not a local
      defn to-local (x:VMImm, num:Int) :
        match(x:Local) :
          slot(x)
        else :
          val index = max-local + num + 1
          set-local(index, x)
          index

      ;Number of words needed to hold immediate in local
      defn words-for-to-local (x:VMImm) :
        match(x:Local) :
          0
        else :
          match(to-bits(x)) :
            (v:Int) : 2
            (v:Long) : 3

      ;Put immediate in register if not a function immediate
      defn to-function-local (f:VMImm) :
        match(f) :
          (f:CodeId) : id(f)
          (f) : to-local(f, 0)

      ;==================================================
      ;===================== Launch =====================
      ;==================================================
      driver()

    encode(func as VMMultifn|VMFunc)

  plop("FUNC 0x%_" % [hex(value(f))])
  EncodedFunction(f, trace-entry-table)

;============================================================
;======================= Opcodes ============================
;============================================================

val SET-OPCODE-LOCAL = 0
val SET-OPCODE-UNSIGNED = 1
val SET-OPCODE-SIGNED = 2
val SET-OPCODE-CODE = 3
val SET-OPCODE-GLOBAL = 5
val SET-OPCODE-DATA = 6
val SET-OPCODE-CONST = 7
val SET-OPCODE-WIDE = 8
val SET-REG-OPCODE-LOCAL = 9
val SET-REG-OPCODE-UNSIGNED = 10
val SET-REG-OPCODE-SIGNED = 11
val SET-REG-OPCODE-CODE = 12
val SET-REG-OPCODE-GLOBAL = 14
val SET-REG-OPCODE-DATA = 15
val SET-REG-OPCODE-CONST = 16
val SET-REG-OPCODE-WIDE = 17
val GET-REG-OPCODE = 18
val CALL-OPCODE-LOCAL = 19
val CALL-OPCODE-CODE = 20
val CALL-CLOSURE-OPCODE = 22
val TCALL-OPCODE-LOCAL = 23
val TCALL-OPCODE-CODE = 24
val TCALL-CLOSURE-OPCODE = 26
val CALLC-OPCODE-LOCAL = 27
val CALLC-OPCODE-WIDE = 28
val POP-FRAME-OPCODE = 30
val LIVE-OPCODE = 31
val YIELD-OPCODE = 32
val RETURN-OPCODE = 33
val DUMP-OPCODE = 34
;2-arity operations
val INT-ADD-OPCODE = 35
val INT-SUB-OPCODE = 36
val INT-MUL-OPCODE = 37
val INT-DIV-OPCODE = 38
val INT-MOD-OPCODE = 39
val INT-AND-OPCODE = 40
val INT-OR-OPCODE = 41
val INT-XOR-OPCODE = 42
val INT-SHL-OPCODE = 43
val INT-SHR-OPCODE = 44
val INT-ASHR-OPCODE = 45
val INT-LT-OPCODE = 46
val INT-GT-OPCODE = 47
val INT-LE-OPCODE = 48
val INT-GE-OPCODE = 49
val REF-EQ-OPCODE = 50
val EQ-OPCODE-REF = 51
val EQ-OPCODE-BYTE = 52
val EQ-OPCODE-INT = 53
val EQ-OPCODE-LONG = 54
val EQ-OPCODE-FLOAT = 55
val EQ-OPCODE-DOUBLE = 56
val REF-NE-OPCODE = 57
val NE-OPCODE-REF = 58
val NE-OPCODE-BYTE = 59
val NE-OPCODE-INT = 60
val NE-OPCODE-LONG = 61
val NE-OPCODE-FLOAT = 62
val NE-OPCODE-DOUBLE = 63
val ADD-OPCODE-BYTE = 64
val ADD-OPCODE-INT = 65
val ADD-OPCODE-LONG = 66
val ADD-OPCODE-FLOAT = 67
val ADD-OPCODE-DOUBLE = 68
val SUB-OPCODE-BYTE = 69
val SUB-OPCODE-INT = 70
val SUB-OPCODE-LONG = 71
val SUB-OPCODE-FLOAT = 72
val SUB-OPCODE-DOUBLE = 73
val MUL-OPCODE-BYTE = 74
val MUL-OPCODE-INT = 75
val MUL-OPCODE-LONG = 76
val MUL-OPCODE-FLOAT = 77
val MUL-OPCODE-DOUBLE = 78
val DIV-OPCODE-BYTE = 79
val DIV-OPCODE-INT = 80
val DIV-OPCODE-LONG = 81
val DIV-OPCODE-FLOAT = 82
val DIV-OPCODE-DOUBLE = 83
val MOD-OPCODE-BYTE = 84
val MOD-OPCODE-INT = 85
val MOD-OPCODE-LONG = 86
val AND-OPCODE-BYTE = 87
val AND-OPCODE-INT = 88
val AND-OPCODE-LONG = 89
val OR-OPCODE-BYTE = 90
val OR-OPCODE-INT = 91
val OR-OPCODE-LONG = 92
val XOR-OPCODE-BYTE = 93
val XOR-OPCODE-INT = 94
val XOR-OPCODE-LONG = 95
val SHL-OPCODE-BYTE = 96
val SHL-OPCODE-INT = 97
val SHL-OPCODE-LONG = 98
val SHR-OPCODE-BYTE = 99
val SHR-OPCODE-INT = 100
val SHR-OPCODE-LONG = 101
val ASHR-OPCODE-INT = 103
val ASHR-OPCODE-LONG = 104
val LT-OPCODE-INT = 105
val LT-OPCODE-LONG = 106
val LT-OPCODE-FLOAT = 107
val LT-OPCODE-DOUBLE = 108
val GT-OPCODE-INT = 109
val GT-OPCODE-LONG = 110
val GT-OPCODE-FLOAT = 111
val GT-OPCODE-DOUBLE = 112
val LE-OPCODE-INT = 113
val LE-OPCODE-LONG = 114
val LE-OPCODE-FLOAT = 115
val LE-OPCODE-DOUBLE = 116
val GE-OPCODE-INT = 117
val GE-OPCODE-LONG = 118
val GE-OPCODE-FLOAT = 119
val GE-OPCODE-DOUBLE = 120
val ULE-OPCODE-BYTE = 121
val ULE-OPCODE-INT = 122
val ULE-OPCODE-LONG = 123
val ULT-OPCODE-BYTE = 124
val ULT-OPCODE-INT = 125
val ULT-OPCODE-LONG = 126
val UGT-OPCODE-BYTE = 127
val UGT-OPCODE-INT = 128
val UGT-OPCODE-LONG = 129
val UGE-OPCODE-BYTE = 130
val UGE-OPCODE-INT = 131
val UGE-OPCODE-LONG = 132
;1-arity operations
val INT-NOT-OPCODE = 133
val INT-NEG-OPCODE = 134
val NOT-OPCODE-BYTE = 135
val NOT-OPCODE-INT = 136
val NOT-OPCODE-LONG = 137
val NEG-OPCODE-INT = 138
val NEG-OPCODE-LONG = 139
val NEG-OPCODE-FLOAT = 140
val NEG-OPCODE-DOUBLE = 141
val DEREF-OPCODE = 142
val TYPEOF-OPCODE = 143
;branch operation
val JUMP-SET-OPCODE = 144
val JUMP-TAGBITS-OPCODE = 240
val JUMP-TAGWORD-OPCODE = 242
val GOTO-OPCODE = 145
;conversion operations
val CONV-OPCODE-BYTE-FLOAT = 146
val CONV-OPCODE-BYTE-DOUBLE = 147
val CONV-OPCODE-INT-BYTE = 148
val CONV-OPCODE-INT-FLOAT = 149
val CONV-OPCODE-INT-DOUBLE = 150
val CONV-OPCODE-LONG-BYTE = 151
val CONV-OPCODE-LONG-INT = 152
val CONV-OPCODE-LONG-FLOAT = 153
val CONV-OPCODE-LONG-DOUBLE = 154
val CONV-OPCODE-FLOAT-BYTE = 155
val CONV-OPCODE-FLOAT-INT = 156
val CONV-OPCODE-FLOAT-LONG = 157
val CONV-OPCODE-FLOAT-DOUBLE = 158
val CONV-OPCODE-DOUBLE-BYTE = 159
val CONV-OPCODE-DOUBLE-INT = 160
val CONV-OPCODE-DOUBLE-LONG = 161
val CONV-OPCODE-DOUBLE-FLOAT = 162
;tagging operations
val DETAG-OPCODE = 163
val TAG-OPCODE-BYTE = 164
val TAG-OPCODE-CHAR = 165
val TAG-OPCODE-INT = 166
val TAG-OPCODE-FLOAT = 167
;storing operations
val STORE-OPCODE-1 = 168
val STORE-OPCODE-4 = 169
val STORE-OPCODE-8 = 170
val STORE-OPCODE-1-VAR-OFFSET = 171
val STORE-OPCODE-4-VAR-OFFSET = 172
val STORE-OPCODE-8-VAR-OFFSET = 173
;loading operations
val LOAD-OPCODE-1 = 174
val LOAD-OPCODE-4 = 175
val LOAD-OPCODE-8 = 176
val LOAD-OPCODE-1-VAR-OFFSET = 177
val LOAD-OPCODE-4-VAR-OFFSET = 178
val LOAD-OPCODE-8-VAR-OFFSET = 179
;Allocation
val RESERVE-OPCODE-LOCAL = 180
val RESERVE-OPCODE-CONST = 181
val ENTER-STACK-OPCODE = 182
val ALLOC-OPCODE-CONST = 183
val ALLOC-OPCODE-LOCAL = 184
;system operations
val GC-OPCODE = 185
val CLASS-NAME-OPCODE = 241
val C-RSP-OPCODE = 243
val PRINT-STACK-TRACE-OPCODE = 186
val COLLECT-STACK-TRACE-OPCODE = 187
val FLUSH-VM-OPCODE = 188
;2-arity branch operations
val JUMP-INT-LT-OPCODE = 192
val JUMP-INT-GT-OPCODE = 193
val JUMP-INT-LE-OPCODE = 194
val JUMP-INT-GE-OPCODE = 195
val JUMP-EQ-OPCODE-REF = 196
val JUMP-EQ-OPCODE-BYTE = 197
val JUMP-EQ-OPCODE-INT = 198
val JUMP-EQ-OPCODE-LONG = 199
val JUMP-EQ-OPCODE-FLOAT = 200
val JUMP-EQ-OPCODE-DOUBLE = 201
val JUMP-NE-OPCODE-REF = 202
val JUMP-NE-OPCODE-BYTE = 203
val JUMP-NE-OPCODE-INT = 204
val JUMP-NE-OPCODE-LONG = 205
val JUMP-NE-OPCODE-FLOAT = 206
val JUMP-NE-OPCODE-DOUBLE = 207
val JUMP-LT-OPCODE-INT = 208
val JUMP-LT-OPCODE-LONG = 209
val JUMP-LT-OPCODE-FLOAT = 210
val JUMP-LT-OPCODE-DOUBLE = 211
val JUMP-GT-OPCODE-INT = 212
val JUMP-GT-OPCODE-LONG = 213
val JUMP-GT-OPCODE-FLOAT = 214
val JUMP-GT-OPCODE-DOUBLE = 215
val JUMP-LE-OPCODE-INT = 216
val JUMP-LE-OPCODE-LONG = 217
val JUMP-LE-OPCODE-FLOAT = 218
val JUMP-LE-OPCODE-DOUBLE = 219
val JUMP-GE-OPCODE-INT = 220
val JUMP-GE-OPCODE-LONG = 221
val JUMP-GE-OPCODE-FLOAT = 222
val JUMP-GE-OPCODE-DOUBLE = 223
val JUMP-ULE-OPCODE-BYTE = 224
val JUMP-ULE-OPCODE-INT = 225
val JUMP-ULE-OPCODE-LONG = 226
val JUMP-ULT-OPCODE-BYTE = 227
val JUMP-ULT-OPCODE-INT = 228
val JUMP-ULT-OPCODE-LONG = 229
val JUMP-UGT-OPCODE-BYTE = 230
val JUMP-UGT-OPCODE-INT = 231
val JUMP-UGT-OPCODE-LONG = 232
val JUMP-UGE-OPCODE-BYTE = 233
val JUMP-UGE-OPCODE-INT = 234
val JUMP-UGE-OPCODE-LONG = 235
;dispatch operation
val DISPATCH-OPCODE = 236
val DISPATCH-METHOD-OPCODE = 237
;jump on register
val JUMP-REG-OPCODE = 238
;function entry
val FNENTRY-OPCODE = 239

defn set-reg-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-REG-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-REG-OPCODE-UNSIGNED
        (v:Byte) : SET-REG-OPCODE-UNSIGNED
        (v:Int) : SET-REG-OPCODE-UNSIGNED
        (v:Long) : SET-REG-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-REG-OPCODE-UNSIGNED
        (v:Double) : SET-REG-OPCODE-WIDE
    (y:Marker) : SET-REG-OPCODE-UNSIGNED
    (y:Tag) : SET-REG-OPCODE-UNSIGNED
    (y:CodeId) : SET-REG-OPCODE-CODE
    (y:ExternId) : SET-REG-OPCODE-WIDE
    (y:GlobalId) : SET-REG-OPCODE-GLOBAL
    (y:DataId) : SET-REG-OPCODE-DATA
    (y:ConstId) : SET-REG-OPCODE-CONST
    (y:VoidMarker) : SET-REG-OPCODE-UNSIGNED

defn set-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-OPCODE-UNSIGNED
        (v:Byte) : SET-OPCODE-UNSIGNED
        (v:Int) : SET-OPCODE-UNSIGNED
        (v:Long) : SET-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-OPCODE-UNSIGNED
        (v:Double) : SET-OPCODE-WIDE
    (y:Marker) : SET-OPCODE-UNSIGNED
    (y:Tag) : SET-OPCODE-UNSIGNED
    (y:CodeId) : SET-OPCODE-CODE
    (y:ExternId) : SET-OPCODE-WIDE
    (y:GlobalId) : SET-OPCODE-GLOBAL
    (y:DataId) : SET-OPCODE-DATA
    (y:ConstId) : SET-OPCODE-CONST
    (y:VoidMarker) : SET-OPCODE-UNSIGNED

defn call-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALL-OPCODE-LOCAL
    (f:CodeId) : CALL-OPCODE-CODE

defn callc-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALLC-OPCODE-LOCAL
    (f:ExternId) :  CALLC-OPCODE-WIDE

defn tcall-opcode (f:VMImm) :
  match(f) :
    (f:Local) : TCALL-OPCODE-LOCAL
    (f:CodeId) : TCALL-OPCODE-CODE

defn store-opcode (offset:VMImm|False, val-type:VMType) :
  match(offset, val-type) :
    (o:False, vt:VMByte) : STORE-OPCODE-1
    (o:False, vt:VMInt) : STORE-OPCODE-4
    (o:False, vt:VMLong) : STORE-OPCODE-8
    (o:False, vt:VMFloat) : STORE-OPCODE-4
    (o:False, vt:VMDouble) : STORE-OPCODE-8
    (o:False, vt:VMRef) : STORE-OPCODE-8
    (o:VMImm, vt:VMByte) : STORE-OPCODE-1-VAR-OFFSET
    (o:VMImm, vt:VMInt) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMLong) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMFloat) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMDouble) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMRef) : STORE-OPCODE-8-VAR-OFFSET

defn load-opcode (offset:VMImm|False, xtype:VMType) :
  match(offset, xtype) :
    (o:False, xt:VMByte) : LOAD-OPCODE-1
    (o:False, xt:VMInt) : LOAD-OPCODE-4
    (o:False, xt:VMLong) : LOAD-OPCODE-8
    (o:False, xt:VMFloat) : LOAD-OPCODE-4
    (o:False, xt:VMDouble) : LOAD-OPCODE-8
    (o:False, xt:VMRef) : LOAD-OPCODE-8
    (o:VMImm, xt:VMByte) : LOAD-OPCODE-1-VAR-OFFSET
    (o:VMImm, xt:VMInt) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMLong) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMFloat) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMDouble) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMRef) : LOAD-OPCODE-8-VAR-OFFSET

defn op0-opcode (op:VMOp) :
  match(op) :
    (op:FlushVMOp) : FLUSH-VM-OPCODE
    (op:CRSPOp) : C-RSP-OPCODE

;Returns false if operation becomes a set operation.
defn op1-opcode (op:VMOp, xt:VMType, yt:VMType) -> Int|False :
  match(op, xt, yt) :
    (op:IntNotOp, xt:VMRef, yt:VMRef) : INT-NOT-OPCODE
    (op:IntNegOp, xt:VMRef, yt:VMRef) : INT-NEG-OPCODE
    (op:NotOp, xt:VMByte, yt:VMByte) : NOT-OPCODE-BYTE
    (op:NotOp, xt:VMInt, yt:VMInt) : NOT-OPCODE-INT
    (op:NotOp, xt:VMLong, yt:VMLong) : NOT-OPCODE-LONG
    (op:NegOp, xt:VMInt, yt:VMInt) : NEG-OPCODE-INT
    (op:NegOp, xt:VMLong, yt:VMLong) : NEG-OPCODE-LONG
    (op:NegOp, xt:VMFloat, yt:VMFloat) : NEG-OPCODE-FLOAT
    (op:NegOp, xt:VMDouble, yt:VMDouble) : NEG-OPCODE-DOUBLE
    (op:InterpretOp, xt, yt) : false
    (op:ConvOp, xt:VMByte, yt:VMByte) : false
    (op:ConvOp, xt:VMByte, yt:VMInt) : false
    (op:ConvOp, xt:VMByte, yt:VMLong) : false
    (op:ConvOp, xt:VMByte, yt:VMFloat) : CONV-OPCODE-BYTE-FLOAT
    (op:ConvOp, xt:VMByte, yt:VMDouble) : CONV-OPCODE-BYTE-DOUBLE
    (op:ConvOp, xt:VMInt, yt:VMByte) : CONV-OPCODE-INT-BYTE
    (op:ConvOp, xt:VMInt, yt:VMInt) : false
    (op:ConvOp, xt:VMInt, yt:VMLong) : false
    (op:ConvOp, xt:VMInt, yt:VMFloat) : CONV-OPCODE-INT-FLOAT
    (op:ConvOp, xt:VMInt, yt:VMDouble) : CONV-OPCODE-INT-DOUBLE
    (op:ConvOp, xt:VMLong, yt:VMByte) : CONV-OPCODE-LONG-BYTE
    (op:ConvOp, xt:VMLong, yt:VMInt) : CONV-OPCODE-LONG-INT
    (op:ConvOp, xt:VMLong, yt:VMLong) : false
    (op:ConvOp, xt:VMLong, yt:VMFloat) : CONV-OPCODE-LONG-FLOAT
    (op:ConvOp, xt:VMLong, yt:VMDouble) : CONV-OPCODE-LONG-DOUBLE
    (op:ConvOp, xt:VMFloat, yt:VMByte) : CONV-OPCODE-FLOAT-BYTE
    (op:ConvOp, xt:VMFloat, yt:VMInt) : CONV-OPCODE-FLOAT-INT
    (op:ConvOp, xt:VMFloat, yt:VMLong) : CONV-OPCODE-FLOAT-LONG
    (op:ConvOp, xt:VMFloat, yt:VMFloat) : false
    (op:ConvOp, xt:VMFloat, yt:VMDouble) : CONV-OPCODE-FLOAT-DOUBLE
    (op:ConvOp, xt:VMDouble, yt:VMByte) : CONV-OPCODE-DOUBLE-BYTE
    (op:ConvOp, xt:VMDouble, yt:VMInt) : CONV-OPCODE-DOUBLE-INT
    (op:ConvOp, xt:VMDouble, yt:VMLong) : CONV-OPCODE-DOUBLE-LONG
    (op:ConvOp, xt:VMDouble, yt:VMFloat) : CONV-OPCODE-DOUBLE-FLOAT
    (op:ConvOp, xt:VMDouble, yt:VMDouble) : false
    (op:TagOp, xt, yt) :
      switch(type(op)) :
        BYTE-TYPE : TAG-OPCODE-BYTE
        CHAR-TYPE : TAG-OPCODE-CHAR
        INT-TYPE : TAG-OPCODE-INT
        FLOAT-TYPE : TAG-OPCODE-FLOAT
    (op:DetagOp, xt, yt) : DETAG-OPCODE
    (op:DerefOp, xt, yt) : DEREF-OPCODE
    (op:GCOp, xt, yt) : GC-OPCODE
    (op:ClassNameOp, xt, yt) : CLASS-NAME-OPCODE
    (op:PrintStackTraceOp, xt, yt) : PRINT-STACK-TRACE-OPCODE
    (op:CollectStackTraceOp, xt, yt) : COLLECT-STACK-TRACE-OPCODE

defn op2-opcode (op:VMOp, xt:VMType, yt:VMType) :
  match(op, xt, yt) :
    (op:IntAddOp, xt:VMRef, yt:VMRef) : INT-ADD-OPCODE
    (op:IntSubOp, xt:VMRef, yt:VMRef) : INT-SUB-OPCODE
    (op:IntMulOp, xt:VMRef, yt:VMRef) : INT-MUL-OPCODE
    (op:IntDivOp, xt:VMRef, yt:VMRef) : INT-DIV-OPCODE
    (op:IntModOp, xt:VMRef, yt:VMRef) : INT-MOD-OPCODE
    (op:IntAndOp, xt:VMRef, yt:VMRef) : INT-AND-OPCODE
    (op:IntOrOp, xt:VMRef, yt:VMRef) : INT-OR-OPCODE
    (op:IntXorOp, xt:VMRef, yt:VMRef) : INT-XOR-OPCODE
    (op:IntShlOp, xt:VMRef, yt:VMRef) : INT-SHL-OPCODE
    (op:IntShrOp, xt:VMRef, yt:VMRef) : INT-SHR-OPCODE
    (op:IntAshrOp, xt:VMRef, yt:VMRef) : INT-ASHR-OPCODE
    (op:IntLtOp, xt:VMRef, yt:VMRef) : INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef, yt:VMRef) : INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef, yt:VMRef) : INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef, yt:VMRef) : INT-GE-OPCODE
    (op:RefEqOp, xt:VMRef, yt:VMRef) : REF-EQ-OPCODE
    (op:RefNeOp, xt:VMRef, yt:VMRef) : REF-NE-OPCODE
    (op:EqOp, xt:VMLong, yt:VMRef) : EQ-OPCODE-REF
    (op:EqOp, xt:VMLong, yt:VMByte) : EQ-OPCODE-BYTE
    (op:EqOp, xt:VMLong, yt:VMInt) : EQ-OPCODE-INT
    (op:EqOp, xt:VMLong, yt:VMLong) : EQ-OPCODE-LONG
    (op:EqOp, xt:VMLong, yt:VMFloat) : EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMLong, yt:VMDouble) : EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMLong, yt:VMRef) : NE-OPCODE-REF
    (op:NeOp, xt:VMLong, yt:VMByte) : NE-OPCODE-BYTE
    (op:NeOp, xt:VMLong, yt:VMInt) : NE-OPCODE-INT
    (op:NeOp, xt:VMLong, yt:VMLong) : NE-OPCODE-LONG
    (op:NeOp, xt:VMLong, yt:VMFloat) : NE-OPCODE-FLOAT
    (op:NeOp, xt:VMLong, yt:VMDouble) : NE-OPCODE-DOUBLE
    (op:AddOp, xt:VMByte, yt:VMByte) : ADD-OPCODE-BYTE
    (op:AddOp, xt:VMInt, yt:VMInt) : ADD-OPCODE-INT
    (op:AddOp, xt:VMLong, yt:VMLong) : ADD-OPCODE-LONG
    (op:AddOp, xt:VMFloat, yt:VMFloat) : ADD-OPCODE-FLOAT
    (op:AddOp, xt:VMDouble, yt:VMDouble) : ADD-OPCODE-DOUBLE
    (op:SubOp, xt:VMByte, yt:VMByte) : SUB-OPCODE-BYTE
    (op:SubOp, xt:VMInt, yt:VMInt) : SUB-OPCODE-INT
    (op:SubOp, xt:VMLong, yt:VMLong) : SUB-OPCODE-LONG
    (op:SubOp, xt:VMFloat, yt:VMFloat) : SUB-OPCODE-FLOAT
    (op:SubOp, xt:VMDouble, yt:VMDouble) : SUB-OPCODE-DOUBLE
    (op:MulOp, xt:VMByte, yt:VMByte) : MUL-OPCODE-BYTE
    (op:MulOp, xt:VMInt, yt:VMInt) : MUL-OPCODE-INT
    (op:MulOp, xt:VMLong, yt:VMLong) : MUL-OPCODE-LONG
    (op:MulOp, xt:VMFloat, yt:VMFloat) : MUL-OPCODE-FLOAT
    (op:MulOp, xt:VMDouble, yt:VMDouble) : MUL-OPCODE-DOUBLE
    (op:DivOp, xt:VMByte, yt:VMByte) : DIV-OPCODE-BYTE
    (op:DivOp, xt:VMInt, yt:VMInt) : DIV-OPCODE-INT
    (op:DivOp, xt:VMLong, yt:VMLong) : DIV-OPCODE-LONG
    (op:DivOp, xt:VMFloat, yt:VMFloat) : DIV-OPCODE-FLOAT
    (op:DivOp, xt:VMDouble, yt:VMDouble) : DIV-OPCODE-DOUBLE
    (op:ModOp, xt:VMByte, yt:VMByte) : MOD-OPCODE-BYTE
    (op:ModOp, xt:VMInt, yt:VMInt) : MOD-OPCODE-INT
    (op:ModOp, xt:VMLong, yt:VMLong) : MOD-OPCODE-LONG
    (op:AndOp, xt:VMByte, yt:VMByte) : AND-OPCODE-BYTE
    (op:AndOp, xt:VMInt, yt:VMInt) : AND-OPCODE-INT
    (op:AndOp, xt:VMLong, yt:VMLong) : AND-OPCODE-LONG
    (op:OrOp, xt:VMByte, yt:VMByte) : OR-OPCODE-BYTE
    (op:OrOp, xt:VMInt, yt:VMInt) : OR-OPCODE-INT
    (op:OrOp, xt:VMLong, yt:VMLong) : OR-OPCODE-LONG
    (op:XorOp, xt:VMByte, yt:VMByte) : XOR-OPCODE-BYTE
    (op:XorOp, xt:VMInt, yt:VMInt) : XOR-OPCODE-INT
    (op:XorOp, xt:VMLong, yt:VMLong) : XOR-OPCODE-LONG
    (op:ShlOp, xt:VMByte, yt:VMByte) : SHL-OPCODE-BYTE
    (op:ShlOp, xt:VMInt, yt:VMInt) : SHL-OPCODE-INT
    (op:ShlOp, xt:VMLong, yt:VMLong) : SHL-OPCODE-LONG
    (op:ShrOp, xt:VMByte, yt:VMByte) : SHR-OPCODE-BYTE
    (op:ShrOp, xt:VMInt, yt:VMInt) : SHR-OPCODE-INT
    (op:ShrOp, xt:VMLong, yt:VMLong) : SHR-OPCODE-LONG
    (op:AshrOp, xt:VMInt, yt:VMInt) : ASHR-OPCODE-INT
    (op:AshrOp, xt:VMLong, yt:VMLong) : ASHR-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMInt) : LT-OPCODE-INT
    (op:LtOp, xt:VMLong, yt:VMLong) : LT-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMFloat) : LT-OPCODE-FLOAT
    (op:LtOp, xt:VMLong, yt:VMDouble) : LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMLong, yt:VMInt) : GT-OPCODE-INT
    (op:GtOp, xt:VMLong, yt:VMLong) : GT-OPCODE-LONG
    (op:GtOp, xt:VMLong, yt:VMFloat) : GT-OPCODE-FLOAT
    (op:GtOp, xt:VMLong, yt:VMDouble) : GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMLong, yt:VMInt) : LE-OPCODE-INT
    (op:LeOp, xt:VMLong, yt:VMLong) : LE-OPCODE-LONG
    (op:LeOp, xt:VMLong, yt:VMFloat) : LE-OPCODE-FLOAT
    (op:LeOp, xt:VMLong, yt:VMDouble) : LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMLong, yt:VMInt) : GE-OPCODE-INT
    (op:GeOp, xt:VMLong, yt:VMLong) : GE-OPCODE-LONG
    (op:GeOp, xt:VMLong, yt:VMFloat) : GE-OPCODE-FLOAT
    (op:GeOp, xt:VMLong, yt:VMDouble) : GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMLong, yt:VMByte) : ULT-OPCODE-BYTE
    (op:UltOp, xt:VMLong, yt:VMInt) : ULT-OPCODE-INT
    (op:UltOp, xt:VMLong, yt:VMLong) : ULT-OPCODE-LONG
    (op:UleOp, xt:VMLong, yt:VMByte) : ULE-OPCODE-BYTE
    (op:UleOp, xt:VMLong, yt:VMInt) : ULE-OPCODE-INT
    (op:UleOp, xt:VMLong, yt:VMLong) : ULE-OPCODE-LONG
    (op:UgtOp, xt:VMLong, yt:VMByte) : UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMLong, yt:VMInt) : UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong, yt:VMLong) : UGT-OPCODE-LONG
    (op:UgeOp, xt:VMLong, yt:VMByte) : UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMLong, yt:VMInt) : UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong, yt:VMLong) : UGE-OPCODE-LONG

defn branch2-opcode (op:VMOp, xt:VMType) :
  match(op, xt) :
    (op:IntLtOp, xt:VMRef) : JUMP-INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef) : JUMP-INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef) : JUMP-INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef) : JUMP-INT-GE-OPCODE
    (op:EqOp, xt:VMRef) : JUMP-EQ-OPCODE-REF
    (op:EqOp, xt:VMByte) : JUMP-EQ-OPCODE-BYTE
    (op:EqOp, xt:VMInt) : JUMP-EQ-OPCODE-INT
    (op:EqOp, xt:VMLong) : JUMP-EQ-OPCODE-LONG
    (op:EqOp, xt:VMFloat) : JUMP-EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMDouble) : JUMP-EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef) : JUMP-NE-OPCODE-REF
    (op:NeOp, xt:VMByte) : JUMP-NE-OPCODE-BYTE
    (op:NeOp, xt:VMInt) : JUMP-NE-OPCODE-INT
    (op:NeOp, xt:VMLong) : JUMP-NE-OPCODE-LONG
    (op:NeOp, xt:VMFloat) : JUMP-NE-OPCODE-FLOAT
    (op:NeOp, xt:VMDouble) : JUMP-NE-OPCODE-DOUBLE
    (op:LtOp, xt:VMInt) : JUMP-LT-OPCODE-INT
    (op:LtOp, xt:VMLong) : JUMP-LT-OPCODE-LONG
    (op:LtOp, xt:VMFloat) : JUMP-LT-OPCODE-FLOAT
    (op:LtOp, xt:VMDouble) : JUMP-LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMInt) : JUMP-GT-OPCODE-INT
    (op:GtOp, xt:VMLong) : JUMP-GT-OPCODE-LONG
    (op:GtOp, xt:VMFloat) : JUMP-GT-OPCODE-FLOAT
    (op:GtOp, xt:VMDouble) : JUMP-GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMInt) : JUMP-LE-OPCODE-INT
    (op:LeOp, xt:VMLong) : JUMP-LE-OPCODE-LONG
    (op:LeOp, xt:VMFloat) : JUMP-LE-OPCODE-FLOAT
    (op:LeOp, xt:VMDouble) : JUMP-LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMInt) : JUMP-GE-OPCODE-INT
    (op:GeOp, xt:VMLong) : JUMP-GE-OPCODE-LONG
    (op:GeOp, xt:VMFloat) : JUMP-GE-OPCODE-FLOAT
    (op:GeOp, xt:VMDouble) : JUMP-GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMByte) : JUMP-ULT-OPCODE-BYTE
    (op:UltOp, xt:VMInt) : JUMP-ULT-OPCODE-INT
    (op:UltOp, xt:VMLong) : JUMP-ULT-OPCODE-LONG
    (op:UleOp, xt:VMByte) : JUMP-ULE-OPCODE-BYTE
    (op:UleOp, xt:VMInt) : JUMP-ULE-OPCODE-INT
    (op:UleOp, xt:VMLong) : JUMP-ULE-OPCODE-LONG
    (op:UgtOp, xt:VMByte) : JUMP-UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMInt) : JUMP-UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong) : JUMP-UGT-OPCODE-LONG
    (op:UgeOp, xt:VMByte) : JUMP-UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMInt) : JUMP-UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong) : JUMP-UGE-OPCODE-LONG

;For debugging and tracing
public val opcode-names = IntTable<String>()
opcode-names[SET-OPCODE-LOCAL] = "SET-OPCODE-LOCAL"
opcode-names[SET-OPCODE-UNSIGNED] = "SET-OPCODE-UNSIGNED"
opcode-names[SET-OPCODE-SIGNED] = "SET-OPCODE-SIGNED"
opcode-names[SET-OPCODE-CODE] = "SET-OPCODE-CODE"
opcode-names[SET-OPCODE-GLOBAL] = "SET-OPCODE-GLOBAL"
opcode-names[SET-OPCODE-DATA] = "SET-OPCODE-DATA"
opcode-names[SET-OPCODE-CONST] = "SET-OPCODE-CONST"
opcode-names[SET-OPCODE-WIDE] = "SET-OPCODE-WIDE"
opcode-names[SET-REG-OPCODE-LOCAL] = "SET-REG-OPCODE-LOCAL"
opcode-names[SET-REG-OPCODE-UNSIGNED] = "SET-REG-OPCODE-UNSIGNED"
opcode-names[SET-REG-OPCODE-SIGNED] = "SET-REG-OPCODE-SIGNED"
opcode-names[SET-REG-OPCODE-CODE] = "SET-REG-OPCODE-CODE"
opcode-names[SET-REG-OPCODE-GLOBAL] = "SET-REG-OPCODE-GLOBAL"
opcode-names[SET-REG-OPCODE-DATA] = "SET-REG-OPCODE-DATA"
opcode-names[SET-REG-OPCODE-CONST] = "SET-REG-OPCODE-CONST"
opcode-names[SET-REG-OPCODE-WIDE] = "SET-REG-OPCODE-WIDE"
opcode-names[GET-REG-OPCODE] = "GET-REG-OPCODE"
opcode-names[CALL-OPCODE-LOCAL] = "CALL-OPCODE-LOCAL"
opcode-names[CALL-OPCODE-CODE] = "CALL-OPCODE-CODE"
opcode-names[CALL-CLOSURE-OPCODE] = "CALL-CLOSURE-OPCODE"
opcode-names[TCALL-OPCODE-LOCAL] = "TCALL-OPCODE-LOCAL"
opcode-names[TCALL-OPCODE-CODE] = "TCALL-OPCODE-CODE"
opcode-names[TCALL-CLOSURE-OPCODE] = "TCALL-CLOSURE-OPCODE"
opcode-names[CALLC-OPCODE-LOCAL] = "CALLC-OPCODE-LOCAL"
opcode-names[CALLC-OPCODE-WIDE] = "CALLC-OPCODE-WIDE"
opcode-names[POP-FRAME-OPCODE] = "POP-FRAME-OPCODE"
opcode-names[LIVE-OPCODE] = "LIVE-OPCODE"
opcode-names[YIELD-OPCODE] = "YIELD-OPCODE"
opcode-names[RETURN-OPCODE] = "RETURN-OPCODE"
opcode-names[DUMP-OPCODE] = "DUMP-OPCODE"
opcode-names[INT-ADD-OPCODE] = "INT-ADD-OPCODE"
opcode-names[INT-SUB-OPCODE] = "INT-SUB-OPCODE"
opcode-names[INT-MUL-OPCODE] = "INT-MUL-OPCODE"
opcode-names[INT-DIV-OPCODE] = "INT-DIV-OPCODE"
opcode-names[INT-MOD-OPCODE] = "INT-MOD-OPCODE"
opcode-names[INT-AND-OPCODE] = "INT-AND-OPCODE"
opcode-names[INT-OR-OPCODE] = "INT-OR-OPCODE"
opcode-names[INT-XOR-OPCODE] = "INT-XOR-OPCODE"
opcode-names[INT-SHL-OPCODE] = "INT-SHL-OPCODE"
opcode-names[INT-SHR-OPCODE] = "INT-SHR-OPCODE"
opcode-names[INT-ASHR-OPCODE] = "INT-ASHR-OPCODE"
opcode-names[INT-LT-OPCODE] = "INT-LT-OPCODE"
opcode-names[INT-GT-OPCODE] = "INT-GT-OPCODE"
opcode-names[INT-LE-OPCODE] = "INT-LE-OPCODE"
opcode-names[INT-GE-OPCODE] = "INT-GE-OPCODE"
opcode-names[REF-EQ-OPCODE] = "REF-EQ-OPCODE"
opcode-names[EQ-OPCODE-REF] = "EQ-OPCODE-REF"
opcode-names[EQ-OPCODE-BYTE] = "EQ-OPCODE-BYTE"
opcode-names[EQ-OPCODE-INT] = "EQ-OPCODE-INT"
opcode-names[EQ-OPCODE-LONG] = "EQ-OPCODE-LONG"
opcode-names[EQ-OPCODE-FLOAT] = "EQ-OPCODE-FLOAT"
opcode-names[EQ-OPCODE-DOUBLE] = "EQ-OPCODE-DOUBLE"
opcode-names[REF-NE-OPCODE] = "REF-NE-OPCODE"
opcode-names[NE-OPCODE-REF] = "NE-OPCODE-REF"
opcode-names[NE-OPCODE-BYTE] = "NE-OPCODE-BYTE"
opcode-names[NE-OPCODE-INT] = "NE-OPCODE-INT"
opcode-names[NE-OPCODE-LONG] = "NE-OPCODE-LONG"
opcode-names[NE-OPCODE-FLOAT] = "NE-OPCODE-FLOAT"
opcode-names[NE-OPCODE-DOUBLE] = "NE-OPCODE-DOUBLE"
opcode-names[ADD-OPCODE-BYTE] = "ADD-OPCODE-BYTE"
opcode-names[ADD-OPCODE-INT] = "ADD-OPCODE-INT"
opcode-names[ADD-OPCODE-LONG] = "ADD-OPCODE-LONG"
opcode-names[ADD-OPCODE-FLOAT] = "ADD-OPCODE-FLOAT"
opcode-names[ADD-OPCODE-DOUBLE] = "ADD-OPCODE-DOUBLE"
opcode-names[SUB-OPCODE-BYTE] = "SUB-OPCODE-BYTE"
opcode-names[SUB-OPCODE-INT] = "SUB-OPCODE-INT"
opcode-names[SUB-OPCODE-LONG] = "SUB-OPCODE-LONG"
opcode-names[SUB-OPCODE-FLOAT] = "SUB-OPCODE-FLOAT"
opcode-names[SUB-OPCODE-DOUBLE] = "SUB-OPCODE-DOUBLE"
opcode-names[MUL-OPCODE-BYTE] = "MUL-OPCODE-BYTE"
opcode-names[MUL-OPCODE-INT] = "MUL-OPCODE-INT"
opcode-names[MUL-OPCODE-LONG] = "MUL-OPCODE-LONG"
opcode-names[MUL-OPCODE-FLOAT] = "MUL-OPCODE-FLOAT"
opcode-names[MUL-OPCODE-DOUBLE] = "MUL-OPCODE-DOUBLE"
opcode-names[DIV-OPCODE-BYTE] = "DIV-OPCODE-BYTE"
opcode-names[DIV-OPCODE-INT] = "DIV-OPCODE-INT"
opcode-names[DIV-OPCODE-LONG] = "DIV-OPCODE-LONG"
opcode-names[DIV-OPCODE-FLOAT] = "DIV-OPCODE-FLOAT"
opcode-names[DIV-OPCODE-DOUBLE] = "DIV-OPCODE-DOUBLE"
opcode-names[MOD-OPCODE-BYTE] = "MOD-OPCODE-BYTE"
opcode-names[MOD-OPCODE-INT] = "MOD-OPCODE-INT"
opcode-names[MOD-OPCODE-LONG] = "MOD-OPCODE-LONG"
opcode-names[AND-OPCODE-BYTE] = "AND-OPCODE-BYTE"
opcode-names[AND-OPCODE-INT] = "AND-OPCODE-INT"
opcode-names[AND-OPCODE-LONG] = "AND-OPCODE-LONG"
opcode-names[OR-OPCODE-BYTE] = "OR-OPCODE-BYTE"
opcode-names[OR-OPCODE-INT] = "OR-OPCODE-INT"
opcode-names[OR-OPCODE-LONG] = "OR-OPCODE-LONG"
opcode-names[XOR-OPCODE-BYTE] = "XOR-OPCODE-BYTE"
opcode-names[XOR-OPCODE-INT] = "XOR-OPCODE-INT"
opcode-names[XOR-OPCODE-LONG] = "XOR-OPCODE-LONG"
opcode-names[SHL-OPCODE-BYTE] = "SHL-OPCODE-BYTE"
opcode-names[SHL-OPCODE-INT] = "SHL-OPCODE-INT"
opcode-names[SHL-OPCODE-LONG] = "SHL-OPCODE-LONG"
opcode-names[SHR-OPCODE-BYTE] = "SHR-OPCODE-BYTE"
opcode-names[SHR-OPCODE-INT] = "SHR-OPCODE-INT"
opcode-names[SHR-OPCODE-LONG] = "SHR-OPCODE-LONG"
opcode-names[ASHR-OPCODE-INT] = "ASHR-OPCODE-INT"
opcode-names[ASHR-OPCODE-LONG] = "ASHR-OPCODE-LONG"
opcode-names[LT-OPCODE-INT] = "LT-OPCODE-INT"
opcode-names[LT-OPCODE-LONG] = "LT-OPCODE-LONG"
opcode-names[LT-OPCODE-FLOAT] = "LT-OPCODE-FLOAT"
opcode-names[LT-OPCODE-DOUBLE] = "LT-OPCODE-DOUBLE"
opcode-names[GT-OPCODE-INT] = "GT-OPCODE-INT"
opcode-names[GT-OPCODE-LONG] = "GT-OPCODE-LONG"
opcode-names[GT-OPCODE-FLOAT] = "GT-OPCODE-FLOAT"
opcode-names[GT-OPCODE-DOUBLE] = "GT-OPCODE-DOUBLE"
opcode-names[LE-OPCODE-INT] = "LE-OPCODE-INT"
opcode-names[LE-OPCODE-LONG] = "LE-OPCODE-LONG"
opcode-names[LE-OPCODE-FLOAT] = "LE-OPCODE-FLOAT"
opcode-names[LE-OPCODE-DOUBLE] = "LE-OPCODE-DOUBLE"
opcode-names[GE-OPCODE-INT] = "GE-OPCODE-INT"
opcode-names[GE-OPCODE-LONG] = "GE-OPCODE-LONG"
opcode-names[GE-OPCODE-FLOAT] = "GE-OPCODE-FLOAT"
opcode-names[GE-OPCODE-DOUBLE] = "GE-OPCODE-DOUBLE"
opcode-names[ULE-OPCODE-BYTE] = "ULE-OPCODE-BYTE"
opcode-names[ULE-OPCODE-INT] = "ULE-OPCODE-INT"
opcode-names[ULE-OPCODE-LONG] = "ULE-OPCODE-LONG"
opcode-names[ULT-OPCODE-BYTE] = "ULT-OPCODE-BYTE"
opcode-names[ULT-OPCODE-INT] = "ULT-OPCODE-INT"
opcode-names[ULT-OPCODE-LONG] = "ULT-OPCODE-LONG"
opcode-names[UGT-OPCODE-BYTE] = "UGT-OPCODE-BYTE"
opcode-names[UGT-OPCODE-INT] = "UGT-OPCODE-INT"
opcode-names[UGT-OPCODE-LONG] = "UGT-OPCODE-LONG"
opcode-names[UGE-OPCODE-BYTE] = "UGE-OPCODE-BYTE"
opcode-names[UGE-OPCODE-INT] = "UGE-OPCODE-INT"
opcode-names[UGE-OPCODE-LONG] = "UGE-OPCODE-LONG"
opcode-names[INT-NOT-OPCODE] = "INT-NOT-OPCODE"
opcode-names[INT-NEG-OPCODE] = "INT-NEG-OPCODE"
opcode-names[NOT-OPCODE-BYTE] = "NOT-OPCODE-BYTE"
opcode-names[NOT-OPCODE-INT] = "NOT-OPCODE-INT"
opcode-names[NOT-OPCODE-LONG] = "NOT-OPCODE-LONG"
opcode-names[NEG-OPCODE-INT] = "NEG-OPCODE-INT"
opcode-names[NEG-OPCODE-LONG] = "NEG-OPCODE-LONG"
opcode-names[NEG-OPCODE-FLOAT] = "NEG-OPCODE-FLOAT"
opcode-names[NEG-OPCODE-DOUBLE] = "NEG-OPCODE-DOUBLE"
opcode-names[DEREF-OPCODE] = "DEREF-OPCODE"
opcode-names[TYPEOF-OPCODE] = "TYPEOF-OPCODE"
opcode-names[JUMP-SET-OPCODE] = "JUMP-SET-OPCODE"
opcode-names[JUMP-TAGBITS-OPCODE] = "JUMP-TAGBITS-OPCODE"
opcode-names[JUMP-TAGWORD-OPCODE] = "JUMP-TAGWORD-OPCODE"
opcode-names[GOTO-OPCODE] = "GOTO-OPCODE"
opcode-names[CONV-OPCODE-BYTE-FLOAT] = "CONV-OPCODE-BYTE-FLOAT"
opcode-names[CONV-OPCODE-BYTE-DOUBLE] = "CONV-OPCODE-BYTE-DOUBLE"
opcode-names[CONV-OPCODE-INT-BYTE] = "CONV-OPCODE-INT-BYTE"
opcode-names[CONV-OPCODE-INT-FLOAT] = "CONV-OPCODE-INT-FLOAT"
opcode-names[CONV-OPCODE-INT-DOUBLE] = "CONV-OPCODE-INT-DOUBLE"
opcode-names[CONV-OPCODE-LONG-BYTE] = "CONV-OPCODE-LONG-BYTE"
opcode-names[CONV-OPCODE-LONG-INT] = "CONV-OPCODE-LONG-INT"
opcode-names[CONV-OPCODE-LONG-FLOAT] = "CONV-OPCODE-LONG-FLOAT"
opcode-names[CONV-OPCODE-LONG-DOUBLE] = "CONV-OPCODE-LONG-DOUBLE"
opcode-names[CONV-OPCODE-FLOAT-BYTE] = "CONV-OPCODE-FLOAT-BYTE"
opcode-names[CONV-OPCODE-FLOAT-INT] = "CONV-OPCODE-FLOAT-INT"
opcode-names[CONV-OPCODE-FLOAT-LONG] = "CONV-OPCODE-FLOAT-LONG"
opcode-names[CONV-OPCODE-FLOAT-DOUBLE] = "CONV-OPCODE-FLOAT-DOUBLE"
opcode-names[CONV-OPCODE-DOUBLE-BYTE] = "CONV-OPCODE-DOUBLE-BYTE"
opcode-names[CONV-OPCODE-DOUBLE-INT] = "CONV-OPCODE-DOUBLE-INT"
opcode-names[CONV-OPCODE-DOUBLE-LONG] = "CONV-OPCODE-DOUBLE-LONG"
opcode-names[CONV-OPCODE-DOUBLE-FLOAT] = "CONV-OPCODE-DOUBLE-FLOAT"
opcode-names[DETAG-OPCODE] = "DETAG-OPCODE"
opcode-names[TAG-OPCODE-BYTE] = "TAG-OPCODE-BYTE"
opcode-names[TAG-OPCODE-CHAR] = "TAG-OPCODE-CHAR"
opcode-names[TAG-OPCODE-INT] = "TAG-OPCODE-INT"
opcode-names[TAG-OPCODE-FLOAT] = "TAG-OPCODE-FLOAT"
opcode-names[STORE-OPCODE-1] = "STORE-OPCODE-1"
opcode-names[STORE-OPCODE-4] = "STORE-OPCODE-4"
opcode-names[STORE-OPCODE-8] = "STORE-OPCODE-8"
opcode-names[STORE-OPCODE-1-VAR-OFFSET] = "STORE-OPCODE-1-VAR-OFFSET"
opcode-names[STORE-OPCODE-4-VAR-OFFSET] = "STORE-OPCODE-4-VAR-OFFSET"
opcode-names[STORE-OPCODE-8-VAR-OFFSET] = "STORE-OPCODE-8-VAR-OFFSET"
opcode-names[LOAD-OPCODE-1] = "LOAD-OPCODE-1"
opcode-names[LOAD-OPCODE-4] = "LOAD-OPCODE-4"
opcode-names[LOAD-OPCODE-8] = "LOAD-OPCODE-8"
opcode-names[LOAD-OPCODE-1-VAR-OFFSET] = "LOAD-OPCODE-1-VAR-OFFSET"
opcode-names[LOAD-OPCODE-4-VAR-OFFSET] = "LOAD-OPCODE-4-VAR-OFFSET"
opcode-names[LOAD-OPCODE-8-VAR-OFFSET] = "LOAD-OPCODE-8-VAR-OFFSET"
opcode-names[RESERVE-OPCODE-LOCAL] = "RESERVE-OPCODE-LOCAL"
opcode-names[RESERVE-OPCODE-CONST] = "RESERVE-OPCODE-CONST"
opcode-names[ENTER-STACK-OPCODE] = "ENTER-STACK-OPCODE"
opcode-names[ALLOC-OPCODE-CONST] = "ALLOC-OPCODE-CONST"
opcode-names[ALLOC-OPCODE-LOCAL] = "ALLOC-OPCODE-LOCAL"
opcode-names[GC-OPCODE] = "GC-OPCODE"
opcode-names[CLASS-NAME-OPCODE] = "CLASS-NAME-OPCODE"
opcode-names[C-RSP-OPCODE] = "C-RSP-OPCODE"
opcode-names[PRINT-STACK-TRACE-OPCODE] = "PRINT-STACK-TRACE-OPCODE"
opcode-names[COLLECT-STACK-TRACE-OPCODE] = "COLLECT-STACK-TRACE-OPCODE"
opcode-names[FLUSH-VM-OPCODE] = "FLUSH-VM-OPCODE"
opcode-names[JUMP-INT-LT-OPCODE] = "JUMP-INT-LT-OPCODE"
opcode-names[JUMP-INT-GT-OPCODE] = "JUMP-INT-GT-OPCODE"
opcode-names[JUMP-INT-LE-OPCODE] = "JUMP-INT-LE-OPCODE"
opcode-names[JUMP-INT-GE-OPCODE] = "JUMP-INT-GE-OPCODE"
opcode-names[JUMP-EQ-OPCODE-REF] = "JUMP-EQ-OPCODE-REF"
opcode-names[JUMP-EQ-OPCODE-BYTE] = "JUMP-EQ-OPCODE-BYTE"
opcode-names[JUMP-EQ-OPCODE-INT] = "JUMP-EQ-OPCODE-INT"
opcode-names[JUMP-EQ-OPCODE-LONG] = "JUMP-EQ-OPCODE-LONG"
opcode-names[JUMP-EQ-OPCODE-FLOAT] = "JUMP-EQ-OPCODE-FLOAT"
opcode-names[JUMP-EQ-OPCODE-DOUBLE] = "JUMP-EQ-OPCODE-DOUBLE"
opcode-names[JUMP-NE-OPCODE-REF] = "JUMP-NE-OPCODE-REF"
opcode-names[JUMP-NE-OPCODE-BYTE] = "JUMP-NE-OPCODE-BYTE"
opcode-names[JUMP-NE-OPCODE-INT] = "JUMP-NE-OPCODE-INT"
opcode-names[JUMP-NE-OPCODE-LONG] = "JUMP-NE-OPCODE-LONG"
opcode-names[JUMP-NE-OPCODE-FLOAT] = "JUMP-NE-OPCODE-FLOAT"
opcode-names[JUMP-NE-OPCODE-DOUBLE] = "JUMP-NE-OPCODE-DOUBLE"
opcode-names[JUMP-LT-OPCODE-INT] = "JUMP-LT-OPCODE-INT"
opcode-names[JUMP-LT-OPCODE-LONG] = "JUMP-LT-OPCODE-LONG"
opcode-names[JUMP-LT-OPCODE-FLOAT] = "JUMP-LT-OPCODE-FLOAT"
opcode-names[JUMP-LT-OPCODE-DOUBLE] = "JUMP-LT-OPCODE-DOUBLE"
opcode-names[JUMP-GT-OPCODE-INT] = "JUMP-GT-OPCODE-INT"
opcode-names[JUMP-GT-OPCODE-LONG] = "JUMP-GT-OPCODE-LONG"
opcode-names[JUMP-GT-OPCODE-FLOAT] = "JUMP-GT-OPCODE-FLOAT"
opcode-names[JUMP-GT-OPCODE-DOUBLE] = "JUMP-GT-OPCODE-DOUBLE"
opcode-names[JUMP-LE-OPCODE-INT] = "JUMP-LE-OPCODE-INT"
opcode-names[JUMP-LE-OPCODE-LONG] = "JUMP-LE-OPCODE-LONG"
opcode-names[JUMP-LE-OPCODE-FLOAT] = "JUMP-LE-OPCODE-FLOAT"
opcode-names[JUMP-LE-OPCODE-DOUBLE] = "JUMP-LE-OPCODE-DOUBLE"
opcode-names[JUMP-GE-OPCODE-INT] = "JUMP-GE-OPCODE-INT"
opcode-names[JUMP-GE-OPCODE-LONG] = "JUMP-GE-OPCODE-LONG"
opcode-names[JUMP-GE-OPCODE-FLOAT] = "JUMP-GE-OPCODE-FLOAT"
opcode-names[JUMP-GE-OPCODE-DOUBLE] = "JUMP-GE-OPCODE-DOUBLE"
opcode-names[JUMP-ULE-OPCODE-BYTE] = "JUMP-ULE-OPCODE-BYTE"
opcode-names[JUMP-ULE-OPCODE-INT] = "JUMP-ULE-OPCODE-INT"
opcode-names[JUMP-ULE-OPCODE-LONG] = "JUMP-ULE-OPCODE-LONG"
opcode-names[JUMP-ULT-OPCODE-BYTE] = "JUMP-ULT-OPCODE-BYTE"
opcode-names[JUMP-ULT-OPCODE-INT] = "JUMP-ULT-OPCODE-INT"
opcode-names[JUMP-ULT-OPCODE-LONG] = "JUMP-ULT-OPCODE-LONG"
opcode-names[JUMP-UGT-OPCODE-BYTE] = "JUMP-UGT-OPCODE-BYTE"
opcode-names[JUMP-UGT-OPCODE-INT] = "JUMP-UGT-OPCODE-INT"
opcode-names[JUMP-UGT-OPCODE-LONG] = "JUMP-UGT-OPCODE-LONG"
opcode-names[JUMP-UGE-OPCODE-BYTE] = "JUMP-UGE-OPCODE-BYTE"
opcode-names[JUMP-UGE-OPCODE-INT] = "JUMP-UGE-OPCODE-INT"
opcode-names[JUMP-UGE-OPCODE-LONG] = "JUMP-UGE-OPCODE-LONG"
opcode-names[DISPATCH-OPCODE] = "DISPATCH-OPCODE"
opcode-names[DISPATCH-METHOD-OPCODE] = "DISPATCH-METHOD-OPCODE"
opcode-names[JUMP-REG-OPCODE] = "JUMP-REG-OPCODE"
opcode-names[FNENTRY-OPCODE] = "FNENTRY-OPCODE"
